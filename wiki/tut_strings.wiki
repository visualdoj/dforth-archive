= Работа со строками =
Есть несколько разных типов строк.
=pchar=
C pchar можно работать так же, как и с указателем. Считается, что pchar ссылается на последовательность ascii-символов, завершающихся символом с кодом 0. Совместим с `char*` типом в C. При работе с pchar надо внимательно следить за тем, чтобы не было утечек памяти. Основное предназначение типа — взаимодействие с внешним кодом.

Изменение символов этой строки коснуться всех, кто на эту строку ссылается.

Для pchar есть все стековые команды (кроме `pchar-push`), `рchar.` для печати строки на консоль, а так же есть дополнительный набор команд
{{{
pchar" ссс"   ( -- pchar ) Создаёт строку типа pchar с символами ccc и кладёт указатель на неё на вершину стека. Эта строка константная, её освобождать не нужно.
}}}
{{{
pchar-alloc   ( n             -- pchar ) выделяет память на n полезных символов. (Т.е. выделится n+1 байт, один байт нужен под завершающий нуль.)
Ответственность за освобождение выделенной памяти лежит на пользователе.
pchar-free    ( pchar         --       ) освобождает память, выделенную при помощи pchar-alloc
pchar-len     ( pchar         -- n     ) кладёт длину строки
pchar-concat  ( pchar1 pchar2 -- pchar ) создаёт новую строку (так же как и pchar-alloc) и записывает в неё конкатенацию pchar1 и pchar2 (возможно, что эта команда будет пересмотрена). 
Ответственность за освобождение созданной строки лежит на пользователе.
pchar=        ( pchar1 pchar2 -- b     ) посимвольное сравнение строк
}}}
Вот так можно написать Hello world на строках с завершающим нулём:
{{{
pchar" Hello world!" pchar. cr
}}}
=str=
С типом str нельзя работать как с указателем — допустимо производить только операции начинающиеся с str-. 

Строка этого типа предназначена для использования внутри программы. Строки содержат счётчик кол-ва символов и счётчик ссылок. Это означает, что строка автоматически будет освобождена из памяти, как только на неё перестанут ссылаться. 

Изменение символов этой строки не изменит строку для всех прочих на неё ссылающихся.

Для строк этого типа работают все стековые операции, а так же:
{{{
str" ccc"  (           -- str       ) создаёт строку с символами ccc и помещает её на стек
str.       ( str       --           ) печатает строку на консоль
str=       ( str1 str2 -- str1=str2 ) проверяет совпадают ли строки между собой
str0       (           -- str-nil   ) кладёт нулевую строку на стек (0 символов)
str+       ( str1 str2 -- str       ) конкатенация двух строк
str#       ( str       -- int       ) кладёт длину строки
}}}
Программа Hello world на строках str:
{{{
str" Hello world!" str. cr
}}}
Вот несколько примеров, все они должны печатать TRUE
{{{
str" ab" str" cdef" str-concat str" abcd" str" ef" str-concat str= bool.
str-nil str" " str= bool.
}}}

Для удобства есть несколько команд для преобразований чисел в строки и обратно.
{{{
( %   -- str)
int->str int8->str int16->str int32->str int64->str
uint->str uint8->str uint16->str uint32->str uint64->str
single->str double->str extended->str
( str --   %)
str->int str->int8 str->int16 str->int32 str->int64
str->uint str->uint8 str->uint16 str->uint32 str->uint64
str->single str->double str->extended
}}}

{{{
str-pos    ( str sub -- i)  
str-delete ( spl-s)
str-copy   ( spl-s)
}}}
