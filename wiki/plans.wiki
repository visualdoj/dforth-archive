= TODO =

== DEBI ==
 # `exception-block`, `\exception-block`
== DESL ==
=== algorithms ===
 # `qsort`, `qsort-interval`
 # `heapsort`, `heapsort-interval`
 # `insertsort`, `insertsort-interval`
 # `insert-sorted`
 # `bin-search`

= Язык =

|| Функционал || Команды || Статус ||
|| || `;also` || ||
|| || `branch;` || ||
|| Поддержка словарей || || Отладка ||
|| Локальный словарь || || Готов ||
|| || `builtin` || ||
|| || `loop`, `+loop` || ||
|| || `do` || ||
|| L-стек || `l@ l! l+ l-` || ||
|| Векторизация (! нужно обдумать локальную векторизацию) || `doer` || ||
|| Векторизация || `make` || ||
|| || `0;` || Сделано || 
|| || `[str]"` `str"` `"` `pchar"` `[pchar]"` || Почти ||
|| Счётчиковый тип (?отдельный стек) || `cdrop cnip ... c@ c!` || ||
|| Динамический массив (модуль `dyn.de`) || || Сделано ||
|| Поддержка модулей || || Сделано ||
|| Работа с `xt` типом `xt.n@ xt.c@ xt.d@` || || ||
 

Вызов внешних функций.
  Так себе представляю названия функций:
        # ~~`:a (-)`~~ и `:a-noname (-)` — начать объявлять прототип внешней функции
        # ~~`a; (-)`~~ закончить объявлять прототип вызова внешней функции
        # ~~`stdcall ( -i)`~~ положить на стек `stdcall`-идентификатор вызова
        # ~~`cdecl ( -i)`~~
        # `afrom ( ss-)` берёт адрес для последней созданной функции из библиотеки
         с названием, которое лежит на вершине стека, функцию с именем, которое
         лежит предпоследним элементом стека. Если имя функции пустое, то
         в библиотеке будет найдена функция с именем, которое указано в качестве
         имени из конструкции `:a`
        # `toa ( "name" p-)` записывает адрес в созданный ранее прототип внешней функции
    Таким образом, объявление функции будет выглядеть как-то так
        `:a ExternalFunc t_int t_int t_int t_void stdcall a;`
    Далее, следует вызовом `<ptr> toa ExternalFunc` записать адрес внешней 
    функции, которая должна вызываться при вызове команды `ExternalFunc`. 
    Ещё можно сделать так:
        `:a-noname t_int t_int t_int t_void stdcall a;`
    Оно оставит на стеке `xt` команды.

== Стратегия развития ==

 * Версия 0.10 (сделано)
   # Работа со стеком
   # Типы int и bool
   # Создание собственных команд: обычных и immediate
   # Поддержка команд branch, ?branch, >mark, >resolve, <mark, <resolve и compile для реализации условных переходов и циклов
   # Три режима: интерпритация, компиляция в шитый код и исполнение
 * Версия 0.20
   # Возможность подключения внешних библиотек (dll)
   # Удобный механизм для создания прототипов вызываемых функций (поддержка cdecl, stdcall)
   # Создание callback команд для экспорта во внешний код
   # Поддержка простейших типов: целые числа, числа с плавающей точкой, указатели и pchar  
   # Работа с переменными 
   # Консоль: чтение данных
 * Версия 0.30
   # RTL: работа со временем
   # RTL: работа с файлами
   # Компилятор: поддержка отладочного режима: дампы шитого кода, стеков и переменных, контроль за операциями на стеке, отслеживание утечек памяти
   # Функционирование команд с локальной областью видимости
   # ...
 * Версия 0.40
   # Компиляция программы, использующей возможности версии 0.1, в исполняемый файл (exe)
   # Введение оптимизатора кода по размеру: отбрасывание ненужного RTL, упаковка вызовов частоиспользуемых команд в 1 или 2 байта
   # ...