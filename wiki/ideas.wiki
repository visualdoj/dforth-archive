= Размышления =
== Виды кода и преобразования их между собой ==
{{{
source -> Meta Embro -> Meta Asm
Meta Embro <-> input/output
Meta Embro -> dump
Meta Embro -> Executable Embro
Meta Asm <-> input/output
Meta Asm -> dump
Meta Asm -> Executable Asm
}}}

Исходник преобразуется в «Meta Embro».
«Meta Embro» можно
 # Сконвертировать в «Executable Embro» и выполнить
 # Сдампить
 # Сохранить или загрузить в/из потока
 # Скомпилировать в Meta Asm

{{{
TMeta = class
  Save(Stream);
  Load(Stream);
  Dump(TextStream);
end;
}}}

Аналогичные действия можно проделать с «Meta Asm».

{{{
TMetaEmbro = class
  Start[Command/Data]();
  Write[Raw/Call/Int/Ptr/Embro/Str/...](Value);
  GetIterator(Embro, out Iterator): Error;
  ClearLast();
  ClearTo[Embro/Xt](...);
end;

TMetaEmbroIterator = class
  Next(): Boolean;
  _End(): Boolean;
  EmbroType: Command/Data;
  RecordType: Raw/Call/Int/Ptr/Embro/Str/...;
  Value: ...
end;

GetIterator(Xt, out Iterator): Error;
}}}

== Ассемблерное приложение, генерируемое дембро-транслятором ==
При старте приложения инициализируются нужные структуры дембро-машины. Часть указателей сохраняется в регистрах, часть выносится в память отдельной структурой (dembro machine), ссылка на которую должна быть локальна для данной нити, ибо в случае создания многопоточного приложения структуры нужно дублировать. Видимо, инициализация этой структуры должна быть выделена в отдельную процедуру, для использования при многопоточности.

Распределение по регистрам должно (в идеале) определяться конфигом дембро. Есть проблема, заключающаяся в неортогональности системы команд ia-32 в использовании регистров (некоторые команды нельзя применять к некоторым регистрам).

Примерное распределение:
{{{
eax - TOP/SEC - top of w
ecx - 
edx - SEC/TOP - sec of w
ebx -
esp - RP  - top of r stack
ebp - RB  - base of r stack
esi - WP  - top of w?
edi - DE  - dembro machine?
}}}

Смысл регистров eax и ebx должен меняться, чтобы не делать постоянно swap. (И поэтому действие `swap TOP<->SEC` чисто формальное.)

Примерно действия:
{{{
; 1+
inc TOP
; 1 такт

; 5
mov [WP], SEC
add WP, 4
mov SEC, 5
swap TOP<->SEC
; 1 + 1 + 1 = 3 такта
; с учётом спаривания: 2 такта

; + 
add TOP, SEC
sub WP, 4
mov SEC, [WP]
; 1 + 1 + 2 = 4 такта

; swap
swap TOP<->SEC
; 0 тактов :)

; over
mov [WP], SEC
add WP, 4
swap TOP<->SEC

; dup
mov [WP], SEC
add WP, 4
mov SEC, TOP
}}}

== Кроссплатформенность ==
Кроссплатформенность — возможность корректного выполения одной и той же программы на разных «платформах» (примеры платформ: операционные системы, процессоры). Таким образом, чтобы DEmbro был пригоден для кроссплатформенных разработок, он должен
 # Запускаться на разных платформах
 # Предоставить программисту возможность писать кроссплатформенные программы
Кроссплатформенность создаёт некоторые ограничения: если на какой-то платформе поддерживается особенная фича, отсутствующая на других, то ею нельзя пользоваться. В качестве некоторого упрощения можно попытаться найти некоторую «базу» — самое основное, что необходимо для программирования, и присутствует на всех платформах.
=== Запуск DEmbro на разных платформах ===
Для решения этой задачи в качестве языка разработки ядра DEmbro используется компилятор Free Pascal. Если не использовать платформозависимых библиотек языка, появиться возможность портировать ядро на те платформы, на которых портирован Free Pascal, а конкретней [http://www.freepascal.org/faq.var#FPandGNUPascal см. список].
=== Возможность написания кроссплатформенных программ на DEmbro ===
==== Операционные системы ====
Примерный список того, что требуется обычно от операционной системы (повторюсь, что цели обеспечить полнофункциональное RTL нет):
 # Файловая система
   # Получение состояния файла (дата изменения, размер, флаги и т.д.)
   # Операции над файлами (копирование, удаление, перемещение, проверка существования и т.д.)
   # Чтение/запись файлов, скорее всего достаточно только бинарных.
   # Операции над директориями (получение списка файлов в директории)
   # Стандартный ввод/вывод программы
 # «Командная строка»
   # Запуск других программ 
     # Возможность чтения и запись в потоки дочерней программы
     # Получение результата (ExitCode) от дочерней программы
     # Поддержка в строке запуска pipe'ов, перенаправлений в файлы, последовательностей выполнения и распараллеливание выполнения
   # Считывание переданных при запуске параметров.
 # Поддержка подключения динамических библиотек 
   # Подключить библиотеку
   # Получить функцию 
   # Выполнить функцию
   # Освободить библиотеку
 # Сеть — сокеты Беркли, скорее всего TCP и UDP достаточно
 # Многопоточность
   # Потоки (создать, запустить, переключиться)
   # Критические секции (создать, удалить, заблокировать, разблокировать)
 # Время (получение текущего, таймеры, засыпание на сколько-то миллисекунд)
 # Гуи
   # MessageBox
   # Создание классических оконных элементов (window, label, button, memo, ...)
   # Обработка обычных событий (нажатия клавиш, клики, изменения состояний)
==== Процессоры ====


== Проблемы с проектированием DEmbro ==
=== Типы константного размера, отличающегося от размера ячейки ===
Важные такие типы: float, double, int64, int8, пользовательские струтуры.
==== Почему операции над ними затруднительно производить через главный стек ====
Основной стек DEmbro, через который происходят все операции с числами и указателями, предназначен для хранения ячеек — значений, занимающих фиксированный размер в памяти.

Никаких метаданных о содержимом стека не хранится, обеспечение этого может неоправданно замедлить программу. Кроме того, постфиксная запись выражений не позволяет интерпретатору угадать какого типа операнды будут на вершине стека во время выполнения определённой команды.

Приведу иллюстрирующий пример. Например, для целых чисел и чисел с плавающей точкой должны поддерживаться команды сложения, причём они различные. Хотелось бы (теоретически), чтобы обе команды обозначались одним символом «+». Тогда в следующей псевдопрограмме будет понятно, что делается:
{{{
4 5 +
1.2f 1.3f +
}}}
Теперь объявим команду, которая состоит из вызова «+»:
{{{
: add + ;
}}} 
И произведём сложение при помощи неё:
{{{
4 5 add
1.2f 1.3f add
}}}
Тут уже непонятно как должен интерпретатор себя вести. В момент компиляции add неизвестно какие параметры команда будет принимать, а значит неизвестно какую операцию «+» компилировать — целую или для плавающей точки. Создавать «add» для всех возможных входных типов — плохая идея, т.к. операция «add» могла бы выглядеть так:
{{{
: add + + + + +  + + + + + ;
}}}
т.е. может произойти комбинаторный взрыв. Если же не создавать «add» на все возможные комбинации типов входных параметров, то один из вызовов «add» выше осуществить не удастся. Это достаточно простые случаи, но есть и более сложные, в которых эта проблема встаёт более остро (например, когда есть циклы или условные операторы). (Может показаться, что объявление «add» нетипичное, потому что параметры не фиксированны. Это не так: это стандартный способ для DEmbro передать параметры в команду.)

Во многих языках программирования есть понятие перегрузки (overloading) функций — когда есть несколько функций с одним названием, но для разных типов входных парамтеров. Сказанное выше по сути означает, что в языках с постфиксной записью выражений (в частности, в DEmbro) организовать перегрузку невозможно. Т.е., получается, что *для разных типов параметров должны быть команды с разными названиями.*

В частности, вместо просто «+» следует иметь две версии команды (например, «int+» и «float+»). Это же касается всех операций, которые могут выполняться для разных типов.

Разные типы могут занимать разное число байт в памяти. int32 занимает 4 байта, float — 4 байта, double — 8 байт, int16 — 2 байта, и т.д. Размер ячейки может варироваться: 4, 8, или даже 2 байта. Язык должен поддерживать работу с этими типами данных. Первое, что приходит в голову — хранить все числа в главном стеке. Если ячейка занимает 4 байта, то float займёт одну ячейку стека, а double — две. Но на другом процессоре ячейка может занимать 8 байт, и тогда float и double займут одну ячейку.

При работе со стеком необходимо иметь операции, которые меняют местами и копируют элементы стека. Например, есть операция swap, которая меняет две верхних ячейки стека. Если же нужно поменять местами два float'а, то потребуется команда для них: скажем, «float-float-swap». Если же потребуется менять местами float и ячейку, то потребуется команда «float-cell-swap». А ещё есть double, его нужно уметь местами с другим double, float'ом и ячейкой. А ещё есть типы int8, int16, int32, int64 — их тоже надо уметь менять местами. А ещё, кроме обмена местами, есть команды «tuck», «nip», «lrot», «rrot» — для них ведь тоже много комбинаций, у последних двух даже три параметра!

Добавим пользовательские струтуры, которые тоже нужно где-то хранить и производить операции, и поймём, что это непригодное решение.

Именно так я изначально и спроектировал DEmbro, и уже через несколько месяцев столкнулся с серьёзными проблемами.

==== Почему в других языках этой проблемы нет ====

Основной стек DEmbro не является аналогом обычного стека — на обычном стеке выделяются переменные при входе в функции, и освобождаются при выходе, при этом операции над ними происходят обычным образом, сходным с глобальными переменными или регистрами: можно получить доступ к любой локальной переменной.

В DEmbro главный стек используется для вычислений, его размер постоянно меняется, поэтому доступ к какому-то конкретному элементу затруднён (т.к. его положение относительно вершины стека меняется). В DEmbro будет (и частично уже есть) стек возврата и локальных переменных (r и l), который можно считать аналогом обычного стека.

==== Ещё один довод против хранения на основном стеке ====

Хочется, чтобы программа, оперирующая с float, и программа, оперирующая с double, были абсолютно похожи за тем исключением, что команды, работающие с float нужно бы было заменить на операции, работающие с double.

Почему это хочется? Потому что если работа с ними будет отличаться, то какая-то будет лучше, и программист будет выбирать тип, с которым работать, не объективно, а исходя из удобства (под «программист» я тут подразумеваю в первую очередь себя).

Если же в программе предполагается, что float занимает одну ячейку, а double — две, то это свойство нарушится: для float'ов можно использовать операции со стеком над ячейками, а для double'ов хитрить.

=== Метаданные о шитом коде и данных ===