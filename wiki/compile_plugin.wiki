Всё самое свежее нужно смотреть в файле [http://code.google.com/p/dforth/source/browse/trunk/source/plugins/dec.h dec.h]

В [http://code.google.com/p/dforth/source/browse/trunk/source/plugins/#plugins/deArhimag папке plugins\deArhimag] находится плагин. `make` запускает его компиляцию, `make test` запускает компиляцию `deArhimagTest.cpp`. Полезным для понимания как нужно писать плагины является изучение файлов `deArhimagTest.cpp` и `examples.cpp`.

Если плагин скомпилирован в режиме `make test`, то при компиляции он сделает следующие действия
  # Создаст файл `commands~` с таблицей команд, переданных плагину. `i` означает, что команда `immediate`, `b` означает, что команда встроена. Если у команды указано два числа, то первое -- code (embroptr, положение в шитом коде, начиная с которого начинается код или начинаются данные), а второе число -- data, смысл этого параметра зависит от команды.
  # Создаст файл `code~` с переданным плагину шитым кодом. Число в начале каждой строки -- номер байта в шитом коде, с которого начинается команда. Далее идёт либо название вызываемой функции, либо размер данных, после чего сами данные в шестнадцатиричном виде. В конце строки может быть комментарий с названием команды, которой принадлежит код, начиная с данного места.

=== Описание (возможно, устаревшее) ===
{{{
const int TYPE_INT = 1;
const int TYPE_STR = 2;
const int TYPE_DATA = 3;
}}}
{{{
void __stdcall decSetParam(int id, int type, void* val, int size = 0);
}}}
Устанавливает определённое значение переменной
  * `id` — идентификатор устанавливаемой переменной
  * `type` — тип устанавливаемого значения (см. константы `TYPE_*`)
  * `val` — значение переменной или указатель на данные (см. ниже)
  * `size` — размер области данных, если он нужен
В случае, если `id` отрицательна или превышает максимально допустимое значение, либо тип `type` имеет недопустимое значение, функция ничего не должна делать. Действия функции зависят от значения переменной `type`:
  * `TYPE_INT` — значение переменной хранится в самой переменной `val`, оно просто запоминается, параметр `size` игнорируется
  * `TYPE_STR` — переменная `val` является указателем на строку с завершающим нулём. Значение переменной `size` должно быть равно кол-ву символов, включая завершающий нуль. Компилятор должен *скопировать* строку в свою память (а не запоминать ссылку). Если `val` имеет значение `NULL` или `size<=0`, функция должна установить тип переменной в `TYPE_STR` и значение в `NULL`. Если `val` не ссылается на строку с завершающим нулём, либо `size` имеет некорректное значение, действие функции не определено.
  * `TYPE_DATA` — записываются данные с особой стрктурой. В `val` хранится указатель на область данных, а в `size` размер структуры, смысл которого для каждой переменной индивидуален. Функция *не должна* копировать данные, а должна запомнить указатель и размер. Если `size<0`, то считается, что указано `size=0`.

{{{
void __stdcall decCompile();
}}}
Выполняет компиляцию. Конкретные действия зависят от значений переменных. Ниже
дан список их идентификаторов, в скобках указан необходимый тип
  * ID_APPTYPE = 1 (TYPE_INT)
        * APPTYPE_CONSOLE       = 1 (default)
        * APPTYPE_GUI           = 2
  * ID_OUTPUT   = 2 (TYPE_STR) (default "a.exe") имя выходного файла
  * ID_COMMANDS = 3 (TYPE_DATA) (default NULL 0) указатель на таблицу команд
  * ID_CODE     = 4 (TYPE_DATA) (default NULL 0) указатель на дамп шитого кода

{{{
int __stdcall decError(int* id, int* pos);
// id — код последней ошибки
// pos — место, где возникла ошибка
// если функция вернула 0, то ошибок нет, иначе в параметрах оказывается
// информация об ошибке
// после этого ошибка извлекается из очереди, и последующий вызов выдаст 
// следующую возникшую ошибку.
char*  __stdcall decErrorString(int id);
// возвращает описание ошибки по её идентификатору
}}}
{{{
void __cdecl decParse(const char* format, ...);
}}}

=== Таблица команд (ID_COMMANDS) ===
В val находится значение типа commands_t, в поле size кол-во элементов массива
{{{
typedef struct command_s {
  char* name; // имя команды
  int flags; // флаги; bit0 является ли команда immediate
             // bit1 является ли команда встроенной, или она является функцией
             // в первом случае код будет сгенерирован плагином, во втором
             // он указан в полне code
  int code; // номер байта в embro, начиная с которого идёт описание
  int data; // номер байта в embro, начиная с которого находятся данные для команд
} command_t;
typedef command_t* commands_t;
}}}

=== Шитый код, embro (ID_CODE) ===
В val находится значение типа embro_t, в size число элементов массива
{{{
typedef struct embro_item_s {
  int opcode; // номер команды в таблице команд, которую нужно выполнить
  void* data; // данные, следующие за командой
  int size;
} embro_item_t;
typedef embro_item_t* embro_t;
}}}

=== Таблица ссылок (ID_REFS) ===

{{{
typedef int* refs_t;
}}}