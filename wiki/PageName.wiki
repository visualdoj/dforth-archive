= Компиляция =

Как я себе представляю процесс компиляции: вначале дембро-машина просто выполняет некоторый код. В итоге получается куча скомпиленного в шитый код.
После этого наченается «сборка бинарника»: программа на DEmbro, при интерпретации которой конфигурируются все необходимые параметры (типа информации о том, какая функция главная, для какого режима компилируем — `CONSOLE` или `GUI`, используем ли оптимизацию, требуем ли поддержку плагинов и т.д.) и после чего запускается собственно сборщик бинарника
Он соптимизирует всё что нужно, и сохранит в exe.

При создании окончательного кода есть несколько проблем.
  # Стеки в DEmbro (за исключением `R` возвратов) должны расти в сторону увеличения адреса, что не общепринято. Стек `W` так же очень трудно имитировать при помощи аппаратно поддерживаемых стеков, так как он должен работать с не выровнеными данными.
  # У дембро-машины много структур, а регистров всего восемь. Нужно продумать что хранить в регистрах, что в памяти, а что вообще не хранить (например, указатель на таблицу команд можно не хранить, а держать таблицу в виде глобальной переменной. Тогда обращение к ней будет иметь вид `mov EAX, [CommandID*4 + table_offset]`).

== Оптимизация ==

Оптимизация должна выполнять следующие задачи:
  # Оптимизация скорости. 
    Шитый код невозможно проанализировать. Так как в нём не только команды, но ещё и данные, которые команда считывает. Поэтому чтобы можно было оптимизировать, нужно ещё параллельно хранить положения команд на исполнение где команды начинаются. А так же знать адреса переходов, так как они должны меняться при изменении кода.
  # Помимо оптимизаций скорости, хотелось бы выполнить оптимизации размера. Вырезать ненужные команды, это самое главное, — данные и код, которые используются только при компиляции в exe. 
    Для этого уже потребуется хранить некий граф связей — кто на кого ссылается. И я не знаю всегда ли такой возможно построить.