= Использование в качестве скриптового движка (в разработке) =

dembro32.dll имеет небольшой набор функций для использования DEmbro в качестве скриптового движка.

{{{
  function deCreateMachine: Pointer; stdcall; external 'dembro32.dll';
}}}
Создаёт новую форт-машину, возвращает указатель, с которым потом будет происходить работа.
{{{
  procedure deFreeMachine(machine: Pointer); stdcall; external 'dembro32.dll';
}}}
Уничтожает созданную ранее форт-машину.
{{{
  procedure deInterpret(machine: Pointer; typ: Integer; source: PChar); stdcall; external 'dembro32.dll';
}}}
Выполняет заданную программу на созданной ранее форт-машине. source должно быть ansi-строкой с завершающим нулём. typ обязана имет значение DE_SOURCE_PCHAR.
{{{
  procedure deAddCommand(machine: Pointer; 
                         name: PChar; 
                         CallBack: Pointer;
                         Data: Pointer;
                         Immediate: Boolean
                        ); stdcall;
}}}
Регистрирует новую команду с именем name. Параметры:
  # machine — форт-машина, в которую будет добавлена команда
  # name — имя добавляемой команды
  # callback — функция, которая будет запускаться при вызове команды
  # data — значение, которое будет передано в callback при её выполнении
  # immediate — является ли команда immediate
При её выполнении будет вызываться функция callback, которая обязана иметь следующий заголовок:
   {{{
      procedure (machine: Pointer; data: Pointer); stdcall;
   }}}

{{{
function deVar(machine: Pointer; 
               valtype: Integer; 
               action: Integer; 
               ptr: Pointer;
               size: Integer; 
               pos: Integer): Integer; stdcall;

}}}
Функция для установки и чтения значений переменных и выполнения операций со стеками форт-машины. Параметры:
    # machine — форт-машина, в которой производится нужная операция
    # valtype — переменная или стек, с которой мы производим действие. Может принимать следующие значения:
      * DE_IGNORE                     = 0; // игнорировать
      * DE_USERDATA                   = 1; // пользовательская переменная 
      * DE_W                          = 2; // стек W (основной)
      * DE_R                          = 3; // стек R (возвратов)
      * DE_L                          = 4; // стек L (локальных переменных)
    # action — производимое действие. Может принимать значения:
      * DE_IGNORE                     = 0; // игнорировать
      * DE_READ                       = 1;
      * DE_WRITE                      = 2;
      Для стеков так же допустимы следующие действия:
      * DE_PUSH                       = 3;
      * DE_POP                        = 4;
    # ptr — указатель на область в памяти, в которой находится передаваемые данные, или область, в которую нужно записать считываемые данные.
    # size — размер передаваемых/получаемых данных. При valtype = DE_USERDATA игнорируется.
    # pos — отступ от вершины стека. Не игнорируется только когда в valtype указан какой-то стек, а в action = DE_PUSH или DE_POP. 
    # возвращаемое значение может быть одним из следующих
      * DE_OK                         = 0; // всё прошло без ошибок
      * DE_ERR_UNKNOWN_VALTYPE        = 1; // некорректное значение параметра valtype
      * DE_ERR_UNKNOWN_ACTION         = 2; // некорректное значение параметра action


Переменная DE_USERDATA может использоваться пользователем библиотеки по своему усмотрению. Форт-машина её просто хранит и ничего с ней не делает. Для 32-битной форт-машины переменная занимает 4 байта.
{{{
  deVar(machine, DE_USERDATA, DE_WRITE, @a, 0, 0); // записать значение a в userdata
  deVar(machine, DE_USERDATA, DE_READ, @a, 0, 0); // считать в a значение userdata
}}}
Работа с каждым стеком DE_W, DE_R и DE_L аналогична. Команды DE_PUSH, DE_POP
используются для выполнения обычных операций со стеком. Параметр size указывает
размер данных, pos игнорируется. Возможно передавать ptr=nil, при этом вершина массива сдвинется, но с данными ничего не произойдёт (обратите внимание, что это единственный случай когда можно использовать nil, при других valtype или action последствия непредсказуемы).
{{{
  deVar(machine, DE_W, DE_PUSH, @a, SizeOf(a), 0); // заталкивание значения a в стек
  // чтение массива a из стека
  deVar(machine, DE_W, DE_POP, @a[0], SizeOf(a[0])*Length(a), 0);
  // просто увеличение вершины стека на 4 размера типа Integer 
  deVar(machine, DE_W, DE_POP, nil, 4*SizeOf(Integer), 0);
}}}
Кроме того, можно произвольным образом работать со стеком. Для этого можно использовать команды DE_WRITE, DE_READ. Параметр pos будет означать смещение относительно вершины стека, по которому нужно записать/прочитать. При этом смещение вершины стека не произойдёт.
{{{
  // прочитать с вершины стека в а
  deVar(machine, DE_W, D_READ, @a, SizeOf(a), -SizeOf(a));
  // записать в вершину стека значение а
  deVar(machine, DE_W, D_WRITE, @a, SizeOf(a), -SizeOf(a));
}}}
