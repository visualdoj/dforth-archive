= Объектная подсистема =

== Главная проблема ==

В первую очередь приходит на ум идея о том, что объект представляет из себя ссылку на стеке. Когда вызывается метод, он снимает объект со стека и выполняется. Но возникает трудность с именованием метода: рассмотрим такой пример (псевдокод):
{{{
0 defclass B
  : method1 ... ;
/defclass

0 defclass A
  B class -- b // создали поле — класс типа B
  : method1 ... ;
/defclass

: test method1 ;

A.create value a
a test
B.create value b
b test

a method1
}}}
Как определить на этапе компиляции какой из двух method1 вызвать внутри test? Никак — если хотеть, чтобы этот код был корректен, то диспетчеризация вываливается в рантайм, а этого я не хочу, либо следует признать, что глобальный .method1 у B перекрывает глобальный метод у A. Тогда можно для обеспечения доступа к перекрытым методам использовать пространства имён — у каждого класса есть пространство имён, совпадающее с именем класса, и вызов метода выражается так:
{{{
A create value a
a A method1
}}}
При этом использовать последний определённый method1 можно без явного указания класса.

== Синтаксический сахар в обращении ==
К примеру, есть код
{{{
A create value a
a A method1
}}}
В нём нам бы хотелось обойтись без явного указания класса A при вызове метода, при этом DEmbro-машине для определения вызываемого method1 пользоваться информацией, хранящейся в словаре для a. Таким образом, создание переменной a следует осуществлять специальной конструкцией
{{{
A create A value a
}}}
а обращение к методу производить через специальный синтаксис точки:
{{{
a. method1
}}}
В случае обращения к полю, которое тоже является объектом некоторого класса, можно продолжить синтаксис точки:
{{{
a. b. method1
}}}
Семантика интерпретации (а нужна ли?)
  # Кладём a на стек
  # Определяем класс a, т.е. A (если класс не определён — действие не определено)
  # Ищем в A метод b.
  # Передаём управление «b.»
  # Кладём b на стек
  # Определяем класс b, т.е. B
  # Ищем в B метод method1
  # Передаём управление методу method1

Семантика компиляции
  # Компилируем действие «Кладём a на стек»
  # Определяем класс a, т.е. A
  # Ищем в A метод b.
  # Передаём управление «b.»
  # Компилируем действие «Кладём b на стек»
  # Определяем класс b, т.е. B
  # Ищем в B метод method1
  # Компилируем «вызвать method1»
Отмечу, что это не единственный способ обращения, функциональность предыдущего раздела не теряется.

== Объявление классов ==
{{{
A class defclass C // класс C наследуем от A
 private // запрещаем получать доступ извне к последующим элементам  
  int -- i // создали поле типа int
  B class -- b // создали поле типа B class
 private r // можно извне читать следующие переменные
  float -- f
 public // всё возможно
  double -- d
  // метод экземпляра, self лежит на стеке
  : simplemethod b. DoSomething ;
  // метод экземпляра, self лежит в одноимённой локальной переменной 
  +: method1 i@ 5 + i! ;
  // метода класса, self не передаётся
  -: classmethod 100 . ;
/class // завершаем объявление класса 
}}}
Поля суть несколько методов. Для обычных переменных генерируется три метода (в зависимости от настроек областей видимости не все будут видны извне). Для d ими будут следующие методы
{{{
d ( С-p) положить указатель на поле d
d@ ( C-d) прочитать значение поля d, в виде метода: : d@ d double@ ;
d! ( dC-) записать значение в поле d, в виде метода: : d! d double! ;
}}}
Для b добавляется ещё один — для синтаксиса точки
{{{
b. ( "name") immediate поглащает следующее слово входного потока, выполняет необходимое для него
}}}

За видимость отвечают несколько глобальных переменных
|| Переменная || Смысл ||
|| `*r*` || Можно ли извне читать ||
|| `*w*` || Можно ли записывать извне || 
|| `*ir*` || Можно ли читать из унаследованного класса || 
|| `*iw*` || Можно ли записывать из унаследованного класса ||

{{{
: public *r* on *w* on *ir* on *iw* on ;
: private *r* off *w* off *ir* off *iw* off ;
: protected *r* off *w* off *ir* on *iw* on ;
: r *r* on *ir* on ;
: w *w* on *ir* on ;
: wr public ;
}}}

За наследование так же отвечают несколько глобальных переменных
|| Переменная || Смысл ||
|| `*inherited-mode*` || Режим наследования ||

{{{
enum inherited-mode:
inherited-mode: STATIC
inherited-mode: VIRTUAL
inherited-mode: OVERRIDE
variable *inherited-mode*

: static STATIC *inherited-mode* ! ; 
: override OVERRIDE *inherited-mode* ! ;
: virtual VIRTUAL *inherited-mode* ! ;
}}}

== Стандартные классы ==
{{{
0 defclass CIterator
 virtual : next ( - ... false | true ) drop true ;
/defclass

CIterator class defclass CDynIterator
 ptr -- d
 int -- index
 override -: create ( d-) inherited tuck self d! 0 index! ;
 override +: next index@ d@ dyn# < if index@ dup 1+ index! false else
                                      true then ;   
/defclass
}}}