= Стандарт DEmbro v0.12 (в разработке) =

 # [standart#1._%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5 Введение]
 # [standart#2._%D0%A2%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D1%8B_%D0%B8_%D0%BE%D0%B1%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F Термины и обозначения]
 # [standart#3._DEmbro_Virtual_Machine_(DEVM,_%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%88%D0%B8 DEmbro Virtual Machine (DEVM, виртуальная машина DEmbro)]
 # [standart#4._DEmbro_Built-in_Commands_(DEBI,_%D0%B2%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B0 DEmbro Built-in Commands (DEBI, встроенные команды DEmbro)]
 # [standart#5._DEmbro_Standart_Libraries_(DESL,_%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B5_%D0%B1%D0%B8%EF%BF%BD DEmbro Standart Libraries (DESL, стандартные библиотеки DEmbro)]
 # [standart#6._DEmbro_Compiler_and_Optimizer_(DECO,_%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80_%D0%B8 DEmbro Compiler and Optimizer (DECO, компилятор и оптимизатор)]
 # [http://code.google.com/p/dforth/wiki/standart#7._DEmbro_Code_Style_(DECS,_%D1%81%D1%82%D0%B8%D0%BB%D1%8C_%D0%BE%D1%84%D0%BE%D1%80%D0%BC%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B8%D1%81 DEmbro Code Style (DECS, стиль оформления исходных кодов на DEmbro)]

== 1. Введение ==
Цель данного стандарта — упростить написание переносимых программ на `DEmbro`.

В стандарте содержатся
  # Описание стандартного поведения DEmbro-машины.
  # Документация на все стандартные команды.
  # Стандартный стиль оформления исходных кодов
== 2. Термины и обозначения ==
=== 2.1 Термины ===
*`DEmbro`* — (1) язык программирования, (2) виртуальная машина, интерпретатор,
скриптовый движок и компилятор.

*Стек* — структура данных, основными операциями которой являются заталкивание и 
извлечение данных, причём извлечение происходит в порядке, противположном тому, в котором их затолкнули.

*Блок* — участок памяти, выделенный в куче, в первой ячейке которого хранится счётчик — число ссылок на этот блок. 
относительно вершины стека.
Блок является атомарным типом и не должен содержать в себе умных указателей, так как при освобождении блоков освобождается 
только занимаемая им область данных

*Рабочий стек* или *`W`* — основной стек dembro-машины, при помощи которого команды выполняют операции с данными (вычисления).

*Рабочий стек блоков* или *`BW`* — отдельный стек, в котором хранятся указатели на блоки. При выполнении операций со стеком счётчик в блоках обновляется.

*Стек вызовов* или *`R`* — стек для хранения адресов, которым будет возвращено управление после выполнения функции.

*Стек локальных переменных* или *`L`* — стек для размещения временных переменных в рамках определённой функции.

*Шитый код* — множество областей памяти, в которых размещаются скомпилированные команды и глобальные переменные.

*Ячейка* — область памяти, занимающая стандартный размер. Для 32-битных систем — 
4 байта, для 64-битных — 8 байт. Ячейками являются данные типов int, ptr, uint, 
но не являются данные типов int32, int64, int8, double.
=== 2.2 Обозначения ===
==== 2.2.1 Стек ====
*Замечание.* Описываемая ниже стековая нотация не является каким-то синтаксическим элементом языка DEmbro, а служит лишь для удобства документирования.

При описании стеков применяется *стековая нотация*: элементы стека записываются
последовательно, чем элемент правее, тем выше он на стеке. Самый правый элемент
лежит на вершине стека. Примеры:
{{{
7 3 5 9 0 4 2 1
}}}
Здесь элемент `1` лежит на вершине стека, `2` ниже вершины и т.д.
{{{
one two three
}}}
Здесь элемент `three` лежит на вершине стека, `two` ниже вершины и т.д.

Допустимо записывать не весь стек целиком, а только верхнюю его часть, если 
элементы, лежащие ниже, не рассматриваются.

При описании стека в качестве элементов могут быть записаны:
 # Значения элементов стека
 # Переменные, подразумевающие некоторое неизвестное значение
 # Типы элементов стека

Что именно записано, должно быть описано или понятно из контекста. Последний
пункт можно совмещать с предыдущими: для этого после значения или переменной
ставится двоеточие, после которого идёт название типа. Пример:
{{{
3:int 5366:uint64 true:bool f:flag i:int
}}}

Элементы стека разделяются пробелом, запятой или другим оговоренным символом,
не используемым в других целях в стековой нотации.

Разделитель не должен использоваться внутри записи одного элемента. Следующие 
записи некорректны:
{{{
x: int y: int z: int
}}}

В этом случае следует использовать запятую:
{{{
x: int, y: iny, z: int
}}}

Разделитель можно не использовать в том случае, когда запись элемента стека 
занимает один символ и отсутствие разделителя не порождает неправильной трактовки. 
Этот вариант записи называется *краткой нотацией*. Пример:
{{{
ifhii
}}}

Некорректные примеры записи содержимого первых примеров (неправильность 
трактовки и многобуквенность элементов соответственно):
{{{
73590421
}}}
{{{
onetwothree
}}}

При записи стека на нескольких строках действует следующее правило: чем элемент
ниже, тем он выше на стеке. Пример:
{{{
6 1 3
5 9 8
7 4 2
}}}
Эта запись эквивалентна записи
{{{
6 1 3 5 9 8 7 4 2
}}}

Если требуется записывать содержимое нескольких стеков, то перед записью его 
содержимое ставится название стека и двоеточие после него:
{{{
W: ifhii
R: 777 888 999
}}}

Если требуется записать состояния стека до некоторого преобразования и после, то
эти записи отделяются друг от друга двойным знаком дефиса `--`. Пример:
{{{
one second three -- second five
}}}

Подобная запись называется *стековая нотация изменения* или 
*стековая нотация преобразования*, или просто *нотация изменения* или
*нотация преобразования*.

При использовании краткой нотации допустимо использовать один символ дефиса `-`.
Пример:
{{{
ifhii-iih
}}}

Если в нотации изменения используется переменная, подразумевающая некоторое
значение, и она используется в обеих частях изменения, то это означает, что
в обеих частях её значение одинаково. Например, запись
{{{
fisrtvar secondvar -- firstvar newvar fisrtvar
}}}
означает, что в правой части оба `fisrtvar` равны значению `firstvar` из левой 
части.

В случае, если в правой части стекового изменения нет элементов, то двойной
дефис можно опустить. Например,
{{{
alpha beta gamma --
}}}
можно заменить на
{{{
alpha beta gamma
}}}
Наоборот делать нельзя.
== 3. DEmbro Virtual Machine (DEVM, виртуальная машина DEmbro) ==
=== 3.1 Составляющие ===
`DEVM` оперирует следующими данными
==== 3.1.1 state ====
Состояние `DEVM`. Может принимать одно из двух значений: интерпретация или компиляция.
==== 3.1.2 S ====
Представляет из себя поток (последовательность данных), из которого происходит
чтение исходного кода.
==== 3.1.3 PC ====
`PC` — program counter, указатель на исполняемую инструкцию в шитом коде.
==== 3.1.4 W ====
Главный рабочий стек. Через него выполняются все основные 
операции (арифметические и с указателями). Вершина стека `WP` при помещении
в стек данных увеличивается в сторону увеличения адресов в памяти.
==== 3.1.5 R ====
Стек возвратов. В нём сохраняется состояние `PC` перед входом в команду, 
и восстанавливаются при выходе. Возможно хранение промежуточных данных,
если это не мешает использованию по назначению. 

Направление роста стека зависит от реализации.
==== 3.1.6 E ====
Шитый код. Представляет из себя несколько участков памяти. В шитый код 
происходит компиляция команд и сохранение данных. Указатель `PC` в каждый момент 
времени должен ссылаться внутрь какого-нибудь участка шитого кода, причём на 
начало опкода команды. 

Шитый код растёт в сторону увеличения адресов.

==== 3.1.7 L ====
Стек локальных переменных. Содержит два указателя ­ `LB` и `LP`. 
При входе в команду `LB` сохраняется в стеке `R` и приравнивается `LP`.
При выходе из команды `LP` приравнивается `LB`, а `LB` восстанавливается из стека.
Стандартное использование заключается в резервировании внутри команды 
смещением `LP` на нужное число байт, и адресация локальных переменных используя
в качестве базового укзателя `LB`. 

Направление роста стека зависит от реализации.

==== 3.1.8 Динамическая память (Куча) ====
Куча обеспечивает возможность динамически выделять области памяти в 
специально отведённом для этого месте оперативной памяти, и освобождение
выделенных ранее областей памяти для переиспользования.
==== 3.1.9 BW ====
Рабочий стек хранения блоков памяти. Блоком памяти считается указатель на
выделенную в куче область памяти, в первой ячейке которой хранится счётчик 
ссылок. Виртуальная машина следит за тем, чтобы при операциях со стеком `BW`
число ссылок на блок корректно изменялось и, в случае обнуления счётчика у
какого-то блока, освобождает этот блок из памяти.

Блоки памяти предназначены для хранения данных переменной длины, не содержащие
указателей (строки, длинные числа).
==== 3.1.10 BL ====
reserved
==== 3.1.11 V ====
Стеки словарей (`Target` и `Context`). Стек `Context` используется для поиска
слов в шаге обработки, стек `Target` для создания новых слов. Помимо этого,
у виртуальной машины есть предопределённые словари `GLOBAL`, `LOCAL`, `BUILTIN`.
`BUILTIN` используется для хранения слов, реализованных на ассемблере 
непосредственно в самой виртуальной машине. Содержимое этого словаря 
зависит от реализации виртуальной машины и стандартом не ограничивается.
`GLOBAL` предназначен для хранения глобальных определений.
`LOCAL` предназначен для хранения временных определений.
==== 3.1.12 F ====
Стек арифметики с плавающей точкой и статусные регистры. `DEVM` гарантирует стек
размером по крайней мере 8 элементов.
==== 3.1.13 Таблица команд (C) ====
Таблица, хранящая список словарных статей, или `XT`. 

Каждая словарная статья обязана хранить в себе следующие данные
 # Указатель на `asm`-код, выполняющий команду (`Code`)
 # Параметр команды (`Param`)
 # Имя команды (`Name`). Используется для поиска на шаге обработки.
 # `Immediate`-фалг команды. Используется на шаге обработке при выборе действия с командой.
 # `Built-in`-флаг команды. Выставлен у всех `DEBI`-команд.

В зависимости от реализации, DEVM может хранить в `XT` дополнительные нужные для
себя данные. 
=== 3.2 Поведение DEVM ===
==== 3.2.1 Шаг исполнения (run step) ====
 # Считывается ячейка памяти `C`, на которую указывает `PC`. В ней должен находиться идентификатор, по которому `DEVM` определит команду. Что именно там хранится — опкод, указатель на `XT` или что-то ещё — зависит от реализации. Если `C` является командой `exit`, то этот случай обрабатывается отдельно, см. 3.2.2.
 # `LB` кладётся в стек `R`
 # `LB := LP`
 # `PC` := `PC` + `CELL_SIZE`
 # `PC` кладётся в стек `R`
 # В стек `W` кладётся параметр прочитанной команды `С`
 # В `PC` кладётся указатель на первую инструкцию команды `C`
{{{
Изначально:
E: ...|xxxx|CCCC|xxxx|xxxx|xxxx|........|DDDD|
           ^
           PC

R: ...

L: ...|xxxx|yyyy|zzzz|...
      ^         ^
      LB        LP

После:
E: ...|xxxx|CCCC|xxxx|xxxx|xxxx|........|DDDD|
                ^                       ^
                PC+CELL_SIZE            PC

R: ... LB PC+CELL_SIZE

L: ...|xxxx|yyyy|zzzz|...
                ^
                LP
                New LB
}}}
==== 3.2.2 exit ====
Если `DEVM` выполняет команду `exit`, то действия в этом случае особые. Во-первых,
`DEVM` проверяет пуст ли стек `R`. Если пуст, то `DEVM` выполняет шаг обработки. 
Если же стек `R` не пуст, то
 # `PC` извлекается из стека `R`
 # `LP := LB`
 # `LB` извлекается из стека `R`
{{{
Изначально:
E: ...|xxxx|CCCC|xxxx|xxxx|xxxx|........|exit|
           ^                            ^
           X                            PC

R: ... Y X

L: ...|xxxx|yyyy|zzzz|...
      ^         ^    ^
      Y         LB   LP

После
E: ...|xxxx|CCCC|xxxx|xxxx|xxxx|........|exit|
           ^                            
           PC                           

R: ...

L: ...|xxxx|yyyy|zzzz|...
      ^         ^
      LB        LP
}}}
==== 3.2.2 Шаг обработки ====
 # `DEVM` пропускает все символы из `S`, которые являются пробелам (находятся в диапазоне `1..32`). 
 # Если `S` оказалось пусто, то либо `DEVM` выставляет флаг завершённости вычислений и завершает обработку, либо ожидает пока данные не появятся (в зависимости от настроек).
 # Из `S` извлекаются все символы, не принадлежащие диапазону `0..32`. Из них составляется слово `Q`.
 # Вызывается команда `_FIND_`, последовательно от самого верхнего `context`-словаря, до нижнего. Перед каждым вызовом слово `Q` кладётся в стек `BW`. После каждого вызова со стека `W` снимается значение. Это повторяется пока после снятое значение не окажется нулевым. (См. спецификацию слова `_FIND_`.)
 # Если после какого-то вызова со стека сняли 0, то снимается следующее значение, которое является идентификатором команды (опкодом или указателем). Если `DEVM` находится в режиме интерпретации (т.е. `state` выставлено в режим интерпретации), то этот идентификатор передаётся на шаг интерпретации, в противном случае — на шаг компиляции.
 # Если же после всех вызовов `_FIND_` команда так и не найдена, то вызывается команда `_NOTFOUND_`, последовательно от самого верхнего `context`-словаря до нижнего. Перед каждым вызовом в стек `BW` кладётся `Q`. После каждого вызова со стека снимается ячейка. Если она равна `true`, то шаг обработки завершён. Если ни один `_NOTFOUND_` так и не вернул `true`, то срабатывает ошибочная ситуация.
==== 3.2.3 Шаг интерпретации (interpret step) ====
Команда, полученная на шаге обработки, выполняется.
==== 3.2.4 Шаг компиляции (compile step) ====
У команды, полученной на шаге обработки, проверяется флаг `Immediate`. Если он 
равен `true`, то команда выполняется. Иначе команда компилируется в шитый код.
==== 3.2.5 Цикл вычислений (evaluate) ====
В цикле вычислений вызывается шаг исполнения до тех пор, пока флаг завершённости не будет выставлен в `true`.
==== 3.2.6 Добавление нового слова ====
==== 3.2.7 Поиск слова (`_FIND_`) ====
==== 3.2.8 Обработка не найденного слова (`_NOTFOUND_`) ====
=== 3.3 Начальное состояние DEVM ===

|| *Данные* || *Значение* ||
|| `state` || `interpret` ||
|| `S` || устанавливается извне ||
|| `PC` || указывает на `exit` ||
|| `W` || пуст ||
|| `R` || пуст ||
|| `E` || хранит код словаря `BUILTIN` ||
|| `L` || пуст ||
|| Куча || пуста ||
|| `BW` || пуст ||
|| `BL` || не определено ||
|| `V Context` || `GLOBAL LOCAL` ||
|| `V Target` || `GLOBAL` ||
|| Словарь `GLOBAL` || Содержит команды `exit`, `_FIND_`, `(`, `//`, `builtin`, `builtedin`  ||
|| Словарь `LOCAL` || пуст  ||
|| Словарь `BUILTIN` || зависит от реализации  ||
|| `F` || не определено (может быть проинициализировано командой `finit`) ||
|| `C` || хранит команды словаря `BUILTIN` ||

=== 3.4 Метаданные ===

==== 3.4.1 Метакод ====

Метакод — это надстройка над шитым кодом, необходимая для преобразования кода. В частности, для компиляции, оптимизации и сериализации.

{{{
metacode  ::= entry metacode  | h07

entry     ::= h00                       // call xt
            | h01 int                   // (raw) user defined data, int for length
            | h11                       // (raw) int
            | h21                       // (raw) uint
            | h31                       // (raw) ansistring
            | h41                       // (raw) unicode string
            | h51                       // (raw) widestring
            | h02                       // xt
            | h03                       // int
            | h04 metaptr               // pointer
            | h05 metaptr               // pointer
            | h06 ptr                   // block end, next entry at the ptr
            | h07                       // meta embro end (system entry)
            | h08                       // (system) end of metacode
            | h18 ptr                   // (system) end of block

metaptr   ::= page offset
page      ::= int
offset    ::= int
}}} 

== 4. DEmbro Built-in Commands (DEBI, встроенные команды DEmbro) ==
При запуске `DEmbro`-машины в `DEBI` режиме в словаре `GLOBAL` создаются слова,
список и поведение которых описаны ниже. Слова берутся либо из словаря `BUILTIN`,
либо реализуются на `DEmbro`. При этом все `DEBI` команды отмечены 
`builtin`-флагом.

См. [doc]
==== Правила именования слов ====
X ниже -- некоторое имя
{{{
Xed если команда X читает последующие слова входного потока, то Xed делает то же, что и X, но берёт слова как строки со стека блоков
[X] компилирует семантику слова X, сохраняя данные в шитый код
(X) выполняет семантику слова X, считывая данные из шитого кода
@ означает прочитать
! означает присвоить
*X глобальная переменная
X# размер X (X -- массив, строка и т.д.)
}}}
==== Список слов. ====
{{{
nop ничего не делает

Комментарии
// ( "...\n") пропускает во входящем потоке всё до конца строки
(  ( "...)" ) пропускает во входящем потоке всё до закрывающей круглой скобки

Стек W
%-drop       ( %   --     )
%-nip        ( ab  -- b   )
%-dup        ( %   -- %%  )
%-over       ( ab  -- aba )
%-tuck       ( ab  -- bab )
%-swap       ( ab  -- ba  )
%-rot        ( abc -- bca )
%-lrot       ( abc -- bca )
%-rrot       ( abc -- cab )
%-lrotn      ( a1 a2 ... an n -- a2 a3 ... an a1 )
%-rrotn      ( a1 a2 ... an n -- a2 a3 ... an a1 )
%-pick       ( a1 a2 ... an n -- a1 a2 ... an a1 )

Стек BW
`+x` означает, что команда число ссылок на `x` увеличивает на 1
`-x` означает, что команда число ссылок на `x` уменьшает на 1 и удаляет из
блок памяти, если нужно
`^x` означает, что x создастся после выполнения команды
w>b         ( W: a -- ) ( B: -- x) переносит значение с W в BW
b>w         ( W: -- a ) ( B: x --) переносит значение с BW в W
b@w         ( W: -- x ) ( B: x -- B: x) читает значение на вершине BW
w@b         ( W: a -- a ) ( -- B: a) читает значение с W на BW
binc        ( W: x   --     ) ( +x) увеличивает число ссылок на блок x 
bdec        ( W: x   --     ) ( -x) уменьшает число ссылок на x, освобождает если нужно
b@          ( p      -- B: x) ( +x) читает x из p
b!          ( p B: x --     ) ( -[p]) записывает x в p
bdrop       ( B: x   --     ) ( -x) удаляет с вершины стека переменную
bnip        ( B: xy  -- B: y   ) ( -x) удаляет второй по счёту элемент стека
bdup        ( B: x   -- B: xx  ) ( +x) дублирует верхнюю переменную на стеке
bover       ( B: xy  -- B: xyx ) ( +x) копирует предпоследний элемент стека на вершину
btuck       ( B: xy  -- B: yxy ) ( +y) копирует верхний элемент стека ниже второго элемента стека
bswap       ( B: xy  -- B: yx  ) меняет два верхних значения местами
blrot       ( B: xyz -- B: yzx ) меняет три верхних элемента местами
brrot       ( B: zxy -- B: zxy ) меняет три верхних элемента местами

Арифметические операции
%+       ( ab    -- a+b    )
%-       ( ab    -- a-b    )
%*       ( ab    -- a*b    )
%=       ( ab    -- a=b    ) проверяет два значения на равенство, кладёт на стек bool
%<>      ( ab    -- a<>b   ) ... на неравенство ...
%<       ( ab    -- a<b    ) ... на меньше ...
%>       ( ab    -- a>b    ) ... на больше ...
%<=      ( ab    -- a<=b   ) ... на меньше или равно ...
%>=      ( ab    -- a>=b   ) ... на больше или равно ...
%0=      ( a     -- a=0    ) проверяет a на равенство нулю
%0<>     ( a     -- a<>0   ) ... на неравенство ...
%0<      ( a     -- a<0    ) ... на меньше ...
%0>      ( a     -- a>0    ) ... на больше ...
%0<=     ( a     -- a<=0   ) ... на меньше или равно ...
%0>=     ( a     -- a>=0   ) ... на больше или равно ...
%-?dup   ( a     -- 0 | a a) дублирует a, если оно ненулевое
%0;      ( a     -- a |    ) Если a не равно нулю, то ничего не делает. Иначе снимает
                             a со стека и выходит из функции.
%-within ( x a b -- bool   ) проверяет лежит ли x в полуинтервале [a b) (в разработке)
%-max    ( ab    -- a | b  ) из двух верхних элементов на стеке оставляет максимальный
%-min    ( ab    -- a | b  ) из двух верхних элементов на стеке оставляет минимальный
%-minmax ( ab    -- ab | ba) сортирует два элемента — на вершине стека оказывается максимум, а вторым по счёту минимум

Целочисленные операции [u]int*
%-div    ( ab -- a div b          ) вычисляет целую чаcть при делении a на b
%-mod    ( ab -- a mod b          ) вычисляет остаток при делении a на b
%-divmod ( ab -- a div b, a mod b )
%-inc    ( a  -- a+1              ) быстрое увеличение на единицу
%-dec    ( a  -- a-1              ) быстрое уменьшение на единицу
1+       ( a  -- a+1              ) эквивалентно int-inc
1-       ( a  -- a-1              ) эквивалентно int-dec

Знаковые арифметические операции
%-abs    ( % -- |%| ) вычисляет модуль числа
%-neg    ( % -- -%  ) обращает знак числа

Операции для чисел с плавающей точкой
%/      ( ab -- a/b         ) делит одно число на другое
%-cos   ( a  -- cos(a)      )
%-sin   ( a  -- sin(a)      )
%-tan   ( a  -- tan(a)      ) 
%-atan  ( a  -- atan(a)     )
%-atan2 ( yx -- atan2(y, x) )

Преобразования из одних типов в другие
int8->int 
int16->int 
int32->int
int->int8 
int->int16 
int->int32
uint8->uint 
uint16->uint 
uint32->uint
uint->uint8 
uint->uint16 
uint->uint32
single->double 
single->extended
double->single 
souble->extended
extended->single 
extended->double

Побитовые операции
false (     -- false   ) кладёт на стек ложь
true  (     -- true    ) кладёт на стек истину
not   ( a   -- c       ) c = not a
or    ( ab  -- c       ) c = a or b
and   ( ab  -- c       ) c = a and b
xor   ( ab  -- c       ) c = a xor b

Указатели
%!     ( % ptr --      ) записать % по заданному адресу
%@     ( ptr   -- %    ) кладёт в стек значение по адресу ptr (команда разыменовывания)
malloc ( i     -- ptr  ) Выделяет i байтов в куче, возвращает указатель на область
free   ( ptr   --      ) Освобождает выделенную ранее область
cell+  ( ptr1   -- ptr2) увеличивает указатель на размер ячейки
cells  ( int   -- int  ) умножает число на размер ячейки в байтах
ptr+%  ( ptr1  -- ptr2 ) снимает со стека ptr, прибавляет к нему размер типа % и кладёт результат на стек
%+!    ( n ptr --      ) прибавляет к типу % по адресу ptr число n типа %. Только для арифметических типов
%-inc! ( ptr   --      ) увеличивает число типа % по адресу ptr на 1
%-dec! ( ptr   --      ) уменьшает число типа % по адресу ptr на 1
1+!    ( ptr   --      ) увеличивает число типа int по адресу ptr на 1
1-!    ( ptr   --      ) уменьшает число типа int по адресу ptr на 1

Строки
*poststr* ( -- p) переменная, хранящая xt команды с рисунком ( B: x -- B: y), которая вызывается для обработки прочитанных строк
*postname*    ( -- p) то же, для обработки прочитанных имён 
str0       (          --   B: s ) ( ^s) кладёт нулевую строку в стек блоков
str#       (    B: s  -- i B: s ) кладёт в стек W длину строки s на вершине B
str-width  ( B: s     -- i B: s ) кладёт число байт, занимаемое одним символом в строке
str+       (    B: xy --   B: s ) ( -x -y ^s) конкатенация двух строк: s = xy
str@       ( p        --   B: s ) ( +s) то же, что и b@
str!       ( p  B: s  --        ) ( +s -[p]) то же, что и b!
str=       (    B: xy -- i B: xy) проверяет на равенство строки, x=y: i=0, x<y: i=-1; x>y: y=1 
str^       (    B: xs -- i B: xs) выдаёт номер символа, в котором наблюдается первое вхождение s в x, либо -1, если такого нет
str^?      (   B: xs -- if B: xs) то же, что и предыдущее, но ещё выдаёт флаг успеха
str-       (   B: xs --    B: y ) ( -xs^y) удалить все вхождения s в строке x
str\       (   B: xsn--    B: y ) ( -xsn^y) заменить все вхождения s в строке x на n
                                            кодировка полученной строки будет совпадать
                                            с кодировкой x
str-ins    ( p B: xs --    B: y ) ( -x -s ^y) вставляет строку s в x перед символом с номером p
str-del    ( ps B: x  --   B: y ) ( -x ^y) из строки x удаляет фрагмент [p..p+s-1]
str-cut    ( ps B: x  --   B: y ) ( -x ^y) от строки x оставляет фрагмент [p..p+s-1]
str-split  ( p  B: s  --   B: xy) ( -s ^x ^y) разрезает строку s на две части: x=s[0..p-1]; y=s[p..s#-1]
str-sub    ( B: xyz   --   B: s ) ( -xyz ^s) все вхождения z в x слева направо заменяются на y
str"       (      .." --   B: s ) ( ^s) читает всё до двойной кавычки, создаёт строку. Только в режиме интерпретации
[str]"     ( C:   .." --        ) ( R: -- B: s) ( ^s) в режиме компиляции читает строку, в режиме выполнения создаёт строку.
(str)"     (          -- B: s   ) ( +s) читает из шитого кода строку, кладёт на стек. "
str.       ( B: s     --        ) ( -s) вывести строку на консоль
str$       (          -- B: s   ) ( ^s) прочесть строку с консоли
str-new    ( icb      --   B: s ) ( ^s) создаёт строку s длиной i с b байтами на символ, каждый символ имеет значение c
str[]@     (  i B: x  -- c B: x ) читает i-ый символ строки
str[]!     ( ci B: x  --   B: y ) ( -x^y) устанавливает i-ый символ строки в c. Если на x есть единственная ссылка, то y=x 
str->pchar ( B: s     -- p B: s ) создаёт pchar со строкой str (в которой все не 8bit символы заменяются на ?)
pchar->str ( p        -- p B: s ) ( ^s) создаёт 8bit-строку, копию pchar строки p

Поток управления
branch   (   -- ) совершает скачек на определённый адрес в коде. При этом адрес берётся из последующего после команды числа в шитом коде.
?branch  ( f -- ) если f ложно, то действует как branch, в противном случае переходит к следующей команде
>mark    (   -- ) ( -- embroptr ) при исполнении ничего не делает, при компиляции кладёт текущий адрес на стек и выделяет в шитом коде место под запись адреса
>resolve (   -- ) ( embroptr -- ) при исполнении ничего не делает, при компиляции извлекает со стека адрес в шитом коде и записывает по нему адрес текущего положения в шитом коде
<mark    (   -- ) ( L: -- embroptr ) при исполнении ничего не делает, при компиляции кладёт текущий адрес на стек
<resolve (   -- ) ( L: embroptr -- ) при исполнении ничего не делает, при компиляции извлекает со стека адрес в шитом коде и записывает его в шитый код
exit     (   -- ) выйти из текущей функции, работает только внутри определения функции

Режим компиляции
state         (        -- ptr) кладёт на стек указатель на значение переменной state
                            0 — DEmbro-машина находится в режиме интерпретации
                            1 — DEmbro-машина находится в режиме компиляции
[             (        --    ) I+ Переводит DEmbro-машину в режим интерпретации
]             (        --    ) переводит DEmbro-машину в режим компиляции
compile       ( "name" --    ) I+ компилирует команду name в шитый код, вне зависимости от её флага immediate
%-literal     ( C: % -- ) ( E: -- % ) I+ в режиме компиляции считывает 
                                      число со стека и компилирует код, который
                                      кладёт это число на стек

Объявление новых команд, шитый код
:          ( "name" --      ) создаёт новое определение с именем name, переводит машину в режим компиляции
;          (                ) I+ завершает описание определения, переводит машину в режим интерпретации
immediate  (                ) делает последнюю определённую команду командой немедленного исполнения
recurse    (                ) I+ рекурсивно вызвать текущую функцию, работает только внутри определения функции
last       (          --  xt) кладёт на стек последнюю созданную команду
create     (          --    ) создаёт новую команду с именем name. При выполнении name на стек будет класться указатель на её область в шитом коде
allot      ( i        --    ) выделяет i байт в шитом коде последней определённой команды
here       (          -- ptr) кладёт на стек текущий указатель вершины шитого кода
%,         ( %        --    ) выделяет нужный размер под % и записывает в область данных значение со стека
%-to       ( % "name" --    ) I+ перенести значение со стека в область данных команды name
%-variable ( "name"   --    ) аналогично create, но сразу выделяет память под x и инициализирует значением со стека 
%-value    ( % "name" --    ) аналогично create, но при выполнении name на стек будет класться не указатель на область данных, а значение типа % в области данных
%-constant ( % "name" --    ) в настоящий момент аналогично value
does>      (          --    ) I+ устанавливает код, который должен выполняться
                           для последнего слова, созданного командой `create`.
                           При вызове слова на стек будет положен указатель
                           на область данных слова и вызван код, указанный после
                           `does>` вплоть до конца определения.    

Работа с типами
typeof     ( "name"   -- type ) кладёт на стек тип, указанный в слове name
type-size  ( type -- i        ) кладёт на стек размер типа
type-name  ( type -- B: name  ) кладёт на стек строку с именем типа
t_%        (      -- %        ) то же, что и typeof %

Динамические библиотеки и взаимодействие с внешним кодом
lib-load   ( str       -- lib bool ) загружает библиотеку, путь до которой прописан в pchar. 
lib-fun    ( lib str   -- lib ptr  ) возвращает адрес функции в библиотеке с именем lib. Если такой нет, вернёт nil. 
lib-unload ( lib       --          ) выгружает библиотеку из памяти, функции перестают быть доступными
:a         ( "name"    --          ) начать объявление прототипа внешней функции
a;         ( ...       --          ) завершиь объявление прототипа внешней функции
:c         ( xt "name" --          ) начать объявление прототипа коллбэка, вызов которого будет перенаправляться в xt
c;         ( ...       --          ) завершить объявление прототипа коллбэка
stdcall    (           -- stdcall  ) поместить на стек идентификатор вызова stdcall 
cdecl      (           -- cdecl    ) поместить на стек идентификатор вызова cdecl

Консоль
%.     ( %  --   ) выводит на консоль значение на вершине определённого типа и пробел после этого типа
%$     (    -- % ) ожидает пока пользователь введёт в консоли значение нужного типа, кладёт его на стек (пока что работает только для арифметических типов)
emit   ( i  --   ) берёт со стека целое число и выводит символ с кодом этого числа
space  (    --   ) печатает на консоль пробел
spaces ( n  --   ) печатает n пробелов
cr     (    --   ) переводит вывод на новую строку

Дембро-машина
dembro-self        (           -- D   ) кладёт текущую дембро-машину на стек
dembro-create      (           -- D   ) создаёт новую дембро-машину
dembro-free        ( D         --     ) освобождает созданную ранее дембро-машину
dembro-save        ( D B: s    --     ) сохраняет дембро-машину в файл
dembro-load        ( D B: s    --     ) загружает дембро-машину из файла
dembro-load-system ( D         --     ) подключает базовый rtl, путь до которого берёт со своего стека блоков
dembro-evaluate    ( W: D B: s --     ) выполняет код в строке на заданной дембро-машине
dembro-push        ( iD        --     ) переносит число со стека на стек заданной дембро-машины
dembro-pop         ( D         -- i   ) переносит число со стека заданной дембро-машины на текущий стек
dembro-bpush       ( W: D B: x --     ) ( -x) переносит элемент со стека блоков на стек блоков дембро-машины
                                        Отмечу, что память под блок будет перевыделена в новой дембро-машине.
dembro-bpop        ( W: D      -- B: x) ( ^x) извлекает блок из заданно дембро-машины
dembro-embro       ( D         -- p   ) кладёт указатель на структуру, описывающую шитый код
dembro-table       ( D         -- p   ) кладёт указатель на структуру, описывающую таблицу команд

Прочие команды
evaluate      ( str --    ) интерпретирует код, находящийся в строке на стеке
evaluate-file ( str --    ) интерпретирует код, находящийся в файле, путь до которого указан в строке. Может использоваться для подключения библиотек
sys-version   (     -- i  ) кладёт число-номер версии форт-машины

Работа с плавающей точкой на сопроцессоре
fdrop   ( F: f   --     ) 
fnip    ( F: fg  -- g   )
fdup    ( F: f   -- ff  )
fover   ( F: fg  -- fgf )
ftuck   ( F: fg  -- gfg )
fswap   ( F: fg  -- gf  )
frot    ( F: fgh -- ghf )
flrot   ( F: fgh -- ghf )
frrot   ( F: fgh -- hfg )

f0      ( F:     -- F: 0)
f1      ( F:     -- F: 1)
fpi     ( F:     -- F: f) кладёт число пи на стек
flog10  (        -- F: f) кладёт log_2(10)
floge   (        -- F: f) кладёт log_2(e)
f10log2 (        -- F: f) кладёт log_10(2)
fln2    (        -- F: f) кладёт ln(2)

вместо % можно подставить float, double, extended, [u]int[/8/16/32]
%-f!    ( p F: f --     )
%-f@    ( p      -- F: f)
%-fdup! ( p F: f -- F: f)
%-w>f   ( %      -- F: %)
%-f>w   ( F: %   -- %   )
w>f     ( i      -- F: i) int-w>f
f>w     ( F: %   -- i   ) int-f>w 

f+      ( F: fg  -- F: h) h = f + g
f-      ( F: fg  -- F: h) h = f - g
fswap-  ( F: fg  -- F: h) h = g - f
f*      ( F: fg  -- F: h) h = f * g
f/      ( F: fg  -- F: h) h = f / g
fswap/  ( F: fg  -- F: h) h = g / f
...

fsqrt   ( F: f   -- F: g) g = sqrt(f)
fscale  ( F: xy  -- F: xh) h = 2^x * y
fabs    ( F: x   -- F: f) f = |x|
fneg    ( F: x   -- F: f) f = -x
fround  ( F: x   -- F: y) y = round(x)

f0=         ( F: f   -- b F: f )
f0>         ( F: f   -- b F: f )
f0<         ( F: f   -- b F: f )
f0>=        ( F: f   -- b F: f )
f0<=        ( F: f   -- b F: f )

f=          ( F: xy  -- b F: xy)
f<>         ( F: xy  -- b F: xy)
f<          ( F: xy  -- b F: xy)
f>          ( F: xy  -- b F: xy)
f<=         ( F: xy  -- b F: xy)
f>=         ( F: xy  -- b F: xy)
fi=         ( F: xy  -- b F: xy)
fi<>        ( F: xy  -- b F: xy)
fi<         ( F: xy  -- b F: xy)
fi>         ( F: xy  -- b F: xy)
fi<=        ( F: xy  -- b F: xy)
fi>=        ( F: xy  -- b F: xy)

f=drop      ( F: xy  -- b F: x )
f<>drop     ( F: xy  -- b F: x )
f<drop      ( F: xy  -- b F: x )
f>drop      ( F: xy  -- b F: x )
f<=drop     ( F: xy  -- b F: x )
f>=drop     ( F: xy  -- b F: x )
fi=drop     ( F: xy  -- b F: x )
fi<>drop    ( F: xy  -- b F: x )
fi<drop     ( F: xy  -- b F: x )
fi>drop     ( F: xy  -- b F: x )
fi<=drop    ( F: xy  -- b F: x )
fi>=drop    ( F: xy  -- b F: x )

f=dropdrop   ( F: xy  -- b      )
f<>dropdrop  ( F: xy  -- b      )
f<dropdrop   ( F: xy  -- b      )
f>dropdrop   ( F: xy  -- b      )
f<=dropdrop  ( F: xy  -- b      )
f>=dropdrop  ( F: xy  -- b      )
fi=dropdrop  ( F: xy  -- b      )
fi<>dropdrop ( F: xy  -- b      )
fi<dropdrop  ( F: xy  -- b      )
fi>dropdrop  ( F: xy  -- b      )
fi<=dropdrop ( F: xy  -- b      )
fi>=dropdrop ( F: xy  -- b      )

fptan     ( F: f   -- F: yx) y/x = tg(f), 0 <= f <= pi/4
fpatan    ( F: xy  -- F: f ) f = arctg(x/y), 0 < y < x
flog*     ( F: xy  -- F: f ) f = x*log_2(y)
fln       ( F: x   -- F: f ) f = ln(x)
flog1+mul ( F: xy  -- F: f ) f = y*log_2(1+x), 0 < x < 1 - 1/sqrt(2)
f2pwr1-   ( F: x   -- F: f ) f = 2^x - 1, 0 <= x <= 0.5
fcos      ( F: x   -- F: f ) f = cos(x)
fsin      ( F: x   -- F: f ) f = sin(x)
fsincos   ( F: x   -- F: fg) f = sin(x), g = cos(x)

float-fliteral    ( C: F: f --) ( R: -- F: f)
double-fliteral   ( C: F: f --) ( R: -- F: f)
extended-fliteral ( C: F: f --) ( R: -- F: f)
float->str        ( F: f -- B: s)
double->str       ( F: f -- B: s)
extended->str     ( F: f -- B: s)
str->float?       ( B: s -- T F: f | F)
str->double?      ( B: s -- T F: f | F)
str->extended?    ( B: s -- T F: f | F)
str->float!?      ( p B: s -- T | F) записывает результат по адресу p
str->double!?     ( p B: s -- T | F)
str->extended!?   ( p B: s -- T | F)

Команды для assembler
xt.asm! ( px-) установить asm подпрограмму p для команды x
xt.asm@ ( x-p)
asm-invoke ( pxm) вызвать ассемблерный код по адресу p, передав в качестве машины m, а в качестве команды x
asm-declare ( icp "name") создать команду, которая будет выполнять ассемблерный код p, param команды будет i, а code команды -- c
:asm    ( "name")
asm;    ( )
}}}
== Строки, кодировки ==
Строка хранит в себе, помимо символов: 
 # число байт, занимаемое символом,
 # число символов в строке, 
 # максимально число символов, которое может быть в строке.

Изначально, dembro машина читает строку исходника, предполагая, что она в 
кодировке ansi — по одному байту на символ. Можно назначить преобразователь
кодировки при преобразовании исходника, тогда команды `str"`, `[str]"` и 
обработчик имён будет применять этот преобразователь. Стандартные следующие:
{{{
nop           ( B: x -- B: x) Никаких преобразований не производит
raw->unicode  ( B: x -- B: y) ( -x ^y) 1-байтная строка расширяется до стандартной
                                       (в размер ячейки)
                                       с добиванием нулями старших байт
utf8->unicode ( B: x -- B: y) ( -x ^y) 1-байтная строка обрабатывается как utf8
                                       и преобразуется в юникод, при этом
                                       число символов может уменьшиться
                                       (т.к. в utf8 символы имеют разную длину)
utf8->raw     ( B: x -- B: y) ( -x ^y) Обрубает символы до одного байта,
                                       крупные символы заменяются знаками вопроса
}}}
Два первых берут однобайтные строки, и преобразуют в юникод, в котором
один символ занимает одну ячейку. 
{{{
unicode->utf8 ( B: x -- B: y) ( -x ^y)
unicode->raw  ( B: x -- B: y) ( -x ^y)
}}}
Как только требуется работать с символами с большим числом байт как будто 
байт в них мало, все символы сверх 255 превращаются в знак вопроса.

Можно использовать собственные преобразователи, а так же есть в стандартной 
поставке есть модули для
{{{
cp1251->unicode
cp866->unicode
unicode->cp1251
unicode->cp866
}}}

Для спецсимволов имеется отдельное слово:
{{{
str\ ( B: x -- B: y) ( -x ^y) заменяет 
                              '\n' на перенос строки
                              '\t' на табуляцию
                              '\\' на символ '\'
}}}
При расширении этого слова его нужно вызвать в конце, чтобы преобразованное '\\' 
не сбило с толку
{{{
: str\ " \a" " Doj" str-sub str\ ;
}}}

Можно конструировать вычисление обработчика по цепочке
{{{
:noname str\ raw->unicode ;
}}}

== 5. DEmbro Standart Libraries (DESL, стандартные библиотеки DEmbro) ==

== 6. DEmbro Compiler and Optimizer (DECO, компилятор и оптимизатор) ==

== 7. DEmbro Code Style (DECS, стиль оформления исходных кодов на DEmbro) ==

=== 7.1 Отступы и переносы строк ===

Длина максимальной строки не фиксируется стандартом.

==== 7.1.1 Оформление фнукций (colon) ====

Если команда умещается на одной строке, то её можно расположить в одну строку.
В противном случае, нужно разбивать по правилам ниже.

Тело больших команд описывается с новой строки с отступом в четыре символа относительно строки объявления команды:
{{{
: init-struct ( csd)
    dup .count off
    tuck .size !
    tuck .capacity !
    get-mem ;
}}}

Точка с запятой должна находится в конце последней строчки тела, либо в новой строчке, но с отступом в четыре символа, как и тело.

Слово does> размещается в новой строке с отступом в два символа относительно
строки объявления:
{{{
: local-generated+ ( s-)
    " +" local-created 
  does>
    put-local-offset 
    compile l@ 
    compile + ;
}}}

== 8. DEmbro Script Engine (DESE, интерфейс скриптового движка) ==
