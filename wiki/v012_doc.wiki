=== misc ===

=== fpu ===
*`finit`* `Устанавливает сопроцессор в стандартное состояние`
<br>*`fdrop`* `( F: f --) удаляет с вершины стека сопроцессора элемент`
<br>*`fnip`* `( F: fg -- F: g) удаляет с второй вершины стека сопроцессора элемент`
<br>*`fdup`* `( F: f -- F: ff) дублирует верхний элемент стека сопроцессора`
<br>*`fover`* `( F: fg -- F: fgf) дублирует второй элемент стека сопроцессора`
<br>*`ftuck`* `( F: fg -- F: gfg) дублирует вершину стека сопроцессора под второй элемент`
<br>*`fswap`* `( F: fg -- F: gf) меняет два верхних элемента стека сопроцессора местами`
<br>*`flrot`* `( F: fgh -- F: ghf) сдвигает влево три верхних элемента сопроцессора`
<br>*`frrot`* `( F: fgh -- F: hfg) сдвигает вправо три верхних элемента сопроцессора`
<br>*`f0`* `( -- F: f) кладёт на стек F число 0.0`
<br>*`f1`* `( -- F: f) кладёт на стек F число 1.0`
<br>*`fpi`* `( -- F: f) кладёт на стек F число pi`
<br>*`flog10`* `( -- F: f) кладёт на стек F двоичный логарифм десяти`
<br>*`floge`* `( -- F: f) кладёт на стек F двоичный логарифм числа e`
<br>*`f10log2`* `( -- F: f) кладёт на стек F десятичный логарифм двойки`
<br>*`fln2`* `( -- F: f) кладёт на стек F натуральный логарифм двойки`
<br>*`frandom`* `( -- F: f) кладёт на стек F случайное число из полуинтервала [0..1)`
<br>*`fsqrt`* `( F: f -- F: g) извлекает квадратный корень из f`
<br>*`fabs`* `( F: f -- F: g) находит модуль числа f`
<br>*`fneg`* `( F: f -- F: g) обращает знак числа f`
<br>*`flog1+*`* ( F: x y -- F: f)  Вычисляет выражение y*log_2(1+x), при этом число x должно быть в диапазоне    0 < x < 1 - 1/sqrt(2)
<br>*`f2**1-`* ( F: x -- F: f) f = 2^x - 1  При достаточно малых значениях x возводит 2 в степень x и вычитает единицу.  x должно быть в диапазоне    0 <= x <= 0.5
<br>*`fcos`* `( F: x -- F: f) f = cos(x), x должно быть в радианах`
<br>*`fsin`* `( F: x -- F: f) f = sin(x), x должно быть в радианах`
<br>*`fsincos`* `( F: x -- F: fg) f = sin(x), g = cos(x), x должно быть в радианах`
<br>*`float->str`* `( W: f -- B: s) конвертирует float в строку`
<br>*`double->str`* `( W: d -- B: s) конвертирует double в строку`
<br>*`extended->str`* `( W: e -- B: s) конвертирует extended в строку`
<br>*`extended-fliteral`* ( C: f -- ) ( R: -- F: f)  В режиме компиляции: снимает число с плавающей точкой со стека, компилирует    в шитый код команду extended-(fliteral) и это число.  В режиме исполнения: кладёт число f на стек, пропускает его в шитом коде.
<br>*`ftan`* ( F: f -- F: h)   Вычисляет тангенс угла: h = tg(f).  Угол f должен быть в радианах.
<br>*`fctan`* ( F: f -- F: h)   Вычисляет котангенс угла: h = ctg(f).  Угол f должен быть в радианах.
<br>*`fsec`* `( F: f -- F: h) вычисляет h = sec(f)`
<br>*`fcosec`* `( F: f -- F: h) вычисляет h = cosec(f)`
<br>*`fatan`* `( F: f -- F: h) вычисляет h = atan(f)`
<br>*`flog`* `( F: f -- F: h) вычисляет логарифм по основанию 2`
<br>*`fln`* `( F: f -- F: h) вычисляет натуральный логарифм (по основанию e)`
<br>*`f10log`* `( F: f -- F: h) вычисляет логарифм по основанию 10`
<br>*`f2**`* `( F: f -- F: h) вычислает степень двойки: h = 2^f`
<br>*`f**`* `( F: fg -- F: h) возводит в степень: h = f^g`
<br>*`fexp`* `( F: f -- F: h) вычислает экспоненту: h = e^f`
<br>*`f10**`* `( F: f -- F: h) вычислает степень десяти: h = 10^f`
<br>*`fstr->f?`*   Пытается сконвертировать строку в число с плавающей точкой. Если это удаётся,  полученное число кладётся на стек сопроцессора, а на обычный стек true.  В случае, если сконвертировать не удалось, на стек кладётся false, а стек  сопроцессора остаётся неизменным.
<br>*`fstr->float?`*   Пытается сконвертировать строку в число с плавающей точкой точностью float.   Если это удаётся, полученное число кладётся на стек сопроцессора, а   на обычный стек true. В случае, если сконвертировать не удалось, на стек   кладётся false, а стек сопроцессора остаётся неизменным.
<br>*`fstr->double?`*   Пытается сконвертировать строку в число с плавающей точкой точностью double.   Если это удаётся, полученное число кладётся на стек сопроцессора, а   на обычный стек true. В случае, если сконвертировать не удалось, на стек   кладётся false, а стек сопроцессора остаётся неизменным.
<br>*`fstr->extended?`*   Пытается сконвертировать строку в число с плавающей точкой точностью extended.   Если это удаётся, полученное число кладётся на стек сопроцессора, а   на обычный стек true. В случае, если сконвертировать не удалось, на стек   кладётся false, а стек сопроцессора остаётся неизменным.
<br>*`def-str->f`* (F: f B: s -- F: g)  Снимает строку со стека B. Пытается её сконвертировать в число с плавающей  точкой. Если это удаётся, то снимает f со стека, и кладёт полученное число.  В противном случае ничего не делает, т.е. на стеке сопроцессора останется  число f. Таким образом можно реализовывать преобразование с дефолтным   значением.  Примеры:  {{{     " 3.0" f1 def-str->f // положит на стек 3.0    " @@@" f1 def-str->f // положит на стек 1.0  }}}
<br>*`def-str->float`* (F: f B: s -- F: g)  Снимает строку со стека B. Пытается её сконвертировать в число с плавающей  точкой с точностью float. Если это удаётся, то снимает f со стека, и кладёт   полученное число. В противном случае ничего не делает, т.е. на стеке   сопроцессора останется число f. Таким образом можно реализовывать   преобразование с дефолтным значением.  Примеры:   {{{     " 3.0" f1 def-str->float // положит на стек 3.0    " @@@" f1 def-str->float // положит на стек 1.0  }}} 
<br>*`def-str->double`* (F: f B: s -- F: g)  Снимает строку со стека B. Пытается её сконвертировать в число с плавающей  точкой с точностью double. Если это удаётся, то снимает f со стека, и кладёт   полученное число. В противном случае ничего не делает, т.е. на стеке   сопроцессора останется число f. Таким образом можно реализовывать   преобразование с дефолтным значением.  Примеры:   {{{     " 3.0" f1 def-str->double // положит на стек 3.0    " @@@" f1 def-str->double // положит на стек 1.0  }}} 
<br>*`def-str->extended`* (F: f B: s -- F: g)  Снимает строку со стека B. Пытается её сконвертировать в число с плавающей  точкой с точностью extended. Если это удаётся, то снимает f со стека, и кладёт   полученное число. В противном случае ничего не делает, т.е. на стеке   сопроцессора останется число f. Таким образом можно реализовывать   преобразование с дефолтным значением.  Примеры:   {{{     " 3.0" f1 def-str->extended // положит на стек 3.0    " @@@" f1 def-str->extended // положит на стек 1.0  }}} 
<br>*`fe`* `( -- F: e) кладёт константу - математическое число e`
<br>*`ff->str`* ( F: f -- B: s)  Снимает со стека сопроцессора значение, и преобразует его в строку.
<br>*`ffloat->str`* ( F: f -- B: s)  Снимает со стека сопроцессора значение, и преобразует его в строку с точностью  числа float.
<br>*`fdouble->str`* ( F: f -- B: s)  Снимает со стека сопроцессора значение, и преобразует его в строку с точностью  числа double.
<br>*`fextended->str`* ( F: f -- B: s)  Снимает со стека сопроцессора значение, и преобразует его в строку с точностью  числа extended.
<br>*`str->f`* `( B: s -- F: f) эквивалентно коду f0 def-str->f`
<br>*`str->float`* `( B: s -- F: f) эквивалентно коду f0 def-str->float`
<br>*`str->double`* `( B: s -- F: f) эквивалентно коду f0 def-str->double`
<br>*`str->extended`* `( B: s -- F: f) эквивалентно коду f0 def-str->extended`
<br>*`f.`* `( F: f -- ) снимает с вершины стека F значение и печатает на консоль`
<br>*`float.`* `( F: f -- ) то же, что "f.", но с точностью float `
<br>*`double.`* `( F: f -- ) то же, что "f.", но с точностью double`
<br>*`extended.`* `( F: f -- ) то же, что "f.", но с точностью extended`
<br>
=== W ===
*`drop`* `( a-)` удаляет с вершины стека значение
<br>*`nip`* `( ab-b)` удаляет второй по счёту элемент стека
<br>*`dup`* `( a-aa)` дублирует верхний элемент стека
<br>*`over`* `( ab-aba)` заталкивает второй элемент стека на вершину
<br>*`tuck`* `( ab-bab)` заталкивает верхний элемент под второй
<br>*`swap`* `( ab-ba)` меняет два верхних элемента местами
<br>*`lrot`* `( abc-bca)` вращает три верхних элемента стека циклически влево
<br>*`rrot`* `( abc-cab)` вращает три верхних элемента стека циклически вправо
<br>*`pick`* `( a1 a2 .. an n -- a1 a2 .. an a1)` копирует n-ный по счёту элемент стека на вершину
<br>
=== arithmetic ===
*`+`* `( a b -- a+b)` складывает два верхних элемента стека
<br>*`-`* `( a b -- a-b)` вычитает из второго элемента первый
<br>*`*`* `( a b -- a*b)` перемножает два верхних элемента стека
<br>*`=`* `( a b -- a=b)` если два верхних элемента равны, заталкивает true, иначе false
<br>*`<>`* `( a b -- a<>b)` если два верхних элемента не равны, заталкивает true, иначе false
<br>*`<`* `( a b -- a<b)` если второй элемент меньше первого, заталкивает true, иначе false
<br>*`>`* `( a b -- a>b)` если второй элемент больше первого, заталкивает true, иначе false
<br>*`<=`* `( a b -- a<=b)` если второй элемент меньше, либо равен первому, заталкивает true, иначе false
<br>*`>=`* `( a b -- a<=b)` если второй элемент больше, либо равен первому, заталкивает true, иначе false
<br>*`0=`* `( a -- a=0)` если верхний элемент равен 0, заталкивает true, иначе false
<br>*`0<>`* `( a -- a<>0)` если верхний элемент не равен 0, заталкивает true, иначе false
<br>*`0<`* `( a -- a<0)` если верхний элемент меньше 0, заталкивает true, иначе false
<br>*`0>`* `( a -- a>0)` если верхний элемент больше 0, заталкивает true, иначе false
<br>*`0<=`* `( a -- a<=0)` если верхний элемент меньше, либо равен 0, заталкивает true, иначе false
<br>*`0>=`* `( a -- a>=0)` если верхний элемент больше, либо равен 0, заталкивает true, иначе false
<br>*`?dup`* `( a-0|aa)` если верхний элемент больше, либо равен 0, заталкивает true, иначе false
<br>*`0;`* `( a-a|)` если верхний элемент равен нулю, снимает его и выходит из функции, иначе ничего не делает
<br>*`max`* `( ab-a|b)` из двух верхних элементов стека оставляет максимальный
<br>*`min`* `( ab-a|b)` из двух верхних элементов стека оставляет минимальный
<br>*`minmax`* `( ab-ab|ba)` переставляет два верхних элемента так, чтобы на вершине оказался наибольший
<br>*`div`* `( a b -- a div b)` целая часть от деления двух целых чисел
<br>*`mod`* `( a b -- a mod b)` остаток от деления двух целых чисел
<br>*`divmod`* `( a b -- a div b, a mod b)` вычисляет целую часть и остаток от деления двух целых чисел
<br>*`inc`* `( a -- a+1)` увеличивает целое число на 1
<br>*`dec`* `( a -- a-1)` уменьшает целое число на 1
<br>*`1+`* `( a -- a+1)` увеличивает int или uint на 1
<br>*`1-`* `( a -- a-1)` уменьшает int или uint на 1
<br>*`abs`* `( a -- |a|)` вычисляет модуль знакового числа
<br>*`neg`* `( a -- -a)` обращает знак числа знакого типа
<br>*`/`* `( ab -- a/b)` делит два числа с плавающей точкой
<br>*`cos`* `( a -- cos(a))` вычисляет косинус числа радиан с плавающей точкой
<br>*`sin`* `( a -- sin(a))` вычисляет синус числа радиан с плавающей точкой
<br>*`tan`* `( a -- tan(a))` вычисляет тангенс числа радиан с плавающей точкой
<br>*`atan`* `( a -- atan(a))` вычисляет арктангенс числа радиан с плавающей точкой
<br>*`atan2`* `( yx -- atan2(y, x))` см. в гугле atan2
<br>
=== bool&bits ===
*`false`* `( -- false)` кладёт на стек ложь (ячейка со сброшенными всеми битами, т.е. 0)
<br>*`true`* `( -- false)` кладёт на стек ложь (ячейка с выставленными всеми битами)
<br>*`not`* `( a -- not a)` побитовое НЕ. Применённое к true и false даёт булевский вариант
<br>*`or`* `( a b -- a or b)` побитовое ИЛИ. Применённая к true и false даёт булевский вариант
<br>*`and`* `( a b -- a and b)` побитовое И. Применённая к true и false даёт булевский вариант
<br>*`xor`* `( a b -- a xor b)` побитовое исключающее ИЛИ. Применённая к true и false даёт булевский вариант
<br>
=== createwords ===
*`create`* `( 'name'-)` создаёт новую команду с именем name
<br>*`allot`* `( i-)` выделяет i байт в шитом коде для последней созданной команды
<br>*`here`* `( -p)` текущий указатель на незанятую область шитого кода
<br>*`,`* ( i-)` выделяет ячейку в шитом коде, и записывает в неё ячейку со стека
<br>*`to`* `I ( i 'name'-) ( C:'name'-) ( R:i-)` записывает значение i в переменную name
<br>*`variable`* `( 'name'-)` создаёт команду с именем name, выделяет для неё ячейку в шитом коде. name кладёт на стек указатель на свою область в шитом коде
<br>*`value`* `( i 'name'-)` создаёт команду с именем name, выделяет для неё ячейку в шитом коде, инициализирует её числом со стека. name кладёт на стек значение из шитого кода
<br>*`constant`* `( i 'name'-)` то же, что и value
<br>*`does>`* в режиме компиляции приостанавливает компиляцию текущего определения и включает компиляцию для последнего созданного слова
<br>
=== ptr ===
*`@`* `( p-i)` читает ячейку, на которую ссылается указатель
<br>*`!`* `( ip-)` записывает ячейку по заданному адресу
<br>*`1+!`* `( p-)` увеличивает ячейку по заданному адресу на 1
<br>*`1-!`* `( p-)` уменьшает ячейку по заданному адресу на 1
<br>*`cell+`* `( p-p)` увеличивает значение указателя на размер ячейки
<br>*`cells`* `( i-i)` считает сколько байт займёт определённое кол-во ячеек
<br>*`malloc`* `( i-p)` выделяет i байт в куче, кладёт указатель на область
<br>*`free`* `( p-)` освобождает выделенную ранее при помощи malloc область
<br>*`move`* `( addr1 addr2 u -- )`     Копирует содержимое u последовательных байтов из addr1 в u     последовательных байтов в addr2. После завершения move,     u последовательных байтов в addr2 содержат то же, что     u последовательных байтов в addr1 содержали перед     перемещением.
<br>*`on`* `( ptr -- )` Выталкивает указатель, записывает true в него.
<br>*`off`* `( ptr -- )` Выталкивает указатель, записывает 0 в него.
<br>
=== statements ===
*`branch`* совершает скачек на определённый адрес в коде. При этом адрес берётся из последующего после команды числа в шитом коде.
<br>*`?branch`* ( i-) если i рано нулю, то действует как branch, в противном случае ничего не делает
<br>*`>mark`* I ( C:-- embroptr) при исполнении ничего не делает, при компиляции кладёт текущий адрес на стек и выделяет в шитом коде место под запись адреса
<br>*`>resolve`* I ( C:embroptr --) при исполнении ничего не делает, при компиляции извлекает со стека адрес в шитом коде и записывает по нему адрес текущего положения в шитом коде
<br>*`<mark`* I ( C:-- embroptr) при исполнении ничего не делает, при компиляции кладёт текущий адрес на стек
<br>*`<resolve`* I ( C:embroptr --) при исполнении ничего не делает, при компиляции извлекает со стека адрес в шитом коде и записывает его в шитый код
<br>*`:`* ( 'name'-) переводит машину в режим компиляции, начинает определение функции name
<br>*`;`*         I     Завершает определение функции, переводит машину в режим интерпретации и     добавляет новую команду в словарь        Пример использования:        {{{                : 195+ 195 + ;                5 195+ .        }}}
<br>*`immediate`* делает последнюю определённую команду командой немедленного исполнения
<br>*`exit`* выходит из текущей функции
<br>*`recurse`* I рекурсивный вызов определяемой функции
<br>*`if`*        I  Компиляция ( -- if-sys)    Кладёт в стек if-sys. if-sys необходимо разрешить при помощи    then или else, в противном случае поведение команды не определено.    Исполнение ( flag -- )    Выталкивает ячейку со стека, если она равна нулю, то переходит к     соответствующему then (или else). Иначе ничего не делает.  Интерпретация    В режиме интерпретации поведение команды не определено.  Пример  {{{    : say if [str]' Hi!' else [str]' See you!' then str. ;    true say    false say  }}}  См. else then
<br>*`else`*        I  Компиляция ( if-sys -- else-sys)    Разрешает if-sys, кладёт в стек else-sys, которую необходимо разрешить    при помощи then.    Исполнение ( -- )    Переходит к выполнению кода, разрешившего else-sys.  Интерпретация    В режиме интерпретации поведение команды не определено.  См. if then
<br>*`then`*        I  Компиляция ( if-sys | else-sys -- )    Разрешает if-sys, или else-sys.    Исполнение ( -- )    В период исполнения ничего не делает.  Интерпретация    В режиме интерпретации поведение команды не определено.  См. if
<br>
=== console ===
*`.`* ( i-) выводит число с вершины стека на консоль
<br>*`$`* ( -i) читает число с консоли
<br>
=== dyn ===
*`dyn`* ( start-length `name` -- )    Создаёт переменную динамический массив с именем name и изначально     выделенной памятью под start-length элементов. Начальная длина    всегда равна 0.  name ( -- dynamic )    Заталкивает ссылку на динамический массив, который воспринимают    слова для работы с дин. массивом (см. ниже). dynamic занимает     на стеке одну ячейку памяти и может обрабатываться обычными     командами для работы со стеком.  Пример:    0 dyn x // создаём динамический массив с начальной памятью под 0 элементов    105 x dyn+ // добавляем в массив число 105    457 x dyn+ // добавляем число 457    913 x dyn+    0 x dyn@ . // печатаем нулевой элемент на консоль (т.е. 105)    1 x dyn@ . // печатаем первый элемент на консоль (т.е. 457)  См. dyn# dyn[] dyn@ dyn! dyn+ high dyn.l@ dyn.l! dyn.last dyn-new            dyn.free
<br>*`dyn#`* ( dynamic -- int )    Снимает динамический массив и заталкивает его длину.   См. dyn
<br>*`dyn[]`* ( int dynamic -- ptr )    Снимает со стека индекс и динамический массив, и кладёт указатель    на элемент массива с этим индексом. Индекс должен быть неотрицательным     числом, меньшим, чем размер массива, в противном случае возникнет    неопределённая ситуация.    См. dyn
<br>*`dyn@`* ( index:int dynamic -- value:int )    Снимает со стека индекс и динамический массив, и кладёт значение     элемента с этим индексом. Индекс должен быть неотрицательным числом,     меньшим, чем размер массива, в противном случае возникнет    неопределённая ситуация.    См. dyn
<br>*`dyn!`* (  value:int index:int dynamic -- )    Снимает со стека значение, индекс и динамический массив, и записывает    значение в элемент массива с заданным индексом. Индекс должен быть     неотрицательным числом, меньшим, чем размер массива.    См. dyn
<br>*`high`* ( dynamic -- int )    Снимает динамический массив и заталкивает номер его последнего элемента,    т.е. длина минус один.    См. dyn
<br>*`dyn.l@`* ( dynamic -- length:int )    То же, что и dyn#.    См. dyn dyn#
<br>*`dyn.l!`* ( length:int dynamic -- )    Изменяет длину динамического массива на новую. При этом если нужно, то    будет перевыделена память (с сохранением значений).    См. dyn
<br>*`dyn.last`* ( dynamic -- ptr )    Снимает динамический массив и кладёт указатель на его последний элемент.    Неопределённая ситуация возникает в том случае, если у массива нет    последнего элемента (т.е. он имеет нулевую длину).    См. dyn
<br>*`dyn+`* ( value:int dynamic -- )    Увеличивает размер динамического массива на 1 и записывает в последний    элемент значение value.    См. dyn
<br>*`dyn-new`* ( start-length:int -- dynamic )    Создаёт динамический массив в куче.    См. dyn dyn.free
<br>*`dyn.free`* ( dynamic -- )    Удаляет созданный ранее при помощи dyn-new массив.    См. dyn dyn-new
<br>
=== file ===
*`file-open`* ( filename:str mode:int -- file)     Открывает файл. mode можно получить вызовом file-w или file-r.    file совместимо с обычной ячейкой, представляет из себя указатель на    структуру, описывающую текущее состояние работы с файлом. Каждый открытый    файл должен быть закрыт вызовом file-close как только файл становится    ненужным. В случае, если файл открыть не удалось, file будет нулевым.  См. file-close file-w file-r file-write file-read file-size
<br>*`file-close`* ( file --)     Закрывает открытый ранее файл.  См. file-open
<br>*`file-w`* ( -- mode:int)     Кладёт идентификатор режима, указывающий на то, что файл требуется открыть    на запись. К открытому в этом режиме файлу можно применять команду    file-write. При вызове file-open с этим режимом, если файла с именем     filename не существует, будет создан новый. Если существует, то его     содержимое будет стёрто, а запись будет производится в чистый файл.  См. file-open file-write
<br>*`file-r`* ( -- mode:int)     Кладёт идентификатор режима, указывающий на то, что файл требуется открыть    на чтение. К открытому в этом режиме файлу можно применять команды    file-read и file-size. При вызове file-open с этим режимом если файла с именем     filename не существует, то в качестве file вернётся 0.  См. file-open file-read file-size
<br>*`file-write`* ( ptr size:int file --)     Записывает size байт из ptr в файл с ненулевым, открытым на чтение    файлом file. Если file нулевой или открыт не на запись, действие     команды неопределёно.  См. file-open file-w
<br>*`file-read`* ( ptr size:int file --)     Считывает size байт из ненулевого, открытого на чтение файла file,    в ptr. Если file нулевой или открыт не на чтение, действие команды    неопределено.  См. file-open file-r
<br>*`file-size`* ( file -- int)     Считывает ненулевой, открытый на чтение файл, и кладёт его размер в байтах.    Если файл нулевой или не открыт на чтение, то действие команды неопределено.   См. file-open file-r
<br>
=== DEVM ===
*`_NOTFOUND_`* ( B: s -- ... true | false )  Если текущее имя не найдено в словаре, то вызывается _NOTFOUND_. Оно должно выполнить s и если это удаётся, то вернуть true. В противном случае оно должно вернуть false. При добавлении своего _NOTFOUND_ поведения рекомендуется учитывать старое:  {{{  : _NOTFOUND_ bdup _NOTFOUND_ ?dup if; ... ;  }}}
<br>
