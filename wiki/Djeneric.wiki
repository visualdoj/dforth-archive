= Djeneric =

Этот текст о некоторых моих идеях языка программирования с кодовым названием `Djeneric`.

= Основное описание =

 # Язык динамический. 
 # Типизация есть и статическая, и динамическая.
 # Сборщик мусора отсутствует (это осложняет работу программиста, которому всё время приходится следить за памятью).

= Выражения и их исполнение =

В языке есть возможность получать синтаксическое дерево выражений (имеющих тип `expr`), а так же их изменение и исполнение. Выражения можно сконструировать, записав код в фигурных скобках, а выполнить вызовом `eval`, т.е. такой код
{{{
eval({5 + 7})
}}}
вернёт 12.

У каждого выражения определён тип (в самом общем случае — `generic`).

= Типы, классы и наследования =

Никаких других типов, кроме классов, в языке нет.

В программе есть глобальное дерево, именуемое классовой иерархией, в каждой вершине которого записано имя, эти имена называются классами. В корне дерева находится `generic` (он же базовый класс). Основные классы:
{{{
generic
|-- class
|-- int
|-- str
|-- ptr
|-- func
|-- float
|---|-- single
|---|-- double
|-- expr
}}}

Каждому классу соответствует свой объект типа `class`. В этом объекте прописано, в частности, сколько и каких данных содержится в классе, от какого класса он унаследован (т.е. своё местоположение в классовой иерархии). Чтобы классам задавать своё уникальное поведение, отличное от поведения предка, достаточно реализовывать функции несколько видов, у одних тип первого аргумента — класс-потомок, у других — класс-предок. Например, если задано наследование `A -> B`, то так можно задать различные поведения функции tostr:
{{{
def tostr(a: A) { ... }
def tostr(b: B) { ... }
}}}

Подробней см. раздел про функции.

= Функции, методы и операторы =

Операторы от функций имеют отличие только на стадии построения синтаксического дерева, тем не менее при выполнении ничем не отличаются (т.е. `a+b` — выражение с одним вызовом функции сложения, которой передаются два параметра `a` и `b`).

Различий между функциями и методами нет. Код вида
{{{
f(a1, a2, ..., an)
}}}
считается вызовом функции и является эквивалентной записью для кода
{{{
call(f, a1, a2, ..., an)
}}}
(Которая, в свою очередь, является эквивалентной записью для кода `call(call, f, a1, a2, ..., an)`.)

Функциями считаются объекты типа `func`. У функции может быть несколько реализаций для разных типов параметров, при вызове будет выбрана наиболее подходящая в соответствии с классовой иерархией. Например, если есть классы `A -> B -> C` (C наследуется от B, B наследуется от A), и функция f
{{{
def f(c: C, b: B, n: int) {5}
def f(b: B, c: C, x) {"hello"}
def f(c: C, c: C) {create(C)}
}}}
то вызов
{{{
f(create(C), create(C), 77)
}}}
вернёт 5, т.е. будет вызван первый вариант, потому что в последнем не хватает параметров, а во втором первый аргумент выше в иерархии. Тут важно понятие маппирования типов параметров, т.е. соответствие между именем параметра и типом. Например в вызове
{{{
f(75, "hello", 5.7f, options = [i,o])
}}}
будет построено следующее маппирование:
|| имя параметра || тип параметра ||
|| 0 || int ||
|| 1 || str ||
|| 2 || float ||
|| options || set ||

Соответственно, у каждой реализации функции есть сигнатура, по сути тоже шаблон таблиц маппироания типов параметров, и задача определения нужной для вызова реализации функции сводится к поиску наиболее подходящей из имеющихся шаблонов.

Механизм вызова можно изменить на свой, достаточно унаследовать свой класс от `func`, реализовать свой вариант функции `call` для вашего класса, и создать функцию с типом вашего класса.

= Синтаксический сахар и синтаксическое дерево =

Программу всегда можно записать в некотором функциональном виде. Однако, для удобства, в языке есть синтаксический сахар, который позволяет записывать программы в более привычном виде.

|| Оператор || Функциональная запись ||
|| Бинарные `+ - * / % & ^` | || `operator+ operator- operator* ...` ||
|| Унарные `+ - ! ~` || `operator+ operator- operator! ...` ||
|| Присваивание `=` || `operator=` ||
|| Тернарный `a?b:c` || `operator?(a, b, c)` ||

|| Statement || Функциональная запись ||
|| Последовательность `{A1, A2, ..., AN}` || `#composite(A1, A2, ..., AN)` ||
|| Оператор если || `#if(cond, then, else)` ||

Задача синтаксического анализатора заключается в преобразовании программы в некоторое дерево, изоморфное соответствующей функциональной записи.

= Добавление собственных синтаксических конструкций =

Новая конструкция должна иметь определённое для себя поведение в двух шагах (как минимум)
 # При синтаксическом разборе
 # При выполнении и других операциях с `expr`

Т.к. построение синтаксического анализатора достаточно сложное дело, могут появится ограничения в расширениях.

Во втором случае всё сводится к операциям с синтаксическим деревом, и не представляет сложностей для расширения.

Набор используемых операторов (бинарных, унарных), их коммутативность, ассоциативность и приоритеты можно конфигурировать.

= Djim =

Язык `Djim` (`gimcrack` — A cheap and showy object of little or no use; a gewgaw., [http://www.thefreedictionary.com/gimcrack The American Heritage Dictionary of the English Language]) использует идеи языка `Djeneric`, но содержит в себе только дешёвую с точки зрения реализации функциональность.
