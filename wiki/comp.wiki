= Компиляция =

Стоит разделять несколько видов компиляции
  # Нативная (шитый код просто превращается в асм код) с использованием call/ret
  # Табличная с прямыми указателями

=== Нативная ===

Шитый код переписан в асме. Например,
{{{
: test + - + ;
}}}
Превратиться в код на асме для сложения, вычитания и сложения. Вызов test будет происходить обычным образом:
{{{
call @@test
}}}
а сама test завершается ret'ом.

=== Табличная с прямыми указателями ===

Главная прогрмма имеет вид (псевдокод)
{{{
@@mainloop: 
mov ecx, [esi]
add esi, 4
jmp ecx
}}}

esi -- указатель на "код", последовательность адресов подпрограмм, которые нужно вызвать. Пример:
{{{
: test + - + ;
}}}
певратиться в последовательность указателей на реализации + - +. Сами реализации + и - должны завершаться строкой
{{{
jmp @@mainloop
}}}

Вызов подпрограммы func и конструкция exit:
{{{
@@call:
push esi
mov esi, @@func
jmp @@mainloop

@@exit:
pop esi
jmp @@mainloop
}}}

Выгоды (32-бит архитектура)
  # Вызов любой команды занимать 4 байта в исполняемом файле
  # Не происходит использование стека при вызове команды.

Минусы
  # Сложнее делать inline'ы.

=== Реализации главного стека W ===

Вариант 1. Все данные стека храняться в оперативной памяти. Указатель на вершину стека хранится в регистре, не задействованном для fastcall с двумя параметрами. (Пусть это будет для примера EDX)
{{{
; +

}}}

Вариант 2. То же, что и Вариант 1 с тем отличием, что в другом незадействованном регистре (пусть EBX) храним верхние 4 байта стека.

(Для упрощения кода иногда будет использоваться обозначение TOP — для регистра, хранящего вершину стека, WP — для хранящего текущей указатель стека, и TEMP — для произвольного незанятого регистра.)

{{{
; 1+
inc TOP
; 1 такт

; 5
mov [WP], TOP
add WP, 4
mov TOP, 5
; 1 + 1 + 1 = 3 такта
; с учётом спаривания: 2 такта

; + 
sub WP, 4
add TOP, [WP]
; 1 + 2 = 3 такта

; swap -
sub WP, 4
sub TOP, [WP]
; 1 + 2 = 3 такта

; -
sub WP, 4
sub [WP], TOP
mov TOP, [WP]
; 1 + 3 + 1 = 5 тактов (!)
; может быть выполнив код для swap - и обратив знак можно ускорить алгоритм

; * 
sub WP, 4
imul TOP, [WP]

; div
sub EDX, 4
??? div EBX, [EDX]

; =
sub EDX, 4
xor EBX, [EDX]
??? if zero_flag then 
  dec EBX
??? else
  xor EBX, EBX

; swap
xchg TOP, [WP-4]

; over
mov [WP], TOP
mov TOP, [WP-4]
add WP, 4

; dup
mov [WP], TOP
add WP, 4

; tuck
mov TEMP, [WP-4]
mov [WP-4], TOP
mov [WP+4], TOP
mov [WP], TEMP
add WP, 4

; ?dup
mov [WP], TOP
??? if zero then inc EDX, 4

; false или 0
mov [WP], TOP
xor TOP, TOP
inc WP, 4

; true или -1
mov [WP], TOP
xor TOP, TOP
dec TOP
inc WP, 4
}}}

=== Литература ===
`[1]` [http://algolist.manual.ru/graphics/3dfaq/articles/61.php demo.design.3D programming FAQ ОПТИМИЗАЦИЯ Приемы оптимизации для процессоров Intel Pentium]

`[2]` [http://www.wasm.ru/publist.php?list=10 wasm.ru Оптимизации]