// 2011.18.07 # Doj
// ћодуль с объ€влени€ми, касающимис€ i386 ассемблера
// —одержит трансл€тор

include" units\statements\switch.de"

namespace I386
  // текуща€ позици€ в ассемблерном коде (дл€ вычислени€ адресов меток)
  : pos@ ( -p) ;
  // записать в ассемблерный код байт
  : byte<< uint->uint8 uint8, ;
  : word<< uint->uint16 uint16, ;
  : dword<< uint->uint32 uint32, ;
  // перехват сообщений об ошибках
  : error ( B: s) ." Error: " str. cr ;
  : unknown-operand-type " unknown operand type" error ;
  : underconstruction " underconstruction" error ;

  // таблица, сопоставл€юща€ имени метки адрес в пам€ти, 
  // по которому она используетс€
  // ....
  // : marks[]@ ( i -- p B: s) ... ;
  // : 
  // таблица, сопоставл€юща€ имени метки адрес в коде, 
  // на который метка должна ссылатьс€
  // ....
  // : label->pos ( B: s -- p) ... ;

  // создаЄт метку с именем name
  : @@ ( "name") source-next-name bdrop ; 

  0 enum OPERAND_TYPE
  OPERAND_TYPE OT_IMM // константа
  OPERAND_TYPE OT_REG // регистр
  OPERAND_TYPE OT_SEG // сегментный регистр
  OPERAND_TYPE OT_MEM // пам€ть

  0 enum DATA_TYPE
  DATA_TYPE DT_BYTE
  DATA_TYPE DT_WORD
  DATA_TYPE DT_DWORD
  DATA_TYPE DT_QWORD

  0 enum REG_TYPE
  REG_TYPE RT_32
  REG_TYPE RT_16
  REG_TYPE RT_8

  0 6 shl constant Mod_MODE_SIMPLE
  1 6 shl constant Mod_MODE_8
  2 6 shl constant Mod_MODE_32
  3 6 shl constant Mod_MODE_REG

  0
    t_int -- .type
    // value = immediate value for .type = OT_IMM
    // value = register for .type = OT_REG
    // value = segment register for .type = OT_REG
    // value = data type (see DT_*)
    t_int -- .value
    // for .type = OT_REG
    t_int -- .regtype // see RT_*
    // for .type = OT_MEM; [base + factor*index + disp]
    t_int -- .base?
    t_int -- .disp?
    t_int -- .base
    t_int -- .factor // 
    t_int -- .index
    t_int -- .disp
  struct s_operand

  variable *operands#
  : operands# *operands# @ ;
  : clear-operands 0 *operands# ! ;
  // проверка на число операндов, *operands-read хранит число операндов, 
  // съедаемых командой
  variable *operands-read
  : ?operands ( i) dup *operands-read ! dup operands# >
                   if int->str "  operands need, but " str+ 
                      operands# int->str str+ 
                      "  found" str+ error 
                   else drop then ;

  create *operands 4 s_operand * allot
  : last-operand *operands operands# 1- s_operand * + ;
  : first last-operand ;
  : second *operands operands# 2 - s_operand * + ;
  : third *operands operands# 3 - s_operand * + ;

  : operand+ ( type:int) *operands# 1+! last-operand .type ! ;

  : factor? ( o) .factor @ 0<> ;
  : disp? ( o) .disp @ 0<> ;
  : base? ( o) .base @ -1 = ;
 
  : 0op ( опкод) create , does> @ byte<< clear-operands ;
  : w-op ( опкод) create , does> @ byte<< first .value @ word<< clear-operands ;
  : r-op ( опкод) create , does> @ first .value @ + byte<< clear-operands ;

  : enum8 0 begin dup 8 < while dup constant 1+ repeat drop ;
  enum8 EAX ECX EDX EBX ESP EBP ESI EDI
  enum8 AX CX DX BX SP BP SI DI
  enum8 AL CL DL BL AH CH DH BH
  enum8 MM0 MM1 MM2 MM3 MM4 MM5 MM6 MM7
  enum8 XMM0 XMM1 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7
  0 constant ES
  1 constant CS
  2 constant SS
  3 constant DS
  4 constant FS
  5 constant GS
  EBP constant special-register
  ESP constant trouble-register

  : reg32 ( i) OT_REG operand+ last-operand .value ! 
                         RT_32 last-operand .regtype ! ; 
  : reg16 ( i) OT_REG operand+ last-operand .value ! 
                         RT_16 last-operand .regtype ! ; 
  : reg8  ( i) OT_REG operand+ last-operand .value ! 
                          RT_8 last-operand .regtype ! ; 
  : reg reg32 ;
  // : w-imm ( int) OT_WIMM operand+ *operand-value ! ;
  : imm ( int) OT_IMM operand+ last-operand .value ! ;
  : seg ( seg) OT_SEG operand+ last-operand .value ! ;
  // d[ ... ]d
  namespace MEM
    : base last-operand .base ! ;
    : factor last-operand .factor ! ;
    : index last-operand .index ! last-operand .factor @ 
            0= if 1 last-operand .factor ! then ;
    : disp last-operand .disp ! ;
    : ] ^^^ ;

    : 1* 1 factor ;
    : 2* 2 factor ;
    : 3* 3 factor ;
    : 4* 4 factor ;

    : short-reg create , does> @ last-operand .base @ -1 = if base else index then ;
    EAX short-reg eax
    ECX short-reg ecx
    EDX short-reg edx
    EBX short-reg ebx
    ESP short-reg esp
    EBP short-reg ebp
    ESI short-reg esi
    EDI short-reg edi
  \namespace

  : MEM call MEM OT_MEM operand+ 
       last-operand .factor off 
       last-operand .disp off 
       -1 last-operand .base ! ;
  : b[ MEM DT_BYTE last-operand .value ! ;
  : w[ MEM DT_WORD last-operand .value ! ;
  : d[ MEM DT_DWORD last-operand .value ! ;
  : q[ MEM DT_QWORD last-operand .value ! ;

  : reg32. ( reg)
    switch
      EAX of ." EAX " \of
      ECX of ." ECX " \of
      EDX of ." EDX " \of
      EBX of ." EBX " \of
      ESP of ." ESP " \of
      EBP of ." EBP " \of
      ESI of ." ESI " \of
      EDI of ." EDI " \of
      ." (UNKNOWN) "
    \switch
  ;
  : seg. ( reg)
    switch
      ES of ." ES " \of
      CS of ." CS " \of
      SS of ." SS " \of
      DS of ." DS " \of
      FS of ." FS " \of
      GS of ." GS " \of
      ." (UNKNOWN) "
    \switch
  ;
  : operand. ( p)
    dup .type @ switch
      OT_REG of .value @ reg32. \of
      OT_IMM of .value @ . \of
      OT_MEM of 
               ." ["
               dup .base @ reg32.
               dup factor? if ." + " dup .factor @ . ." *" dup .index @ reg32. then
               dup disp? if ." + " dup .disp @ . then
               ." ]" drop
             \of
      OT_SEG of .value @ seg. \of
    \switch
  ;


  namespace TRANSLATOR
    // список кратких регистров
    : short-reg32 create , does> @ reg32 ;
    EAX short-reg32 eax
    ECX short-reg32 ecx
    EDX short-reg32 edx
    EBX short-reg32 ebx
    ESP short-reg32 esp
    EBP short-reg32 ebp
    ESI short-reg32 esi
    EDI short-reg32 edi
    : short-reg16 create , does> @ reg16 ;
    AX short-reg16 ax
    CX short-reg16 cx
    DX short-reg16 dx
    BX short-reg16 bx
    SP short-reg16 sp
    BP short-reg16 bp
    SI short-reg16 si
    DI short-reg16 di
    : short-reg8 create , does> @ reg8 ;
    AL short-reg8 al
    CL short-reg8 cl
    DL short-reg8 dl
    BL short-reg8 bl
    AH short-reg8 ah
    CH short-reg8 ch
    DH short-reg8 dh
    BH short-reg8 bh
    // список кратких сегментных регистров
    : short-seg create , does> @ seg ;
    ES short-seg es
    CS short-seg cs
    SS short-seg ss
    DS short-seg ds
    FS short-seg fs
    GS short-seg gs

    : ModR/M ( iii-b) swap 3 shl or swap 6 shl or ;
    : mem<< ( rp-) 0 rrot .base @ ModR/M byte<< ;

// {{{ unary-op (INC, DEC)
    0
      t_int -- .reg
      t_int -- .ex
      t_int -- .r/m32
      t_int -- .r/m8
    struct s_unary
    : unary-op
      create , , , , does>
      1 ?operands
      first .type @ switch
        OT_MEM of 
                 first .value @ switch
                   DT_BYTE of dup .r/m8 @ byte<< .ex @ first mem<< \of
                   DT_DWORD of dup .r/m32 @ byte<< .ex @ first mem<< \of
                   ( error)
                 \switch
               \of
        OT_REG of .reg @ first .value @ + byte<< \of
        ( error)
      \switch
      clear-operands
    ;
   // }}}
    hFE hFF 0 h40 unary-op INC
    hFE hFF 1 h48 unary-op DEC

// {{{ NEG
    : unary-op
      create , , , , does>
      1 ?operands
      first .type @ switch
        OT_MEM of 
                 first .value @ switch
                   DT_BYTE of dup .r/m8 @ byte<< .ex @ first mem<< \of
                   DT_DWORD of dup .r/m32 @ byte<< .ex @ first mem<< \of
                   ( error)
                 \switch
               \of
        OT_REG of dup .r/m32 @ byte<< .ex @ first mem<< \of
        ( error)
      \switch
      clear-operands
    ;
    hF6 hF7 3 0 unary-op NEG
 // }}}
    h90 0op NOP
    hC2 w-op RET
    hC3 0op RET
// {{{ POP
    : POP
      1 ?operands
      first .type @ switch
        OT_REG of h58 first .value @ + byte<< \of
        OT_MEM of h8F byte<< 0 first mem<< \of
        OT_SEG of
                 first .value @ switch 
                   ES of h07 byte<< \of
                   CS of ( error) \of
                   SS of h17 byte<< \of
                   DS of h1F byte<< \of
                   FS of h0f byte<< hA1 byte<< \of
                   GS of h0F byte<< hA9 byte<< \of
                 \switch
               \of
        ( error)
      \switch clear-operands
    ;
// }}}
// {{{ PUSH
    : PUSH
      1 ?operands
      first .type @ switch
        OT_IMM of
                 first .value @ dup 256 < 
                 if h6A byte<< byte<<
                 else h68 byte<< dword<< then 
               \of
        OT_REG of h50 first .value @ + byte<< \of
        OT_MEM of hFF byte<< 6 first mem<< \of
        OT_SEG of
                 first .value @ switch 
                   ES of h06 byte<< \of
                   CS of h0E byte<< \of
                   SS of h16 byte<< \of
                   DS of h1E byte<< \of
                   FS of h0F byte<< hA0 byte<< \of
                   GS of h0F byte<< hA8 byte<< \of
                 \switch
               \of
      \switch clear-operands
    ;
// }}}
// {{{ MOV
// {{{ MOV reg
// {{{ MOV reg imm
    : MOV_reg_imm
      second .regtype @ switch
        RT_8 of hB0 second .value @ + byte<< first .value @ byte<< \of
        RT_16 of underconstruction \of
        RT_32 of hB8 second .value @ + byte<< first .value @ dword<< \of
      \switch
    ;
// }}}
// {{{ MOV reg reg
    : reg_reg<< Mod_MODE_REG second .value @ first .value @ ModR/M byte<< ;
    : MOV_reg_reg
      first .regtype @ second .regtype @ <> 
      if " both operands of MOV must have the same type" error then
      second .regtype @ switch
        RT_8 of h8A byte<< reg_reg<< \of
        RT_16 of underconstruction \of
        RT_32 of h8B byte<< reg_reg<< \of
      \switch
    ;
// }}}
// {{{ MOV reg mem
    : ?regsize=memsize first .value @ <> 
        if " both operand of MOV must have the same bit size" error then ;
    : reg_[r+f*i+...]<<
                first disp? if
                  first .disp @ 1 8 shl < 
                  if Mod_MODE_8 second .value @ first .base @ ModR/M byte<<
                    first .disp @ byte<<
                  else Mod_MODE_32 second .value @ first .base @ ModR/M byte<<
                    first .disp @ dword<< then                 
                else 
                  Mod_MODE_SIMPLE second .value @ first .base @ ModR/M byte<<
                then ;
    : reg_[esp+...]<< ;
    : reg_[r+...]<<
                first factor? if reg_[r+f*i+...]<< exit then    
                first .base @ trouble-register = if reg_[esp+...]<< exit then    
                first disp? if
                  first .disp @ 1 8 shl < 
                  if Mod_MODE_8 second .value @ first .base @ ModR/M byte<<
                    first .disp @ byte<<
                  else Mod_MODE_32 second .value @ first .base @ ModR/M byte<<
                    first .disp @ dword<< then                 
                else 
                  Mod_MODE_SIMPLE second .value @ first .base @ ModR/M byte<<
                then ;
    : MOV_reg_mem
      second .regtype @ switch
        RT_8 of DT_BYTE ?regsize=memsize h8A byte<< reg_[r+...]<< \of
        RT_16 of underconstruction \of
        RT_32 of DT_DWORD ?regsize=memsize h8B byte<< reg_[r+...]<< \of
      \switch
    ;
// }}}
    : MOV_reg_seg ;
    : MOV_reg
      first .type @ switch
        OT_IMM of MOV_reg_imm \of
        OT_REG of MOV_reg_reg \of
        OT_MEM of MOV_reg_mem \of
        OT_SEG of MOV_reg_seg \of
      \switch
    ;
// }}}
// {{{ MOV mem
    : MOV_mem underconstruction ;
// }}}
// {{{ MOV seg
    : MOV_seg underconstruction ;
// }}}
    : MOV
      2 ?operands
      second .type @ switch
        OT_IMM of " dst operand of MOV cannot be immediate " error \of
        OT_REG of MOV_reg \of
        OT_MEM of MOV_mem \of
        OT_SEG of MOV_seg \of
        unknown-operand-type
      \switch clear-operands
    ;
// }}}

    namespace PREFIX
      variable *xt
      : \PREFIX ^^^ *xt @ execute ;
      : prefix-mnemonic ( p "name") create , does> @ *xt dup @ execute ! ;
      ' PUSH prefix-mnemonic push
      ' POP prefix-mnemonic pop
      ' NOP prefix-mnemonic nop
      ' RET prefix-mnemonic ret
      ' INC prefix-mnemonic inc
      ' DEC prefix-mnemonic dec
      ' NEG prefix-mnemonic neg
      ' MOV prefix-mnemonic mov
    \namespace
    : PREFIX call PREFIX ['] nop PREFIX *xt ^ ! ;
  \namespace
\namespace
