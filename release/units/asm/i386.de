// 2011.18.07 # Doj
// ћодуль с объ€влени€ми, касающимис€ i386 ассемблера
// —одержит трансл€тор

include" units\statements\switch.de"

namespace I386
  // текуща€ позици€ в ассемблерном коде (дл€ вычислени€ адресов меток)
  : pos@ ( -p) ;
  // записать в ассемблерный код байт
  : byte<< uint->uint8 uint8, ;
  : word<< uint->uint16 uint16, ;
  : dword<< uint->uint32 uint32, ;

  // таблица, сопоставл€юща€ имени метки адрес в пам€ти, 
  // по которому она используетс€
  // ....
  // : marks[]@ ( i -- p B: s) ... ;
  // : 
  // таблица, сопоставл€юща€ имени метки адрес в коде, 
  // на который метка должна ссылатьс€
  // ....
  // : label->pos ( B: s -- p) ... ;

  // создаЄт метку с именем name
  : @@ ( "name") source-next-name bdrop ; 

  0 enum OPERAND_TYPE
  OPERAND_TYPE OT_IMM // константа
  OPERAND_TYPE OT_REG // регистр
  OPERAND_TYPE OT_SEG // сегментный регистр
  OPERAND_TYPE OT_MEM // пам€ть

  0
    t_int -- .type
    // value = immediate value for .type = OT_IMM
    // value = register for .type = OT_REG
    // value = segment register for .type = OT_REG
    t_int -- .value
    // for .type = OT_MEM; [base + factor*index + disp]
    t_int -- .base?
    t_int -- .disp?
    t_int -- .base
    t_int -- .factor // 
    t_int -- .index
    t_int -- .disp
  struct s_operand

  variable *operands#
  : operands# *operands# @ ;
  : clear-operands 0 *operands# ! ;

  create *operands 4 s_operand * allot
  : first *operands ;
  : second *operands s_operand + ;
  : third *operands s_operand dup + + ;
  : last-operand *operands operands# 1- s_operand * + ;

  : operand+ ( type:int) *operands# 1+! last-operand .type ! ;

  : factor? ( op) .factor @ 0<> ;
  : disp? ( op) .disp @ 0<> ;
 
  : 0op ( опкод) create , does> @ byte<< clear-operands ;
  : w-op ( опкод) create , does> @ byte<< first .value @ word<< clear-operands ;
  : r-op ( опкод) create , does> @ first .value @ + byte<< clear-operands ;

  : enum8 0 begin dup 8 < while dup constant 1+ repeat drop ;
  enum8 EAX ECX EDX EBX ESP EBP ESI EDI
  enum8 AX CX DX BX SP BP SI DI
  enum8 AL CL DL BL AH CH DH BH
  enum8 MM0 MM1 MM2 MM3 MM4 MM5 MM6 MM7
  enum8 XMM0 XMM1 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7
  0 constant ES
  1 constant CS
  2 constant SS
  3 constant DS
  4 constant FS
  5 constant GS

  : reg ( reg) OT_REG operand+ last-operand .value ! ; 
  // : w-imm ( int) OT_WIMM operand+ *operand-value ! ;
  : imm ( int) OT_IMM operand+ last-operand .value ! ;
  : seg ( seg) OT_SEG operand+ last-operand .value ! ;
  // d[ ... ]d
  namespace d[
    : base last-operand .base ! ;
    : factor last-operand .factor ! ;
    : index last-operand .index ! last-operand .factor @ 
            0= if 1 last-operand .factor ! then ;
    : disp last-operand .disp ! ;
    : ] ^^^ ;

    : 1* 1 factor ;
    : 2* 2 factor ;
    : 3* 3 factor ;
    : 4* 4 factor ;

    : short-reg create , does> @ last-operand .base @ -1 = if base else index then ;
    EAX short-reg eax
    ECX short-reg ecx
    EDX short-reg edx
    EBX short-reg ebx
    ESP short-reg esp
    EBP short-reg ebp
    ESI short-reg esi
    EDI short-reg edi
  \namespace
  : d[ call d[ OT_MEM operand+ 
       last-operand .factor off 
       last-operand .disp off 
       -1 last-operand .base ! ;

  : reg32. ( reg)
    switch
      EAX of ." EAX " \of
      ECX of ." ECX " \of
      EDX of ." EDX " \of
      EBX of ." EBX " \of
      ESP of ." ESP " \of
      EBP of ." EBP " \of
      ESI of ." ESI " \of
      EDI of ." EDI " \of
      ." (UNKNOWN) "
    \switch
  ;
  : seg. ( reg)
    switch
      ES of ." ES " \of
      CS of ." CS " \of
      SS of ." SS " \of
      DS of ." DS " \of
      FS of ." FS " \of
      GS of ." GS " \of
      ." (UNKNOWN) "
    \switch
  ;
  : operand. ( p)
    dup .type @ switch
      OT_REG of .value @ reg32. \of
      OT_IMM of .value @ . \of
      OT_MEM of 
               ." ["
               dup .base @ reg32.
               dup factor? if ." + " dup .factor @ . ." *" dup .index @ reg32. then
               dup disp? if ." + " dup .disp @ . then
               ." ]" drop
             \of
      OT_SEG of .value @ seg. \of
    \switch
  ;


  namespace TRANSLATOR
    : short-reg create , does> @ reg ;
    EAX short-reg eax
    ECX short-reg ecx
    EDX short-reg edx
    EBX short-reg ebx
    ESP short-reg esp
    EBP short-reg ebp
    ESI short-reg esi
    EDI short-reg edi
    : short-seg create , does> @ seg ;
    ES short-reg es
    CS short-reg cs
    SS short-reg ss
    DS short-reg ds
    FS short-reg fs
    GS short-reg gs

    : ModR/M ( iii-b) swap 3 shl or swap 6 shl or ;
    : mem<< ( rp-) 0 rrot .base @ ModR/M byte<< ;
 
    h90 0op NOP
    h3A 0op ABX
    h3D 0op MUL
    hC2 w-op RET
    hC3 0op RET
    // 195 0op RET
    
    h40 r-op INC
    h48 r-op DEC

    h50 r-op PUSH
    h58 r-op POP

    : PUSH
      // operands# 2 check-operands-count
      first .type @ switch
        OT_IMM of
                 first .value @ dup 256 < 
                 if h6A byte<< byte<<
                 else h68 byte<< dword<< then 
               \of
        OT_REG of h50 first .value @ + byte<< \of
        OT_MEM of hFF byte<< 6 first mem<< \of
        OT_SEG of
                 first .value @ switch 
                   ES of \of
                   CS of h0E byte<< \of
                   SS of h16 byte<< \of
                   DS of h1E byte<< \of
                   FS of h0F byte<< hA0 byte<< \of
                   GS of h0F byte<< hA8 byte<< \of
                 \switch
               \of
      \switch clear-operands
    ;
  \namespace
\namespace
