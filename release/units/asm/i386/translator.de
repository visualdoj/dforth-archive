// 2011.07.31 # Doj
// Транслятор

include" units\asm\i386\description.de"

I386 extend-namespace 
  namespace COMMANDS
    uses COMMAND_DESCRIPTION
      include" units\asm\i386\tables\ia32.de"
    \uses
  \namespace
\namespace

I386 extend-namespace 
uses COMMAND_DESCRIPTION COMMANDS
  namespace TRANSLATOR
    // default
    *auto-integers? off

    // список кратких регистров
    : short-reg32 create , does> @ reg32 ;
    EAX short-reg32 eax
    ECX short-reg32 ecx
    EDX short-reg32 edx
    EBX short-reg32 ebx
    ESP short-reg32 esp
    EBP short-reg32 ebp
    ESI short-reg32 esi
    EDI short-reg32 edi
    : short-reg16 create , does> @ reg16 ;
    AX short-reg16 ax
    CX short-reg16 cx
    DX short-reg16 dx
    BX short-reg16 bx
    SP short-reg16 sp
    BP short-reg16 bp
    SI short-reg16 si
    DI short-reg16 di
    : short-reg8 create , does> @ reg8 ;
    AL short-reg8 al
    CL short-reg8 cl
    DL short-reg8 dl
    BL short-reg8 bl
    AH short-reg8 ah
    CH short-reg8 ch
    DH short-reg8 dh
    BH short-reg8 bh
    // список кратких сегментных регистров
    : short-seg create , does> @ seg ;
    ES short-seg es
    CS short-seg cs
    SS short-seg ss
    DS short-seg ds
    FS short-seg fs
    GS short-seg gs

// {{{ PREFIX
    namespace PREFIX
      variable *xt
      : \PREFIX ^^^ *xt @ execute ;
      : prefix-mnemonic ( p "name") create , does> @ PREFIX *xt ^ dup @ execute ! ;
    \namespace
    : prefix-reset PREFIX *xt ^ dup @ execute ['] nop swap ! ;
    : step-prefix-reset compile? if postpone prefix-reset else prefix-reset then ;
// }}}
// {{{ directives
    namespace DB
      : \db ^^^ ; immediate
      : _COMPILE_NOTFOUND_ str->int postpone literal postpone byte<< true ;
      : _NOTFOUND_ str->int byte<< true ;
    \namespace
    : db call DB step-prefix-reset ; immediate
    namespace DW
      : \dw ^^^ ; immediate
      : _COMPILE_NOTFOUND_ str->int postpone literal postpone word<< true ;
      : _NOTFOUND_ str->int byte<< true ;
    \namespace
    : dw call DW step-prefix-reset ; immediate
    namespace DD
      : \dd ^^^ ; immediate
      : _COMPILE_NOTFOUND_ str->int postpone literal postpone dword<< true ;
      : _NOTFOUND_ str->int byte<< true ;
    \namespace
    : dd call DD step-prefix-reset ; immediate
// }}}

    : mem<< ( rp-) 0 rrot .base @ ModR/M byte<< ;

// {{{ unary-op (INC, DEC)
    0
      t_int -- .reg
      t_int -- .ex
      t_int -- .r/m32
      t_int -- .r/m8
    struct s_unary
    : unary-op
      create , , , , does>
      1 ?operands
      first .type @ switch
        OT_MEM of 
                 first .value @ switch
                   DT_BYTE of dup .r/m8 @ byte<< .ex @ first mem<< \of
                   DT_DWORD of dup .r/m32 @ byte<< .ex @ first mem<< \of
                   ( error)
                 \switch
               \of
        OT_REG of .reg @ first .value @ + byte<< \of
        ( error)
      \switch
      clear-operands
    ;
   // }}}
    hFE hFF 0 h40 unary-op INC
    hFE hFF 1 h48 unary-op DEC

// {{{ NEG
    : unary-op
      create , , , , does>
      1 ?operands
      first .type @ switch
        OT_MEM of 
                 first .value @ switch
                   DT_BYTE of dup .r/m8 @ byte<< .ex @ first mem<< \of
                   DT_DWORD of dup .r/m32 @ byte<< .ex @ first mem<< \of
                   ( error)
                 \switch
               \of
        OT_REG of dup .r/m32 @ byte<< .ex @ first mem<< \of
        ( error)
      \switch
      clear-operands
    ;
    hF6 hF7 3 0 unary-op NEG
 // }}}
    h90 0op NOP
    hC2 w-op RET
    hC3 0op RET
// {{{ POP
    : POP
      1 ?operands
      first .type @ switch
        OT_REG of h58 first .value @ + byte<< \of
        OT_MEM of h8F byte<< 0 first mem<< \of
        OT_SEG of
                 first .value @ switch 
                   ES of h07 byte<< \of
                   CS of ( error) \of
                   SS of h17 byte<< \of
                   DS of h1F byte<< \of
                   FS of h0f byte<< hA1 byte<< \of
                   GS of h0F byte<< hA9 byte<< \of
                 \switch
               \of
        ( error)
      \switch clear-operands
    ;
// }}}
// {{{ PUSH
    : PUSH
      1 ?operands
      first .type @ switch
        OT_IMM of
                 first .value @ dup 256 < 
                 if h6A byte<< byte<<
                 else h68 byte<< dword<< then 
               \of
        OT_REG of h50 first .value @ + byte<< \of
        OT_MEM of hFF byte<< 6 first mem<< \of
        OT_SEG of
                 first .value @ switch 
                   ES of h06 byte<< \of
                   CS of h0E byte<< \of
                   SS of h16 byte<< \of
                   DS of h1E byte<< \of
                   FS of h0F byte<< hA0 byte<< \of
                   GS of h0F byte<< hA8 byte<< \of
                 \switch
               \of
      \switch clear-operands
    ;
// }}}
// {{{ MOV
// {{{ MOV reg
// {{{ MOV reg imm
    : MOV_reg_imm
      second .regtype @ switch
        RT_8  of COMMAND_DESCRIPTION MOV8_reg_imm ^ \of
        RT_16 of 16 switch<< COMMAND_DESCRIPTION MOV16_reg_imm ^ \of
        RT_32 of 32 switch<< COMMAND_DESCRIPTION MOV32_reg_imm ^ \of
      \switch
    ;
// }}}
// {{{ MOV reg reg
    : MOV_reg_reg
      first .regtype @ second .regtype @ <> 
      if " both operands of MOV must have the same type" error then
      second .regtype @ switch
        RT_8 of COMMAND_DESCRIPTION MOV8_reg_reg ^ \of
        RT_16 of 16 switch<< COMMAND_DESCRIPTION MOV16_reg_reg ^ \of
        RT_32 of 32 switch<< COMMAND_DESCRIPTION MOV32_reg_reg ^ \of
      \switch
    ;
// }}}
// {{{ MOV reg mem
    : MOV_reg_mem
      second .value @ EAX = first .base @ -1 = and first .factor @ 0= and if
        // особый случай
        second .regtype @ switch
          RT_8  of COMMAND_DESCRIPTION MOV8_al_moffset ^ \of
          RT_16 of COMMAND_DESCRIPTION MOV16_ax_moffset ^ \of
          RT_32 of COMMAND_DESCRIPTION MOV32_eax_moffset ^ \of
        \switch
        exit
      then
      second .regtype @ switch
        RT_8  of COMMAND_DESCRIPTION MOV8_reg_mem ^ \of
        RT_16 of COMMAND_DESCRIPTION MOV16_reg_mem ^ \of
        RT_32 of COMMAND_DESCRIPTION MOV32_reg_mem ^ \of
      \switch
    ;
// }}}
// {{{ MOV reg seg
    : MOV_reg_seg 
      first .value @ DT_WORD = if
        16 switch<< COMMAND_DESCRIPTION MOV16_mem_seg ^
      else " mov to segment register must be 16-bit memory operand" error then
    ;
// }}}
    : MOV_reg
      first .type @ switch
        OT_IMM of MOV_reg_imm \of
        OT_REG of MOV_reg_reg \of
        OT_MEM of MOV_reg_mem \of
        OT_SEG of MOV_reg_seg \of
      \switch
    ;
// }}}
// {{{ MOV mem
    : MOV_mem_imm
      second .value @ switch
        DT_BYTE of COMMAND_DESCRIPTION MOV8_mem_imm ^ \of
        DT_WORD of ( 16 switch<<) COMMAND_DESCRIPTION MOV16_mem_imm ^ \of
        DT_DWORD of ( 32 switch<<) COMMAND_DESCRIPTION MOV32_mem_imm ^ \of
        unknown-operand-type
      \switch
    ;
    : MOV_mem_reg 
      first .value @ EAX = second .base? @ not and second .factor @ 0= and if
        // особый случай
        first .regtype @ switch
          RT_8 of COMMAND_DESCRIPTION MOV8_moffset_al ^ \of
          RT_16 of 16 switch<< COMMAND_DESCRIPTION MOV16_moffset_ax ^ \of
          RT_32 of 32 switch<< COMMAND_DESCRIPTION MOV32_moffset_eax ^ \of
          unknown-operand-type
        \switch
        exit
      then
      // TODO проверить на соответствие data type
      first .regtype @ switch
        RT_8 of COMMAND_DESCRIPTION MOV8_mem_reg ^ \of
        RT_16 of 16 switch<< COMMAND_DESCRIPTION MOV16_mem_reg ^ \of
        RT_32 of 32 switch<< COMMAND_DESCRIPTION MOV32_mem_reg ^ \of
        unknown-operand-type
      \switch
    ;
    : MOV_mem_seg 
      second .value @ DT_WORD = if
        16 switch<< COMMAND_DESCRIPTION MOV16_mem_seg ^
      else " mov from segment register must be 16-bit memory operand" error then
    ;
    : MOV_mem 
      first .type @ switch
        OT_IMM of MOV_mem_imm \of
        OT_REG of MOV_mem_reg \of
        OT_SEG of MOV_mem_seg \of
        " cannot mov from mem to mem"
      \switch
    ;
// }}}
// {{{ MOV seg
    : MOV_seg 
      first .type @ switch
        OT_REG of first .regtype @ RT_16 <> 
                  if " must be 16-bit register in this format" error then 
                  16 switch<< MOV16_seg_reg
        \of
        OT_MEM of first .value @ DT_WORD <> 
                  if " must be 16-bit memory access in this format" error then 
                  16 switch<< MOV16_seg_mem
        \of
        OT_IMM of " cannot mov immediate data to segment register" error \of
        OT_SEG of " cannot mov segment regfister to segment register" error \of
        unknown-operand-type
      \switch
    ;
// }}}
    : MOV
      2 ?operands
      second .type @ switch
        OT_IMM of " dst operand of MOV cannot be immediate " error \of
        OT_REG of MOV_reg \of
        OT_MEM of MOV_mem \of
        OT_SEG of MOV_seg \of
        unknown-operand-type
      \switch clear-operands
    ;
// }}}
// {{{ XOR
// {{{ XOR reg
// {{{ XOR reg imm
    : XOR_reg_imm
      second .regtype @ switch
        RT_8  of COMMAND_DESCRIPTION XOR8_reg_imm ^ \of
        RT_16 of COMMAND_DESCRIPTION XOR16_reg_imm ^ \of
        RT_32 of COMMAND_DESCRIPTION XOR32_reg_imm ^ \of
      \switch
    ;
// }}}
// {{{ XOR reg reg
    : XOR_reg_reg
      first .regtype @ second .regtype @ <> 
      if " both operands of XOR must have the same type" error then
      second .regtype @ switch
        RT_8 of COMMAND_DESCRIPTION XOR8_reg_reg ^ \of
        RT_16 of COMMAND_DESCRIPTION XOR16_reg_reg ^ \of
        RT_32 of COMMAND_DESCRIPTION XOR32_reg_reg ^ \of
      \switch
    ;
// }}}
// {{{ XOR reg mem
    : XOR_reg_mem
      second .regtype @ switch
        RT_8  of COMMAND_DESCRIPTION XOR8_reg_mem ^ \of
        RT_16 of COMMAND_DESCRIPTION XOR16_reg_mem ^ \of
        RT_32 of COMMAND_DESCRIPTION XOR32_reg_mem ^ \of
      \switch
    ;
// }}}
// {{{ XOR reg seg
    : XOR_reg_seg 
      first .value @ DT_WORD = if
        // 16 switch<< COMMAND_DESCRIPTION XOR16_mem_seg ^
      else " mov to segment register must be 16-bit memory operand" error then
    ;
// }}}
    : XOR_reg
      first .type @ switch
        OT_IMM of XOR_reg_imm \of
        OT_REG of XOR_reg_reg \of
        OT_MEM of XOR_reg_mem \of
        OT_SEG of XOR_reg_seg \of
      \switch
    ;
// }}}
// {{{ XOR mem
    : XOR_mem_imm
      second .value @ switch
        DT_BYTE of COMMAND_DESCRIPTION XOR8_mem_imm ^ \of
        DT_WORD of COMMAND_DESCRIPTION XOR16_mem_imm ^ \of
        DT_DWORD of COMMAND_DESCRIPTION XOR32_mem_imm ^ \of
        unknown-operand-type
      \switch
    ;
    : XOR_mem_reg 
      first .regtype @ switch
        RT_8 of COMMAND_DESCRIPTION XOR8_mem_reg ^ \of
        RT_16 of COMMAND_DESCRIPTION XOR16_mem_reg ^ \of
        RT_32 of COMMAND_DESCRIPTION XOR32_mem_reg ^ \of
        unknown-operand-type
      \switch
    ;
    : XOR_mem_seg 
      second .value @ DT_WORD = if
        // COMMAND_DESCRIPTION XOR16_mem_seg ^
      else " mov from segment register must be 16-bit memory operand" error then
    ;
    : XOR_mem 
      first .type @ switch
        OT_IMM of XOR_mem_imm \of
        OT_REG of XOR_mem_reg \of
        OT_SEG of XOR_mem_seg \of
        " cannot mov from mem to mem"
      \switch
    ;
// }}}
// {{{ XOR seg
    : XOR_seg 
      first .type @ switch
        OT_REG of first .regtype @ RT_16 <> 
                  if " must be 16-bit register in this format" error then 
                  // TODO 16 switch<< XOR16_seg_reg
        \of
        OT_MEM of first .value @ DT_WORD <> 
                  if " must be 16-bit memory access in this format" error then 
                  // TODO 16 switch<< XOR16_seg_mem
        \of
        OT_IMM of " cannot mov immediate data to segment register" error \of
        OT_SEG of " cannot mov segment regfister to segment register" error \of
        unknown-operand-type
      \switch
    ;
// }}}
    : XOR
          2 ?operands
          second .type @ switch
            OT_IMM of " dst operand of XOR cannot be immediate " error \of
            OT_REG of XOR_reg \of
            OT_MEM of XOR_mem \of
            OT_SEG of XOR_seg \of
            unknown-operand-type
          \switch clear-operands
    ;
// }}}
// {{{ AND
// {{{ AND reg
// {{{ AND reg imm
    : AND_reg_imm
      second .regtype @ switch
        RT_8  of COMMAND_DESCRIPTION AND8_reg_imm ^ \of
        RT_16 of COMMAND_DESCRIPTION AND16_reg_imm ^ \of
        RT_32 of COMMAND_DESCRIPTION AND32_reg_imm ^ \of
      \switch
    ;
// }}}
// {{{ AND reg reg
    : AND_reg_reg
      first .regtype @ second .regtype @ <> 
      if " both operands of AND must have the same type" error then
      second .regtype @ switch
        RT_8 of COMMAND_DESCRIPTION AND8_reg_reg ^ \of
        RT_16 of COMMAND_DESCRIPTION AND16_reg_reg ^ \of
        RT_32 of COMMAND_DESCRIPTION AND32_reg_reg ^ \of
      \switch
    ;
// }}}
// {{{ AND reg mem
    : AND_reg_mem
      second .regtype @ switch
        RT_8  of COMMAND_DESCRIPTION AND8_reg_mem ^ \of
        RT_16 of COMMAND_DESCRIPTION AND16_reg_mem ^ \of
        RT_32 of COMMAND_DESCRIPTION AND32_reg_mem ^ \of
      \switch
    ;
// }}}
// {{{ AND reg seg
    : AND_reg_seg 
      first .value @ DT_WORD = if
        // 16 switch<< COMMAND_DESCRIPTION AND16_mem_seg ^
      else " mov to segment register must be 16-bit memory operand" error then
    ;
// }}}
    : AND_reg
      first .type @ switch
        OT_IMM of AND_reg_imm \of
        OT_REG of AND_reg_reg \of
        OT_MEM of AND_reg_mem \of
        OT_SEG of AND_reg_seg \of
      \switch
    ;
// }}}
// {{{ AND mem
    : AND_mem_imm
      second .value @ switch
        DT_BYTE of COMMAND_DESCRIPTION AND8_mem_imm ^ \of
        DT_WORD of COMMAND_DESCRIPTION AND16_mem_imm ^ \of
        DT_DWORD of COMMAND_DESCRIPTION AND32_mem_imm ^ \of
        unknown-operand-type
      \switch
    ;
    : AND_mem_reg 
      first .regtype @ switch
        RT_8 of COMMAND_DESCRIPTION AND8_mem_reg ^ \of
        RT_16 of COMMAND_DESCRIPTION AND16_mem_reg ^ \of
        RT_32 of COMMAND_DESCRIPTION AND32_mem_reg ^ \of
        unknown-operand-type
      \switch
    ;
    : AND_mem_seg 
      second .value @ DT_WORD = if
        // COMMAND_DESCRIPTION AND16_mem_seg ^
      else " mov from segment register must be 16-bit memory operand" error then
    ;
    : AND_mem 
      first .type @ switch
        OT_IMM of AND_mem_imm \of
        OT_REG of AND_mem_reg \of
        OT_SEG of AND_mem_seg \of
        " cannot mov from mem to mem"
      \switch
    ;
// }}}
// {{{ AND seg
    : AND_seg 
      first .type @ switch
        OT_REG of first .regtype @ RT_16 <> 
                  if " must be 16-bit register in this format" error then 
                  // TODO 16 switch<< AND16_seg_reg
        \of
        OT_MEM of first .value @ DT_WORD <> 
                  if " must be 16-bit memory access in this format" error then 
                  // TODO 16 switch<< AND16_seg_mem
        \of
        OT_IMM of " cannot mov immediate data to segment register" error \of
        OT_SEG of " cannot mov segment regfister to segment register" error \of
        unknown-operand-type
      \switch
    ;
// }}}
    : AND
          2 ?operands
          second .type @ switch
            OT_IMM of " dst operand of AND cannot be immediate " error \of
            OT_REG of AND_reg \of
            OT_MEM of AND_mem \of
            OT_SEG of AND_seg \of
            unknown-operand-type
          \switch clear-operands ;
// }}}

    : MUL_reg
        first .regtype @ switch
          RT_8 of COMMAND_DESCRIPTION MUL8_reg ^ \of
          RT_16 of COMMAND_DESCRIPTION MUL16_reg ^ \of
          RT_32 of COMMAND_DESCRIPTION MUL32_reg ^ \of
          unknown-operand-type
        \switch ;
    : MUL_mem
      first .value @ switch
        DT_BYTE of COMMAND_DESCRIPTION MUL8_mem ^ \of
        DT_WORD of COMMAND_DESCRIPTION MUL16_mem ^ \of
        DT_DWORD of COMMAND_DESCRIPTION MUL32_mem ^ \of
        unknown-operand-type
      \switch ;
    : MUL
        1 ?operands
        first .type @ switch
          OT_REG of MUL_reg \of
          OT_MEM of MUL_mem \of
          unknown-operand-type
        \switch clear-operands ;

    : IMUL_reg
        first .regtype @ switch
          RT_8 of COMMAND_DESCRIPTION IMUL8_reg ^ \of
          RT_16 of COMMAND_DESCRIPTION IMUL16_reg ^ \of
          RT_32 of COMMAND_DESCRIPTION IMUL32_reg ^ \of
          unknown-operand-type
        \switch ;
    : IMUL_reg_*
        ;
    : IMUL_reg_*_*
        ;
    : IMUL
        operands# switch
          0 of " incorrect number of parameters" error \of
            
          1 of first .type @ OT_REG =
               if IMUL_reg else unknown-operand-type then \of
          2 of second .type @ OT_REG = 
               if IMUL_reg_* else unknown-operand-type then \of
          third .type @ OT_REG =
               if IMUL_reg_*_* else unknown-operand-type then
        \switch clear-operands ;

    : _COMPILE_NOTFOUND_
        *auto-integers? @ dup if str->int postpone literal postpone imm 
                              else bdrop then
    ;
    : _NOTFOUND_ // false bdrop exit
        // str-nospace if true exit then
        *auto-integers? @ dup if str->int imm else bdrop then
    ;    

    
    PREFIX 
      : PREFIX call PREFIX ['] nop PREFIX *xt ^ ! ;
      ' DEC prefix-mnemonic dec
      ' INC prefix-mnemonic inc
      ' IMUL prefix-mnemonic imul
      ' MOV prefix-mnemonic mov
      ' MUL prefix-mnemonic mul
      ' AND prefix-mnemonic and
      ' XOR prefix-mnemonic xor
      ' NEG prefix-mnemonic neg
      ' NOP prefix-mnemonic nop
      ' POP prefix-mnemonic pop
      ' PUSH prefix-mnemonic push
      ' RET prefix-mnemonic ret
    ^
  \namespace
\uses
\namespace
