// 2011.08.07 # Doj
// Реализация меток для условного и безусловного переходов

include" units\asm\i386\core.de"
include" units\structures\ndyn.de"

I386 extend-namespace 
  namespace LABELS
    0
      t_str -- .marker
      t_ptr -- .pos
    struct s_marker
    16 s_marker ndyn-global M
    
    // Делает контейнер M пустым
    : M-clear
      M# begin ?dup while 1-
        dup M[] .marker 0 w>b b!
      repeat
      0 M#! ;

    0
      t_str -- .label
      t_ptr -- .ptr
      t_ptr -- .xt
    struct s_label
    16 s_label ndyn-global L

    // Делает контейнер L пустым
    : L-clear
      L# begin ?dup while 1-
        dup L[] .label 0 w>b b!
      repeat
      0 L#! ;

    : @> ( "name")
        M0+
        source-next-name M[#] .marker b!
        pos@ M[#] .pos ! ;
    : label+ ( B: s -- l) L0+ L[#] dup .label b! ;
    : @@ ( "name" --) source-next-name label+ link ;
    : label! ( pxl) tuck .xt ! .ptr ! ;

    : label-resolve ( pos label) dup .ptr @ swap .xt @ execute ;
    ( а оно нам нужно? 
      B: s -- l
      : find-label
          L# begin dup while 1- 
            dup L[] .label bdup b@ str= if bdrop L[] exit then
          repeat bdrop ; )
    : find-marker // B: s -- l
          M# begin dup while 1- 
            dup M[] .marker bdup b@ str= if bdrop M[] exit then
          repeat bdrop ;
    : all-resolve
        L# begin ?dup while 1- dup
          dup L[] .label b@ find-marker ?dup if
            .pos @ over L[] label-resolve 
          else
            " cannot resolve marker '" dup L[] .marker b@ str+ +" '" error
          then
        repeat ;

    ' ! value 'dword-resolver
    ' nop ( TODO word!) value 'word-resolver
    ' nop ( TODO byte!) value 'byte-resolver
  \namespace

  LABELS
    samealias 'dword-resolver
    samealias 'word-resolver
    samealias 'byte-resolver
    samealias @>
    samealias @@
    samealias all-resolve
  ^
\namespace
