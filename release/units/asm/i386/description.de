// 2011.07.31 # Doj
// Команды для удобного описания ассемблерных команд (таблиц)

include" units\statements\switch.de"

I386 extend-namespace 
// {{{ COMMAND_DESCRIPTION
  namespace COMMAND_DESCRIPTION
    : 0op ( опкод) create , does> @ byte<< clear-operands ;
    : w-op ( опкод) create , does> @ byte<< first .value @ word<< clear-operands ;
    : r-op ( опкод) create , does> @ first .value @ + byte<< clear-operands ;

    // убер структура для описания одной разновидности команды
    0
      t_str -- .mnemonic
      t_ptr -- .opcode
      t_ptr -- .+r

      t_bool -- .ModR/M?
      t_ptr -- .mod
      t_ptr -- .reg
      t_ptr -- .r/m

      t_ptr -- .factor-xt
      t_ptr -- .base-xt
      t_ptr -- .index
      t_ptr -- .offset

      t_ptr -- .moffset#
      t_ptr -- .moffset

      t_int -- .imm#
      t_ptr -- .imm
    struct s_variant-description

    // хитрый хак :)
    enum8 '0 '1 '2 '3 '4 '5 '6 '7


    // убер команда, компилирующая по данным убер структуры
    : variant<< ( p)
      dup .opcode @ over .+r @ execute + byte<<
      dup .ModR/M? @ if
        dup .mod @ execute
        over dup .reg @ execute
        swap .r/m @ execute
        ModR/M byte<<
        dup .r/m @ execute ESP = if
          dup .factor-xt @ execute
          over dup .index @ execute
          swap .base-xt @ execute
          SIB byte<<
        then
      then
      dup dup .moffset @ execute swap .moffset# @ execute switch
        1 of byte<< \of
        2 of word<< \of
        4 of dword<< \of
        drop
      \switch
      dup dup .imm @ execute swap .imm# @ execute switch
        1 of byte<< \of
        2 of word<< \of
        4 of dword<< \of
        drop
      \switch
      drop
    ;

    variable *last-multi-mnemonic
    : last-multi-mnemonic *last-multi-mnemonic @ ;
    : variant create here *last-multi-mnemonic ! 
                     s_variant-description allot
                     last-multi-mnemonic .mnemonic off
                     // source-next-name last-multi-mnemonic .mnemonic b! 
                     // last-multi-mnemonic .
        last-multi-mnemonic .opcode !
        ['] '0 last-multi-mnemonic .+r !

        last-multi-mnemonic .ModR/M? off
        ['] '0 last-multi-mnemonic .mod !
        ['] '0 last-multi-mnemonic .reg !
        ['] '0 last-multi-mnemonic .r/m !

        ['] '0 last-multi-mnemonic .factor-xt !
        ['] '0 last-multi-mnemonic .base-xt !
        ['] '0 last-multi-mnemonic .index !

        ['] '0 last-multi-mnemonic .moffset# !
        ['] '0 last-multi-mnemonic .moffset !

        ['] '0 last-multi-mnemonic .imm# !
        ['] '0 last-multi-mnemonic .imm !
    does> variant<<
    ;

    // xt команды, которая кладёт значение параметра reg в ModR/M
    : /r ( x) last-multi-mnemonic .reg ! ;
    : /0 ['] '0 /r ;
    : /1 ['] '1 /r ;
    : /2 ['] '2 /r ;
    : /3 ['] '3 /r ;
    : /4 ['] '4 /r ;
    : /5 ['] '5 /r ;
    : /6 ['] '6 /r ;
    : /7 ['] '7 /r ;
 
    // +r
    : +r last-multi-mnemonic .+r ! ;
    // ModR/M
    : mod! last-multi-mnemonic .mod ! last-multi-mnemonic .ModR/M? on ;
    : reg! last-multi-mnemonic .reg ! last-multi-mnemonic .ModR/M? on ;
    : r/m! last-multi-mnemonic .r/m ! last-multi-mnemonic .ModR/M? on ;
    // imm
    : imm8! last-multi-mnemonic .imm ! ['] '1 last-multi-mnemonic .imm# ! ;
    : imm16! last-multi-mnemonic .imm ! ['] '2 last-multi-mnemonic .imm# ! ;
    : imm32! last-multi-mnemonic .imm ! ['] '4 last-multi-mnemonic .imm# ! ;
    // включение генерации moffset данных
    : moffset8 ['] '1 last-multi-mnemonic .moffset# ! last-multi-mnemonic .moffset ! ;
    : moffset16 ['] '2 last-multi-mnemonic .moffset# ! last-multi-mnemonic .moffset ! ;
    : moffset32 ['] '4 last-multi-mnemonic .moffset# ! last-multi-mnemonic .moffset ! ;

    : first.value first .value @ ;
    : second.value second .value @ ;
    : third.value third .value @ ;
    : first.disp first .disp @ ;
    : second.disp second .disp @ ;
    : third.disp third .disp @ ;

    // op reg reg/mem
    : second_reg_first_reg ['] '3 mod!  
                           ['] second.value reg! 
                           ['] first.value r/m! ;
    // op reg/mem reg
    : first_reg_second_reg ['] '3 mod!  
                           ['] first.value reg! 
                           ['] second.value r/m! ;
    // mod
    : disp->mod dup if drop Mod_MODE_SIMPLE 
                    else 256 < if Mod_MODE_8 else Mod_MODE_32 then then ;
    : first.mod first .disp @ disp->mod ; 
    : second.mod second .disp @ disp->mod ; 
    : third.mod third .disp @ disp->mod ; 

    : first-mem ['] first.mod mod! ;

    // 2 version
    : opmod ( opcode -- mod) .disp @ dup if 0 else 256 < if 1 else 2 then then ;
    : ebp-mod ( opcode -- mod) .disp @ 256 < if 1 else 2 then ;
    : disp-mod<< ( dm) dup if 1 = if byte<< else dword<< then else drop then ;
    : disp<< ( operand) dup opmod disp-mod<< ;
    : ebp-disp<< ( operand) dup ebp-mod disp-mod<< ;
    : op.SS ( operand -- SS) 
                   .factor @ switch 
                      1 of 0 \of 
                      2 of 1 \of 
                      4 of 2 \of
                      8 of 4 \of
                    \switch ;

    ( rp)
    variable *temp
    : [f*i+d]<< 0 lrot ESP ModR/M<< 
                dup dup op.SS swap dup .index @ swap .base @ SIB<<
                .disp @ dword<< ;
    : [ebp+f*i+d]<< tuck ebp-mod ESP ModR/M<< 
                    dup op.SS over .index @ EBP SIB<< ebp-disp<< ;
    : [b+f*i+d]<< tuck opmod swap ESP ModR/M<<
                  dup dup op.SS swap dup .index @ swap .base @ SIB<< disp<< ;
    : [d]<< swap 0 swap EBP ModR/M<< .disp @ dup . dword<< ;
    : [ebp+d]<< tuck ebp-mod swap EBP ModR/M<< ebp-disp<< ;
    : [esp+d]<< tuck opmod swap ESP ModR/M<< 0 ESP ESP SIB<< disp<< ;
    : [b+d]<< tuck opmod swap ( por) 3 pick .base @ ModR/M<< disp<< ;

    // r -- число от 0 до 7, которое будет записано в reg поле байта ModR/M
    // p -- операнд, код которого мы генерируем
    : mem<< ( rp)
      dup factor? if
        dup .index @ ESP = if
          " cannot use ESP as index in mov" error
        else
          dup .base @ switch
            -1 of [f*i+d]<< \of
            EBP of [ebp+f*i+d]<< \of
            [b+f*i+d]<<
          \switch
        then
      else
        dup .base @ dup . switch
          -1 of [d]<< \of
          EBP of [ebp+d]<< \of
          ESP of [esp+d]<< \of
          [b+d]<<
        \switch
      then
    ;
    
    0
      t_int -- v.opcode // опкод варианта
      t_int -- v.bits // 8, 16 или 32
      t_ptr -- v.+r // команда, возвращающая что нужно прибавлять к опкоду
      t_ptr -- v.mem // команда, возвращающая операнд, который записываем в mem составляющую
                     // 0 означает, что mem составляющей нет
      t_ptr -- v./r // команда, возвращающая что записывать в reg поле ModR/M
      t_int -- v.imm# // команда, возвращающая число байт в imm составляющей
                      // 0 означает, что imm нет
      t_ptr -- v.imm
    struct s_variant
   
    : newvariant<< ( variant)
        ." NOIMM" cr
      dup v.bits @ switch
        16 of 16 switch<< \of
        32 of 32 switch<< \of
      \switch
      dup v.opcode @ over v.+r @ execute + dup . byte<<
      dup v./r @ execute over v.mem @ execute mem<<
      dup v.imm# @ switch
        1 of dup v.imm @ execute .value @ byte<< \of
        2 of dup v.imm @ execute .value @ word<< \of
        4 of dup v.imm @ execute .value @ dword<< \of
      \switch
      drop ;
    :noname  0 ; value [']0
    : newvariant ( opcode bits) create swap , , [']0 dup , dup , dup , 0 , ,  
      does> newvariant<< ;
    : +r! last xt.param@ v.+r ! ;
    : mem! last xt.param@ v.mem ! ;
    : /r! last xt.param@ v./r ! ;
    : imm#! last xt.param@ v.imm# ! ;
    : imm! last xt.param@ v.imm ! ;
  \namespace
// }}}
\namespace
