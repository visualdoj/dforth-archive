// 2011.07.31 # Doj
// Команды для удобного описания ассемблерных команд (таблиц)

I386 extend-namespace 
// {{{ COMMAND_DESCRIPTION
  namespace COMMAND_DESCRIPTION
    : 0op ( опкод) create , does> @ byte<< clear-operands ;
    : w-op ( опкод) create , does> @ byte<< first .value @ word<< clear-operands ;
    : r-op ( опкод) create , does> @ first .value @ + byte<< clear-operands ;

    // убер структура для описания одной разновидности команды
    0
      t_str -- .mnemonic
      t_ptr -- .opcode
      t_ptr -- .+r

      t_bool -- .ModR/M?
      t_ptr -- .mod
      t_ptr -- .reg
      t_ptr -- .r/m

      t_ptr -- .factor
      t_ptr -- .base
      t_ptr -- .index
      t_ptr -- .offset

      t_ptr -- .moffset#
      t_ptr -- .moffset

      t_int -- .imm#
      t_ptr -- .imm
    struct s_variant-description

    // хитрый хак :)
    enum8 '0 '1 '2 '3 '4 '5 '6 '7

    // убер команда, компилирующая по данным убер структуры
    : variant<< ( p) cr
      dup .opcode @ over .+r @ execute + byte<<
      dup .ModR/M? @ if
        dup .mod @ execute
        over dup .reg @ execute
        swap .r/m @ execute
        ModR/M byte<<
        dup .r/m @ execute ESP = if
          dup .factor @ execute
          over dup .index @ execute
          swap .base @ execute
          SIB byte<<
        then
      then
      dup dup .moffset @ execute swap .moffset# @ execute switch
        1 of byte<< \of
        2 of word<< \of
        4 of dword<< \of
        drop
      \switch
      dup dup .imm @ execute swap .imm# @ execute switch
        1 of byte<< \of
        2 of word<< \of
        4 of dword<< \of
        drop
      \switch
      drop
    ;

    variable *last-multi-mnemonic
    : last-multi-mnemonic *last-multi-mnemonic @ ;
    : variant create here *last-multi-mnemonic ! 
                     s_variant-description allot
                     last-multi-mnemonic .mnemonic off
                     // source-next-name last-multi-mnemonic .mnemonic b! 
                     // last-multi-mnemonic .
        last-multi-mnemonic .opcode !
        ['] '0 last-multi-mnemonic .+r !

        last-multi-mnemonic .ModR/M? off
        ['] '0 last-multi-mnemonic .mod !
        ['] '0 last-multi-mnemonic .reg !
        ['] '0 last-multi-mnemonic .r/m !

        ['] '0 last-multi-mnemonic .factor !
        ['] '0 last-multi-mnemonic .base !
        ['] '0 last-multi-mnemonic .index !

        ['] '0 last-multi-mnemonic .moffset# !
        ['] '0 last-multi-mnemonic .moffset !

        ['] '0 last-multi-mnemonic .imm# !
        ['] '0 last-multi-mnemonic .imm !
    does> variant<<
    ;

    // xt команды, которая кладёт значение параметра reg в ModR/M
    : /r ( x) last-multi-mnemonic .reg ! ;
    : /0 ['] '0 /r ;
    : /1 ['] '1 /r ;
    : /2 ['] '2 /r ;
    : /3 ['] '3 /r ;
    : /4 ['] '4 /r ;
    : /5 ['] '5 /r ;
    : /6 ['] '6 /r ;
    : /7 ['] '7 /r ;
 
    // +r
    : +r last-multi-mnemonic .+r ! ;
    // ModR/M
    : mod! last-multi-mnemonic .mod ! last-multi-mnemonic .ModR/M? on ;
    : reg! last-multi-mnemonic .reg ! last-multi-mnemonic .ModR/M? on ;
    : r/m! last-multi-mnemonic .r/m ! last-multi-mnemonic .ModR/M? on ;
    // imm
    : imm8! last-multi-mnemonic .imm ! ['] '1 last-multi-mnemonic .imm# ! ;
    : imm16! last-multi-mnemonic .imm ! ['] '2 last-multi-mnemonic .imm# ! ;
    : imm32! last-multi-mnemonic .imm ! ['] '4 last-multi-mnemonic .imm# ! ;
    // включение генерации moffset данных
    : moffset8 ['] '1 last-multi-mnemonic .moffset# ! last-multi-mnemonic .moffset ! ;
    : moffset16 ['] '2 last-multi-mnemonic .moffset# ! last-multi-mnemonic .moffset ! ;
    : moffset32 ['] '4 last-multi-mnemonic .moffset# ! last-multi-mnemonic .moffset ! ;

    : first.value first .value @ ;
    : second.value second .value @ ;
    : third.value third .value @ ;
    : first.disp first .disp @ ;
    : second.disp second .disp @ ;
    : third.disp third .disp @ ;

    // op reg reg/mem
    : second_reg_first_reg ['] '3 mod!  
                           ['] second.value reg! 
                           ['] first.value r/m! ;
    // op reg/mem reg
    : first_reg_second_reg ['] '3 mod!  
                           ['] first.value reg! 
                           ['] second.value r/m! ;
    // mod
    : disp->mod dup if drop Mod_MODE_SIMPLE 
                    else 256 < if Mod_MODE_8 else Mod_MODE_32 then then ;
    : first.mod first .disp @ disp->mod ; 
    : second.mod second .disp @ disp->mod ; 
    : third.mod third .disp @ disp->mod ; 

    : first-mem ['] first.mod mod! ;
  \namespace
// }}}
\namespace
