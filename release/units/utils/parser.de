// 2011.02.02 # Doj
// Команды для обработки строк.

: str-right str# over - str-cut ;
RUS summary ( p B: s -- B: r) ( -s ^r) оставляет фрагмент s[p..s#-1]
: str-left 0 swap str-cut ;
RUS summary ( p B: s -- B: l) ( -s ^l) оставляет фрагмент s[0..p-1]
: str-leftright swap str-split str-right ;
RUS summary ( ps B: x -- B: lr) ( -x ^l ^r) разбивает строку на части l=x[0..p-1] r=x[p+s..x#-1]

: parse-binary? str^? if str# bdrop str-leftright true else drop false then ; 
RUS summary ( B: sb -- f B: lr) парсит строку вида s=lbr, f -- флаг успеха

: parse-list bswap ( bs) 
  begin bover parse-binary? while bswap dup bdyn+ repeat bdrop bdyn+ bdrop ;
RUS summary ( d B: sb - d ) разбивает строку s на части разделителем b
detail ( bdyn B: str sep -- bdyn)
  Разбивает строку str на части при помощи разделителя sep. Добавляет полученные
  строки в bdyn.

  Пример
    5 bdyn x // создали массив, в который мы сохраним строки
    x " a,b,,c,d" " ," parse-list // записали в массив пять строк
    0 x bdyn[]@ str. // a
    1 x bdyn[]@ str. // b
    2 x bdyn[]@ str. // пустая строка
    3 x bdyn[]@ str. // c
    4 x bdyn[]@ str. // d
\detail

: parse-trim 
  begin str^? swap 0 = and while str# bswap str-left bswap repeat 
  begin str# bover str-right str= bdrop while 
    str# bswap str# swap - str-left bswap
  repeat
  bdrop
;
RUS summary ( B: xs -- B: y) удаляет все вхождения s в x слева и справа
detail ( B: str1 sub -- B: str2) 
  1) Проверяет начинается ли строка str1 со строки sub.
     Если это так, то удаляет это вхождение из str1, и повторяет пункт 1.
  2) Проверяет заканчивается ли строка str2 строкой sub.
     Если это так, то удаляет это вхождение из str1, и повторяет пункт 2.
  
  Примеры. 
    Удаление пробелов по краям строки: str"  " str-trim
\detail

" expe" " rience" str+ // сложили две строки, получили experience
2 4 str-cut // оставили четыре символа, начиная со второго, получили peri (нумерация с нуля)
bdup str+ // сложили строку с самой собой, получили periperi
" rip" str^ // определяем символ, начиная с которого идёт первое вхождение rip в строке, получаем число 2
str# // узнали длину строки rip, т.е. 3
// Итого, на обычном стеке: 2 3
// На стеке строк: " periperi" " rip"
bdrop // скидывем строку rip со стека
str-del // удаляем три символа, начиная со второго, получаем peeri
utf8->unicode unicode->cp1251 // перекодировываем строку из utf8 в cp1251
" peeri" str= // проверяем равны ли строки, в данном случае получаем true
." Hello world!"cr // печатаем на консоль строку
