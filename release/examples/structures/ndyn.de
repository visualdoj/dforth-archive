// 2011.08.07 # Doj
// Пример использования динамических массивов структур

include" units\structures\ndyn.de"

// Описываем структуру с полями a, b, c, d
0
  t_int -- .a
  t_int -- .b
  t_int -- .c
  t_int -- .d
struct s_abcd

// Функция, печатающая значения полей структуры на консоль
: abcd. ( p-) dup .a @ . dup .b @ . dup .c @ . .d @ . ;

// Создаём динамический массив arr, состоящий из структур s_abcd
// Первый параметр (2) -- это capacity, предполагаемое число элементов
// Память под такое число элементов будет выделена изначально
// При этом никакие ограничения на использование массива это не накладывает
// (можно передать любое неотрицательное число)
2 s_abcd ndyn-global arr

// Получить число элементов в arr можно двумя способами:
//     arr ndyn#
//     arr#
// Сейчас число элементов равно 0
." arr# = " arr# . cr

// Увеличиваем число элементов в массиве на 1
// Сделать это можно двумя способами:
//    arr ndyn++
//    arr++
arr++
." arr# = " arr# . cr

// Получаем нулевой элемент. Опять два способа:
//     0 arr ndyn[]
//     0 arr[]
0 arr[]

// Записываем в полученную структуру значения 5 6 7 8
5 over .a !
6 over .b !
7 over .c !
8 over .d !
drop

// Печатаем нулевой элемент на консоль, убеждаемся, что это 5 6 7 8
." 0 arr[] = " 0 arr[] abcd. cr

// Увеличиваем число элементов на 1 и убеждаемся, 
// что нулевой элемент сохранил своё значение
arr++
." 0 arr[] = " 0 arr[] abcd. cr

// Записываем в первый элемент структуру 11 12 13 14
1 arr[]
11 over .a !
12 over .b !
13 over .c !
14 over .d !
drop

// Печатаем первые два элемента
." 0 arr[] = " 0 arr[] abcd. cr
." 1 arr[] = " 1 arr[] abcd. cr

// Ещё увеличиваем размер массива, превышаем установленное capacity
// Причём добавленный элемент будет нулевым, т.к. мы использовали операцию 0+
arr0+

// Печатаем первые три элемента
." 0 arr[] = " 0 arr[] abcd. cr
." 1 arr[] = " 1 arr[] abcd. cr
." 2 arr[] = " 2 arr[] abcd. cr

// Делаем массив размером 10
// Установить число элементов можно двумя способами:
//     count arr ndym#!
//     count arr#!
10 arr#!

// Печатаем первые два элемента
." 0 arr[] = " 0 arr[] abcd. cr
." 1 arr[] = " 1 arr[] abcd. cr

// Обращаемся к последнему элементу массива
//    arr ndyn[#]
//    arr[#]
// Это эквивалентно любому такому коду:
//    arr#1- arr[]
//    arr ndyn# 1- arr ndyn[]
arr[#]
71 over .a !
72 over .b !
73 over .c !
74 over .d !
drop

// Печатаем размер массива, его первые два и последний элементы
." arr# = " arr# . cr
." 0 arr[] = " 0 arr[] abcd. cr
." 1 arr[] = " 1 arr[] abcd. cr
." arr[#] = " arr[#] abcd. cr

// Освобождаем массив из памяти
0 arr#!
