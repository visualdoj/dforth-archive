include(`blogspot.m4')dnl

Речь пойдёт о моей эпопеи по написанию транслятора.

SUBHEADER(Что такое транслятор)

В этой статье под транслятором подразумевается нечто, что преобразует ассемблер из удобного для человеческого восприятия вида в машинный код.

SUBHEADER(Зачем мне нужен транслятор)

LIST
  ITEM(Чтобы написать компилятор. Потребуется реализовывать на ассемблере определённую часть ядра DEmbro.)
  ITEM(Вызов внешних функций. Просто так внешнюю функцию из языка выского уровня не вызвать, если информация об её соглашении вызова и типах параметров поступила во время выполнения, sTIRET нужно во время выполнения сгенерировать ассемблерный код, перекидывающий параметры на системный стек.)
  ITEM(Прочие случаи кодогенерации.)
  ITEM(Написание программ на ассемблере. Может быть когда-нибудь такая возможность потребуется.)
END

В каких-то частных случаях транслятор может быть даже и не нужен, функции и так легко описать. Вот, например, реализация нескольких простых функций в машинных кодах (Free Pascal):

{$APPTYPE CONSOLE}
type
  TFunc = function (A, B: Integer): Integer; register;
const
  Func_Add: Cardinal = $c3d001; // Result := A + B
  Func_Sub: Cardinal = $c3d029; // Result := A - B
  Func_Mul: Cardinal = $c3e2f7; // Result := A * B
  Func_Xor: Cardinal = $c3d031; // Result := A xor B
  Func_Lin: Cardinal = $c390048d; // Result := A + 4*B
begin
  Writeln('32 + 12 = ', TFunc(@Func_Add)(32, 12));
  Writeln('32 - 12 = ', TFunc(@Func_Sub)(32, 12));
  Writeln('32 * 12 = ', TFunc(@Func_Mul)(32, 12));
  Writeln('32 xor 12 = ', TFunc(@Func_Xor)(32, 12));
  Writeln('32 + 4*12 = ', TFunc(@Func_Lin)(32, 12));
end.

Меня же частные случаи не интересуют, моей задачей является написать достаточно универсальный и легко расширяемый транслятор.

SUBHEADER(Попытка первая, FreePascal+M4)

Я сразу же отказался (быть может, зря) от идеи в реальном времени парсить строки, содержащие ассемблерный код. Само по себе решение не очень красивое, да и усложнит генерацию ассемблерного кода на лету (например, если нам будет нужно вычислить к какому регистру применить определённую команду).

Я решил максимально используя синтаксические возможности паскаля написать такие функции, использование которых напоминало бы использование ассемблера. После нескольких ночей я реализовал какой-то небольшой комплект команд. Это было около полугода назад. Посмотреть на результат можно тут:

Крайне убого, громоздко, и неудобно. Но самая беда не в этом, а в устройстве машинного кода архитектуры i386, — оно крайне неинтуитивно связано с тем, как команды выглядят в ассемблере. Приведу несколько примеров.

Одной из самых суровых (и самых полезных) является команда MONO(mov). Вот скриншот из QUOTE(Intel 64 and IA-32 Architectures Software Developer's Manual):

IMG(...)

В этой таблице приведены разновидности команды MONO(mov), которые могут присутствовать в машинном коде. В самом левом столбце указано каким числом обозначается определённая разновидность и каким образом записывается один из операднов. Например, MONO(+rd) означает, что код регистра прибаляется к самому коду команды, а MONO(/r) sTIRET что регистр будет сохранён в дополнительном MONO(ModR/M) байте.

SUBHEADER(Попытка вторая, DEmbro)

SUBHEADER(Упрощённые регистры)

SUBHEADER(Префиксная запись команд)

SUBHEADER(Автоматические числа)

SUBHEADER(Директивы объявления данных)

SUBHEADER(Вынесение кода трансляции в команду)

SUBHEADER(Метки, переходы)

SUBHEADER(Перенаправление генерации в файл, hello world программа)

SUBHEADER(Связь команд из ассемблера с DEmbro)

SUBHEADER(Как всё устроено внутри)

SUBHEADER(Итоги, идеи дальнейшего развития)

SUBHEADER(Список ссылок и литературы)
