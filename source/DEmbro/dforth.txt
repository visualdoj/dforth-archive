= Идеология =

 # Маленький размер скомпилированного файла
 # Быстрая скорость выполнения
 # Дух классического форта
 # Чистота в именовании команд
 # Упор на практическое применение

== Стратегия развития ==

 * Версия 0.10 (сделано)
   # Работа со стеком
   # Типы int и bool
   # Создание собственных команд: обычных и immediate
   # Поддержка команд branch, ?branch, >mark, >resolve, <mark, <resolve и compile для реализации условных переходов и циклов
   # Три режима: интерпритация, компиляция в шитый код и исполнение
 * Версия 0.20
   # Возможность подключения внешних библиотек (dll)
   # Удобный механизм для создания прототипов вызываемых функций (поддержка cdecl, stdcall)
   # Создание callback команд для экспорта во внешний код
   # Поддержка простейших типов: целые числа, числа с плавающей точкой, указатели и pchar  
   # Работа с переменными 
   # Консоль: чтение данных
 * Версия 0.30
   # RTL: работа со временем
   # RTL: работа с файлами
   # Компилятор: поддержка отладочного режима: дампы шитого кода, стеков и переменных, контроль за операциями на стеке, отслеживание утечек памяти
   # Функционирование команд с локальной областью видимости
   # ...
 * Версия 0.40
   # Компиляция программы, использующей возможности версии 0.1, в исполняемый файл (exe)
   # Введение оптимизатора кода по размеру: отбрасывание ненужного RTL, упаковка вызовов частоиспользуемых команд в 1 или 2 байта
   # ...

= Синтаксис =

Программа представляет из себя последовательность команд, каждая команда отделена от других пробелами (пробелом считается символ от 0 до 32).

Для каждой команды форт-машина ищет исполнителя и передаёт ему выполнение.

== Комментарии ==

Комментарии являются обычными командами. Строковые комментарии должны начинаться с «//» и заканчиваются концом строки.
{{{
// это комментарий
}}}
Блочные комментарии начинаются с «(». После этого игнорируются все символы до «)». Например
{{{
( это 
       комментарий)
}}}

== Стековая нотация ==

Чтобы проще понимать что происходит со стеком при выполнении некоторых команд, применяется стековая нотация, имеющая следующий вид:
{{{
( состояние-стека-до -- состояние-стека-после )
}}}
Состояние стека записывается в виде последовательности символов, самый правый символ отвечает за вершину стека. Каждый символ должен представлять из себя либо название типа, либо условное название величины. Для простых команд последовательность символов не разделяется пробелом, вот пример нотации команды SWAP (обмен местами двух верхних чисел)
{{{
( ab -- ba )
}}}
В случае сложного выражения, символы следует разделять пробелами — пример для команды ROTN:
{{{
( a1 a2 a3 ... an n -- a2 a3 ... an a1 )
}}}
Некоторые команды могут что-то делать в режиме компиляции. В этом случае нужно записывать изменения на стеке дважды — для случая исполнения и для случая компиляции:
{{{
>resolve ( --   ) ( embroptr -- )
}}}
Некторые команды режима компиляции могут считывать из входного потока исходников символы. Для таких следует указывать что именно они считывают в двойных кавычках или фигурных скобках после описания входных параметров:
{{{
// xxx следует понимать как следующее слово
compile      ( "xxx"     --       ) компилирует команду xxx в шитый код, вне зависимости от её флага immediate
// ccc следует понимать как входные символы, вплоть до первой встретившийся "
pchar"       ( {ccc"}    -- pchar )
int-variable ( int "xxx" --       ) аналогично int-create, но сразу выделяет память под x и инициализирует значением со стека 
}}}
Для наглядности, в документации можно описывать в более удобном виде:
{{{
compile xxx       (     --       ) компилирует команду xxx в шитый код, вне зависимости от её флага immediate
pchar" ссс"       (     -- pchar )
int-variable xxx  ( int --       ) аналогично int-create, но сразу выделяет память под x и инициализирует значением со стека 
}}}
Первым способом я буду оформлять комментарии в коде, а последним — описывать команды в документации. 

= Исполнение =

Входящий поток, исходник, source — последовательность символов, представляющая из себя исходник.
Пробел — символ с кодом от 0 до 32.
Слово — последовательность символов исходника без пробелов, ограниченная пробелами с обеих сторон.
Embro, шитый код — готовый код для выполнения на виртуальной машине.

Есть три режима:
  # Интерпретация — входящий исходный код сразу выполняется (source -> действия)
  # Компиляция — входящий исходный код преобразуется в шитый код (source -> embro)
  # Выполнение — выполняется скомпилированный ранее шитый код (embro -> действия)

Каждое слово в зависимости от текущего режима выполняет некоторое действие.

Если не оговорено иное, то описание к командам следует понимать как описание её действия при интерпритации и выполнении, а при компиляции просто генерируется вызов её выполняющей части.

= Типы =

 # Машинно-зависимые:
   {{{
   int — целое число
   uint — целое число без знака
   ptr — указатель ( не релизован )
   extended - число с плавающей точкой с наибольшей возможной точностью
   }}}
 # Машинно-независимые:
   {{{
   int8 int16 int32 int64 
   uint8 uint16 uint32 uint64
   single - 32-битное число с плавающей точкой 
   double - 64-битное число с плавающей точкой
   }}}
 # Неарифметические типы:
   {{{
   bool — совпадает с int, считается ложным тогда и только тогда когда равно 0
   embro — относительный указатель внутри шитого кода ( частично работает )
   type - тип переменной
   lib - внешняя динамическая библиотека
   }}}
 # Строковые типы
   {{{
   pchar — строка с завершающим нулём
   str — обычная строка
   uni — юникодовая строка ( не релизован )
   }}}

= Команды =

== Базовые команды для работы со стеком ==

Многие команды обладают префиксом типа, с которым они работают. Ниже символ % следует понимать как тип.

{{{
%-push xxx (     -- xxx ) помещает константу xxx типа % в стек (реализовано для int, bool)
%-drop     ( %   --     ) удаляет с вершины стека переменную
%-dup      ( %   -- %%  ) дублирует верхнюю переменную на стеке
%-swap     ( ab  -- ba  ) меняет два верхних значения местами
%-over     ( ab  -- aba ) копирует предпоследний элемент стека на вершину
%-rot      ( abc -- bca ) меняет три верхних элемента местами
%-lrot     ( abc -- bca ) то же самое (ещё не реализовано)
%-rrot     ( abc -- cab ) меняет три верхних элемента местами в другом порядке
%-lrotn    ( a1 a2 ... an n -- a2 a3 ... an a1 ) прокручивание произвольного кол-ва элементов
%-rrotn    ( a1 a2 ... an n -- a2 a3 ... an a1 )
}}}

Для типа int можно записывать команды без префикса. Т.е., например, команда drop равносильна команде int-drop.
== Прямая работа с памятью, переменными и шитым кодом ==
Ниже под % подразумевается один из следующих типов: арифметический, bool, ptr.
=== Переменные ===
{{{
create xxx     (   -- ) создаёт новую команду с именем xxx. При выполнении xxx на стек будет класться указатель на её область данных
allot          ( i -- ) выделяет i байт области данных последней определённой команды
%,             ( % -- ) выделяет нужный размер под % и записывает в область данных значение со стека
%-to xxx       ( % -- ) перенести значение со стека в область данных команды xxx
%-variable xxx ( % -- ) аналогично create, но сразу выделяет память под x и инициализирует значением со стека 
%-value xxx    ( % -- ) аналогично create, но при выполнении xxx на стек будет класться не указатель на область данных, а значение типа % в области данных
%-constant xxx ( % -- ) в настоящий момент, аналогично value
}}}
Например, создать целочисленную переменную с начальным значением 3 можно вызовом
{{{
create x 3 int,
}}}
или, наглядней,
{{{
3 int-variable x
}}}
По умолчанию, при выполнении слова, созданного командой create, на вершину стека кладётся адрес (ptr) переменной. Таким образом, распечатать значение x можно так (см. работу с указателями):
{{{
x int@ .
}}}
Записать новое значение 5 можно так:
{{{
5 x int!
}}}
Можно определить переменную-указатель. В следующем коде переменная p является указателем на x или y и двойным разыменовыванием можно узнать значение:
{{{
create x 5 int,
create y 8 int,
create p nil ptr, // дефолтное значение — nil
x p ptr! // установили указатель на x
p ptr@ int@ . // распечатает 5
y p ptr! // установили указатель на y
p ptr@ int@ . // распечатает 8
}}}
В качестве альтернативы, можно использовать операторы to и value.
{{{
197 int-value x
x .
127 int-to x
x .
}}} 
=== ptr ===
{{{
%@ ( ptr   -- % ) кладёт в стек значение по адресу ptr (команда разыменовывания)
%! ( % ptr --   ) записывает значение % по адресу ptr
}}}
=== embro ===
Для embro-указателей работают все команды со стеком
== Метакоманды ==
{{{
compile  xxx  (     -- ) компилирует команду xxx в шитый код, вне зависимости от её флага immediate
evaluate      ( str -- ) интерпретирует код, находящийся в строке на стеке
evaluate-file ( str -- ) интерпретирует код, находящийся в файле, путь до которого указан в строке. Может использоваться для подключения библиотек
}}}
== Команды контроля выполнения ==
{{{
branch   (   -- ) совершает скачек на определённый адрес в коде. При этом адрес берётся из последующего после команды числа в шитом коде.
?branch  ( f -- ) если f ложно, то действует как branch, в противном случае переходит к следующей команде
>mark    (   -- ) ( -- embroptr ) при исполнении ничего не делает, при компиляции кладёт текущий адрес на стек и выделяет в шитом коде место под запись адреса
>resolve (   -- ) ( embroptr -- ) при исполнении ничего не делает, при компиляции извлекает со стека адрес в шитом коде и записывает по нему адрес текущего положения в шитом коде
<mark    (   -- ) ( -- embroptr ) при исполнении ничего не делает, при компиляции кладёт текущий адрес на стек
<resolve (   -- ) ( embroptr -- ) при исполнении ничего не делает, при компиляции извлекает со стека адрес в шитом коде и записывает его в шитый код
: xxx ( -- ) создаёт новое определение с именем xxx, переводит машину в режим компиляции
; завершает описание определения, переводит машину в режим интерпретации
immediate делает последнюю определённую команду командой немедленного исполнения
exit выйти из текущей функции, работает только внутри определения функции
recurse рекурсивно вызвать текущую функцию, работает только внутри определения функции
}}}
Этих команд достаточно, чтобы реализовать циклы и условные переходы. Внутри DForth подобные конструкции имеются, определены они следующим образом:
{{{
: if compile ?branch >mark ; immediate
: else compile branch >mark embro-swap >resolve ; immediate
: then >resolve ; immediate
: begin <mark ; immediate
: while compile ?branch >mark embro-swap ; immediate
: repeat compile branch <resolve >resolve ; immediate
: until compile ?branch <resolve ; immediate
}}}
Действия этих слов в режиме интерпретации не определены.
{{{
<flag> if ... [else ...] then
}}}
Снимает bool со стека, если оно true, то выполняет код сразу после if, в противном случае переходит к коду, который в else.
{{{
begin ... <flag> until
}}}
begin в режиме исполнения ничего не делает, until снимает bool со стека и если он равен false, то возвращается к begin
{{{
begin ... <flag> while ... repeat
}}}
begin в режиме исполнения ничего не делает, while снимает bool со стека, и если он равен false, то переходит к коду после repeat. repeat переходит к begin

Примеры использования:
{{{
: напечатать-числа-от-1-до-10 1 begin dup . 1 + dup 10 > until ;
: рекурсивный-факториал ( n -- n!) dup 2 < if drop 1 else dup 1 - recurse * then ;
}}}
== Арифметические команды (для арифметических типов) ==
Если не указывать тип, то считается, что команда выполняется для int.
{{{
%+  ( ab -- a+b  )
%-  ( ab -- a-b  )
%*  ( ab -- a*b  )
%=  ( ab -- a=b  ) проверяет два значения на равенство, кладёт на стек bool
%<> ( ab -- a=b  ) ... на неравенство ...
%<  ( ab -- a<b  ) ... на меньше ...
%>  ( ab -- a>b  ) ... на больше ...
%<= ( ab -- a<=b ) ... на меньше или равно ...
%>= ( ab -- a>=b ) ... на больше или равно ...
}}}
=== Для целых типов ===
{{{
%-div    ( ab -- a div b          ) вычисляет целую чаcть при делении a на b
%-mod    ( ab -- a mod b          ) вычисляет остаток при делении a на b
%-divmod ( ab -- a div b, a mod b )
%-inc    ( a  -- a+1              ) быстрое увеличение на единицу
%-dec    ( a  -- a-1              ) быстрое уменьшение на единицу
1+       ( a  -- a+1              ) эквивалентно int-inc
1-       ( a  -- a-1              ) эквивалентно int-dec
}}}
=== Для знаковых численных типов ===
{{{
%-abs    ( % -- |%| ) вычисляет модуль числа
%-neg    ( % -- -%  ) обращает знак числа
}}}
=== Для чисел с плавающей точкой ===
{{{
%/      ( ab -- a/b         ) делит одно число на другое
%-cos   ( a  -- cos(a)      )
%-sin   ( a  -- sin(a)      )
%-tan   ( a  -- tan(a)      ) 
%-atan  ( a  -- atan(a)     )
%-atan2 ( yx -- atan2(y, x) )
}}}
== Команды преобразований ==

Для преобразования из машинно-зависимых в машинно-независимые типы и обратно следует использовать следующие команды

{{{
int8->int int16->int int32->int
int->int8 int->int16 int->int32
uint8->uint uint16->uint uint32->uint
uint->uint8 uint->uint16 uint->uint32
single->double single->extended
double->single souble->extended
extended->single extended->double
}}}

При их выполнении возможна потеря разрядов.

== Булевы команды ==
{{{
false (     -- false   ) кладёт на стек ложь
true  (     -- true    ) кладёт на стек истину
not   ( b   -- not b   )
or    ( ab  -- a or b  )
and   ( ab  -- a and b )
xor   ( ab  -- a xor b )
}}}
== Операции над строками ==
Есть несколько разных типов строк.
=== pchar ===
C pchar можно работать так же, как и с указателем. Считается, что pchar ссылается на последовательность ascii-символов, завершающихся символом с кодом 0. Совместим с `char*` типом в C. При работе с pchar надо внимательно следить за тем, чтобы не было утечек памяти. Основное предназначение типа — взаимодействие с внешним кодом.

Изменение символов этой строки коснуться всех, кто на эту строку ссылается.

Для pchar есть все стековые команды (кроме `pchar-push`), `рchar.` для печати строки на консоль, а так же есть дополнительный набор команд
{{{
pchar" ссс"   ( -- pchar ) Создаёт строку типа pchar с символами ccc и кладёт указатель на неё на вершину стека. Эта строка константная, её освобождать не нужно.
}}}
{{{
pchar-alloc   ( n             -- pchar ) выделяет память на n полезных символов. (Т.е. выделится n+1 байт, один байт нужен под завершающий нуль.)
Ответственность за освобождение выделенной памяти лежит на пользователе.
pchar-free    ( pchar         --       ) освобождает память, выделенную при помощи pchar-alloc
pchar-len     ( pchar         -- n     ) кладёт длину строки
pchar-concat  ( pchar1 pchar2 -- pchar ) создаёт новую строку (так же как и pchar-alloc) и записывает в неё конкатенацию pchar1 и pchar2 (возможно, что эта команда будет пересмотрена). 
Ответственность за освобождение созданной строки лежит на пользователе.
pchar=        ( pchar1 pchar2 -- b     ) посимвольное сравнение строк
}}}
Вот так можно написать Hello world на строках с завершающим нулём:
{{{
pchar" Hello world!" pchar. cr
}}}
=== str ===
С типом str нельзя работать как с указателем — допустимо производить только операции начинающиеся с str-. 

Строка этого типа предназначена для использования внутри программы. Строки содержат счётчик кол-ва символов и счётчик ссылок. Это означает, что строка автоматически будет освобождена из памяти, как только на неё перестанут ссылаться. 

Изменение символов этой строки не изменит строку для всех прочих на неё ссылающихся.

Для строк этого типа работают все стековые операции, а так же:
{{{
str" ccc"  (           -- str       ) создаёт строку с символами ccc и помещает её на стек
str.       ( str       --           ) печатает строку на консоль
str=       ( str1 str2 -- str1=str2 ) проверяет совпадают ли строки между собой
str-nil    (           -- str-nil   ) кладёт нулевую строку на стек (0 символов)
str-concat ( str1 str2 -- str       ) конкатенация двух строк
str-len    ( str       -- int       ) кладёт длину строки
}}}
Программа Hello world на строках str:
{{{
str" Hello world!" str. cr
}}}
Вот несколько примеров, все они должны печатать TRUE
{{{
str" ab" str" cdef" str-concat str" abcd" str" ef" str-concat str= bool.
str-nil str" " str= bool.
}}}
== Работа с типами ==
{{{
typeof xxx (      -- type ) кладёт на стек тип, указанный в слове xxx
type-size  ( type -- i    ) кладёт на стек размер типа
t_%        (      -- %    ) то же, что и typeof %
}}}
Размер типа - это кол-во байт, которые он займёт при хранении на стеке.

Примеры работы с типами:
{{{
// каждая строка печатает размер определённого типа
typeof int type-size .
typeof int64 type-size .
t_ptr type-size .
t_type type-size .
}}}
== Работа с консолью ==
{{{
%.     ( %  --   ) выводит на консоль значение на вершине определённого типа и пробел после этого типа
%$     (    -- % ) ожидает пока пользователь введёт в консоли значение нужного типа, кладёт его на стек (пока что работает только для арифметических типов)
emit   ( i  --   ) берёт со стека целое число и выводит символ с кодом этого числа
space  (    --   ) печатает на консоль пробел
spaces ( n  --   ) печатает n пробелов
cr     (    --   ) переводит вывод на новую строку
}}}
== Взаимодействие с внешним кодом (в разработке) ==
Команды по работе с внешними библиотеками (с dll в частности)
{{{
lib-load   ( pchar     -- lib false | err true  ) загружает библиотеку, путь до которой прописан в pchar. 
Каждую созданную библиотеку нужно высвободить вызовом lib-unload.
Если при загрузке произошла ошибка, на вершине будет лежать true, а в err будет код ошибки.
Даже если загрузить не удалось, вызывать lib-unload всё равно необходимо.
lib-fun    ( pchar lib -- ptr ) возвращает адрес функции в библиотеке с именем lib. Если такой нет, вернёт nil. 
lib-unload ( lib       --     ) выгружает библиотеку из памяти, функции перестают быть доступными
}}}
{{{
alien-fun xxx ( -- sys void ) указывает на то, что дальше будет идти описание прототипа внешней функции
alien-end     ( sys void type1 type2 ... typen type-return conv -- ) создаёт определение с именем xxx
Среди typei не должно быть типа void. conv указывает на тип вызова, см. команды, начинающиеся на conv-.
После этого при вызове xxx будет производится обычный вызов функции:
  1) Указатель функции будет взять из данных команды. Обратите внимание на то, 
     что изначально там находится nil, поэтому нужно вручную выставить указатель на
     внешнюю функцию, например, оператором ptr-to.
  2) параметры type1, ..., typen будут сняты со стека и переданы в функцию
  3) после выполнения на стек будет положен type-return параметр
conv-stdcall  ( -- conv-stdcall ) поместить на стек идентификатор вызова stdcall 
conv-cdecl    ( -- conv-cdecl   ) поместить на стек идентификатор вызова cdecl
}}}
Две предыдущие команды предназначены для использования в следующем виде:
{{{
alien-fun xxx ... <return-type> <conv> alien-end
}}}
Пример:
{{{
alien-fun fun1 typeof ptr typeof ptr typeof int conv-stdcall alien-end
}}}
Этот код создаст команду fun1, которая при вызове считает из данных указатель на внешнюю функцию, считает со стека два параметра ptr, ptr, вызовет с этими параметрами внешнюю функцию и поместит на стек возвращаемое значение (типа int). Вызов будет произведён в соответствии с stdcall типом вызова.

= Пользовательское руководство =
Текущую версию программы можно скачать отсюда
http://igrodelica.googlecode.com/svn/trunk/source/DForth/dforth.exe

Для запуска программы в REPL режиме (интерактивная интерпретация в консоли) нужно запустить программу без параметров:
{{{
  dforth
}}}

(Ещё не готово) Для компиляции необходимо прописать параметр -c с названием компилируемого файла
{{{
  dforth -c <filename>
}}}

== Использование в качестве скриптового движка (временно в ауте) ==
Так же есть возможность подключения библиотеки dforth32.dll для вызова интерпретации и компиляции из программы на других языках. Список функций:
 # function dfCreateMachine: Pointer; stdcall; external 'dforth32.dll';
   Создаёт новую форт-машину, со своими стеками и определениями.
 # procedure dfFreeMachine(machine: Pointer); stdcall; external 'dforth32.dll';
   Уничтожает созданную ранее форт-машину.
 # procedure dfInterpret(machine: Pointer; code: PChar); stdcall; external 'dforth32.dll';
   Выполняет заданную программу на созданной ранее форт-машине. code должно быть ansi-строкой с завершающим нулём.
 # procedure dfSetUserData(machine: Pointer; userdata: Pointer); stdcall; external 'dforth32.dll';
   Устанавливает пользовательскую переменную. Внутри эта переменная не используется вообще никак. Может быть использована для хранения указателя на класс, у которого нужно вызывать коллбэки. По умолчанию userdata=nil.
 # function dfGetUserData(machine: Pointer): Pointer; stdcall; external 'dforth32.dll';
   Возвращает значение пользовательской переменной.
 # function dfAddCommand(machine: Pointer; name: PChar; callback: Pointer): Pointer; stdcall;
   Регистрирует новую команду с именем name. При её выполнении будет вызываться функция callback, которая обязана иметь следующий заголовок:
   {{{
   procedure (machine: Pointer); stdcall;
   }}}
