_file(
unit DForthMachine;

interface

uses
  {$I units.inc},

  Math,
  strings,
  DAlien,
  DVocabulary,
  DForthStack;

const
  DFORTHMACHINE_VERSION = 11;

dnl define(~_comma|, ~~,||)
define(~all_implement|, ~|)
define(~regist_all_commands|, ~|)
define(~all_create|, ~|)
define(~all_free|, ~|)
define(~cmdhdr|, ~(Machine: TForthMachine; Command: PForthCommand)|)
define(~WVar|, ~(Pointer(TUInt(WP) + ($1))^)|)
define(~LVar|, ~(Pointer(TUInt(LB) + ($1))^)|)
define(~WInc|, ~Inc(WP, $1)|)
define(~WDec|, ~Dec(TUInt(WP), $1)|)
define(~PSize|, ~(SizeOf(Pointer))|)
define(~CELL|, ~(SizeOf(Pointer))|)
define(~cinc|, ~ if PInteger($1)^ <> -1 then Inc(PInteger($1)^); |)
define(~cdec|, ~ if PInteger($1)^ > 0 then Dec(PInteger($1)^); |)
define(~genname|, ~ifelse($1, ~|, $2, len($1), ~1|, $2, $1-$2)|)
define(~body|, ~begin with Machine do begin $1 end; end;|)
define(~typed_commands|, 
  ~
    procedure drop_$1 cmdhdr;
    procedure dup_$1 cmdhdr;
    procedure nip_$1 cmdhdr;
    procedure swap_$1 cmdhdr;
    procedure over_$1 cmdhdr;
    procedure tuck_$1 cmdhdr;
    procedure lrot_$1 cmdhdr;
    procedure rrot_$1 cmdhdr;
    procedure lrotn_$1 cmdhdr;
    procedure rrotn_$1 cmdhdr;
    procedure pick_$1 cmdhdr;
    procedure _comma_$1 cmdhdr;
    procedure _dog_$1 cmdhdr;
    procedure _exclamation_$1 cmdhdr;
    procedure ptr_plus_$1 cmdhdr;
    procedure _to_$1 cmdhdr;
    procedure _compile_to_$1 cmdhdr;
    procedure _run_to_$1 cmdhdr;
    procedure _interpret_to_$1 cmdhdr;
    procedure _value_$1 cmdhdr;
    procedure _variable_$1 cmdhdr;
    procedure RunValue_$1 cmdhdr;
    procedure literal_$1 cmdhdr;
    procedure run_literal_$1 cmdhdr
  define(~all_implement|, all_implement 
    ~
     procedure drop_$1 cmdhdr; body(Dec(WP, $2))
     procedure dup_$1 cmdhdr; body(Move(WVar(-$2), WVar(0), $2); WInc($2))
     procedure nip_$1 cmdhdr; body(Move(WVar(-1*$2), WVar(-2*$2), $2); Dec(WP, $2))
     procedure swap_$1 cmdhdr; body(Move(WVar(-$2), WP^, $2); Move(WVar(-2*$2), WVar(-$2), $2); Move(WP^, WVar(-2*$2), $2);)
     procedure over_$1 cmdhdr; body(Move(WVar(-2*$2), WVar(0), $2); Inc(WP, $2))
     procedure tuck_$1 cmdhdr; body(Move(WVar(-2*$2), WVar(-1*$2), 2*$2); Move(WVar(0), WVar(-2*$2), $2); WInc($2);body)
     procedure lrot_$1 cmdhdr; 
     body(
       Move(WVar(-1*$2), WP^, $2);
       Move(WVar(-3*$2), WVar(-1*$2), $2);
       Move(WVar(-2*$2), WVar(-3*$2), $2);
       Move(WP^, WVar(-2*$2), $2);
     )
     procedure rrot_$1 cmdhdr;
     body( 
       Move(WVar(-1*$2), WP^, $2);
       Move(WVar(-2*$2), WVar(-1*$2), $2);
       Move(WVar(-3*$2), WVar(-2*$2), $2);
       Move(WP^, WVar(-3*$2), $2);
     )
     procedure lrotn_$1 cmdhdr; 
     var
       N: Integer;
     body( 
       Dec(WP, SizeOf(TInt));
       N := TInt(WP^);
       Move(WVar(-$2*N), WVar(0), $2);
       while N > 0 do begin
         Move(WVar(-$2*(N-1)), WVar(-$2*N), $2);
         Dec(N);
       end;
       //Move(WVar(0), WVar(-$2), $2);
     )
     procedure rrotn_$1 cmdhdr;
     var
       I: Integer;
       N: Integer;
     body(
       Dec(WP, SizeOf(TInt));
       N := TInt(WP^);
       //Move(WVar(-$2), WVar(0), $2);
       for I := 0 to N - 1 do
         Move(WVar(-$2*(I+1)), WVar(-$2*I), $2);
       Move(WVar(0), WVar(-N*$2), $2);
     )
     procedure pick_$1 cmdhdr; 
     body( 
       Move(WVar(-SizeOf(TInt) -$2*TInt(WVar(-SizeOf(TInt)))), 
            WVar(-SizeOf(TInt)),
            $2);
       WInc($2 - SizeOf(TInt));
     )
     procedure _comma_$1 cmdhdr; body( Dec(WP, $2); Move(WP^, Here^, $2); EA($2); )
     procedure _dog_$1 cmdhdr; body( Move(Pointer(WVar(-PSize))^, WVar(-PSize), $2); Inc(WP, $2 - PSize) )
     procedure _exclamation_$1 cmdhdr; body( Move(WVar(-PSize-$2), Pointer(WVar(-PSize))^, $2); Dec(WP, PSize + $2) )
     procedure ptr_plus_$1 cmdhdr; body( PtrInt(WVar(-SizeOf(Pointer))) := PtrInt(WVar(-SizeOf(Pointer))) + $2; )
     procedure _to_$1 cmdhdr; body( if FState <> FS_INTERPRET then _compile_to_$1(Machine, Command) else _interpret_to_$1(Machine, Command); )
     procedure _compile_to_$1 cmdhdr; body( EWO('run@genname($1, ~to|)'); EWO(NextName); )
     procedure _run_to_$1 cmdhdr; var O: TOpcode; body( O := ERO; Move(WVar(-$2), C[O].Data^, $2); Dec(WP, $2); )
     procedure _interpret_to_$1 cmdhdr; var N: TString; Comm: PForthCommand; body( N := NextName; Comm := FindCommand(N);
               if Comm = nil then begin LogError('unkown name after genname($1, ~to|): ' + N); FSession := False; Exit; end; 
               Move(WVar(-$2), Comm.Data^, $2); Dec(WP, $2);
             )
     procedure _value_$1 cmdhdr; body( with ReserveName(SNN)^ do begin Data := Here; Code := RunValue_$1; Move(WVar(-$2), Here^, $2); Dec(WP, $2); EA($2); Flags := Flags and not 1; end; )
     procedure _variable_$1 cmdhdr; body( with ReserveName(SNN)^ do begin Data := Here; Code := PutDataPtr; {Dec(WP, $2); Move(WP^, Here^, $2);} EA($2); end; )
     procedure RunValue_$1 cmdhdr; body( Move(Command.Data^, WP^, $2); Inc(WP, $2); )
    procedure literal_$1 cmdhdr; body( EWO('genname($1, (literal))'); Dec(WP, $2); EWV(WP, $2); )
    procedure run_literal_$1 cmdhdr; body( ERV(WP, $2); Inc(WP, $2); )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     AddCommand('genname($1, drop)', drop_$1);
     AddCommand('genname($1, dup)', dup_$1);
     AddCommand('genname($1, nip)', nip_$1);
     AddCommand('genname($1, swap)', swap_$1);
     AddCommand('genname($1, over)', over_$1);
     AddCommand('genname($1, tuck)', tuck_$1);
     AddCommand('genname($1, lrot)', lrot_$1);
     AddCommand('genname($1, rrot)', rrot_$1);
     AddCommand('genname($1, lrotn)', lrotn_$1);
     AddCommand('genname($1, rrotn)', rrotn_$1);
     AddCommand('genname($1, pick)', pick_$1);
     AddCommand('$1,', _comma_$1);
     AddCommand('$1@', _dog_$1);
     AddCommand('$1!', _exclamation_$1);
     AddCommand('ptr+$1', ptr_plus_$1);
     AddCommand('genname($1, to)', _to_$1, True);
     AddCommand('compile@genname($1, to)', _compile_to_$1);
     AddCommand('run@genname($1, to)', _run_to_$1);
     AddCommand('interpret@genname($1, to)', _interpret_to_$1);
     AddCommand('genname($1, value)', _value_$1);
     AddCommand('genname($1, constant)', _value_$1);
     AddCommand('genname($1, variable)', _variable_$1);
     AddCommand('genname($1, literal)', literal_$1, True);
     AddCommand('genname($1, (literal))', run_literal_$1);
    |)
|)
define(~counter_commands|, 
  ~
    procedure cdrop cmdhdr;
    procedure cdup cmdhdr;
    procedure cnip cmdhdr;
    procedure cswap cmdhdr;
    procedure cover cmdhdr;
    procedure ctuck cmdhdr;
    procedure clrot cmdhdr;
    procedure crrot cmdhdr;
    procedure clrotn cmdhdr;
    procedure crrotn cmdhdr;
    procedure cpick cmdhdr;
    procedure _ccomma cmdhdr;
    procedure _cdog cmdhdr;
    procedure _cexclamation cmdhdr;
    procedure ptr_plus_c$1 cmdhdr;
    procedure _cto cmdhdr;
    procedure _compile_cto cmdhdr;
    procedure _run_cto cmdhdr;
    procedure _interpret_cto cmdhdr;
    procedure _cvalue cmdhdr;
    procedure _cvariable cmdhdr;
    procedure RuncValue cmdhdr;
    procedure cliteral cmdhdr;
    procedure run_cliteral cmdhdr
  define(~all_implement|, all_implement 
    ~
      procedure cdrop cmdhdr; body( Dec(WP, CELL); cdec(Pointer(WP^)); )
     procedure cdup cmdhdr; body( Pointer(WP^) := WVar(-$2); cinc(Pointer(WP^)); WInc(CELL); )
     procedure cnip cmdhdr; body( Dec(WP, CELL); cdec(WVar(-CELL)); WVar(-CELL) := Pointer(WP^); )
     procedure swap cmdhdr; body( Move(WVar(-$2), WP^, $2); Move(WVar(-2*$2), WVar(-$2), $2); Move(WP^, WVar(-2*$2), $2); )
     procedure over cmdhdr; body( Move(WVar(-2*$2), WVar(0), $2); Inc(WP, $2) )
     procedure tuck cmdhdr; body( Move(WVar(-2*$2), WVar(-1*$2), 2*$2); Move(WVar(0), WVar(-2*$2), $2); WInc($2); )
     procedure lrot cmdhdr; 
     body( 
       Move(WVar(-1*$2), WP^, $2);
       Move(WVar(-3*$2), WVar(-1*$2), $2);
       Move(WVar(-2*$2), WVar(-3*$2), $2);
       Move(WP^, WVar(-2*$2), $2);
     )
     procedure rrot cmdhdr;
     body( 
       Move(WVar(-1*$2), WP^, $2);
       Move(WVar(-2*$2), WVar(-1*$2), $2);
       Move(WVar(-3*$2), WVar(-2*$2), $2);
       Move(WP^, WVar(-3*$2), $2);
     )
     procedure lrotn cmdhdr; 
     var
       N: Integer;
     body( 
       Dec(WP, SizeOf(TInt));
       N := TInt(WP^);
       Move(WVar(-$2*N), WVar(0), $2);
       while N > 0 do begin
         Move(WVar(-$2*(N-1)), WVar(-$2*N), $2);
         Dec(N);
       end;
       //Move(WVar(0), WVar(-$2), $2);
     )
     procedure rrotn cmdhdr;
     var
       I: Integer;
       N: Integer;
     body(
       Dec(WP, SizeOf(TInt));
       N := TInt(WP^);
       //Move(WVar(-$2), WVar(0), $2);
       for I := 0 to N - 1 do
         Move(WVar(-$2*(I+1)), WVar(-$2*I), $2);
       Move(WVar(0), WVar(-N*$2), $2);
     )
     procedure pick cmdhdr; 
     body( 
       Move(WVar(-SizeOf(TInt) -$2*TInt(WVar(-SizeOf(TInt)))), 
            WVar(-SizeOf(TInt)),
            $2);
       WInc($2 - SizeOf(TInt));
     )
     procedure _comma cmdhdr; body( Dec(WP, $2); Move(WP^, Here^, $2); EA($2); )
     procedure _dog cmdhdr; body( Move(Pointer(WVar(-PSize))^, WVar(-PSize), $2); Inc(WP, $2 - PSize) )
     procedure _exclamation cmdhdr; body( Move(WVar(-PSize-$2), Pointer(WVar(-PSize))^, $2); Dec(WP, PSize + $2) )
     procedure ptr_plus cmdhdr; body( PtrInt(WVar(-SizeOf(Pointer))) := PtrInt(WVar(-SizeOf(Pointer))) + $2; )
     procedure _to cmdhdr; body( if FState <> FS_INTERPRET then _compile_to(Machine, Command) else _interpret_to(Machine, Command); )
     procedure _compile_to cmdhdr; body( EWO('run@genname($1, ~to|)'); EWO(NextName); )
     procedure _run_to cmdhdr; var O: TOpcode; body( O := ERO; Move(WVar(-$2), C[O].Data^, $2); Dec(WP, $2); )
     procedure _interpret_to cmdhdr; var N: TString; C: PForthCommand; body( N := NextName; C := FindCommand(N);
               if C = nil then begin LogError('unkown name after genname($1, ~to|): ' + N); FSession := False; Exit; end; 
               Move(WVar(-$2), C.Data^, $2); Dec(WP, $2);
             )
     procedure _value cmdhdr; body( with ReserveName(SNN)^ do begin Data := Here; Code := RunValue; Move(WVar(-$2), Here^, $2); Dec(WP, $2); EA($2); Flags := Flags and not 1; end; )
     procedure _variable cmdhdr; body( with ReserveName(SNN)^ do begin Data := Here; Code := PutDataPtr; {Dec(WP, $2); Move(WP^, Here^, $2);} EA($2); end; )
     procedure RunValue cmdhdr; body( Move(Command.Data^, WP^, $2); Inc(WP, $2); end;
    procedure literal cmdhdr; body( EWO('genname($1, (literal))'); Dec(WP, $2); EWV(WP, $2); )
    procedure run_literal cmdhdr; body( ERV(WP, $2); Inc(WP, $2); )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     (* AddCommand('cdrop',        drop); *)
     (* AddCommand('cdup',         dup); *)
     (* AddCommand('cnip',         nip); *)
     (* AddCommand('cswap',        swap); *)
     (* AddCommand('cover',        over); *)
     (* AddCommand('ctuck',        tuck); *)
     (* AddCommand('clrot',        lrot); *)
     (* AddCommand('crrot',        rrot); *)
     (* AddCommand('clrotn',       lrotn); *)
     (* AddCommand('crrotn',       rrotn); *)
     (* AddCommand('cpick',        pick); *)
     (* AddCommand('c,',           _comma); *)
     (* AddCommand('c@',           _dog); *)
     (* AddCommand('c!',           _exclamation); *)
     (* AddCommand('ptr+c',        ptr_plus); *)
     (* AddCommand('cto',          _cto, True); *)
     (* AddCommand('[cto]',        _compile_cto); *)
     (* AddCommand('(cto)',        _run_cto); *)
     (* AddCommand('_cto_',        _interpret_cto); *)
     (* AddCommand('cvalue',       _cvalue); *)
     (* AddCommand('cconstant',    _cvalue); *)
     (* AddCommand('cvariable',    _cvariable); *)
     (* AddCommand('cliteral',     cliteral, True); *)
     (* AddCommand('(cliteral)',  run_cliteral); *)
    |)
|)
define(~data_commands|, 
  ~
  procedure $1_to cmdhdr;
  procedure interprete_$1_to cmdhdr;
  procedure compile_$1_to cmdhdr;
  procedure run_$1_to cmdhdr
  define(~all_implement|, all_implement 
    ~
     procedure $1_to cmdhdr; body( if Machine.State = FS_COMPILE then compile_$1_to(Machine, Command) else interpete_$1_to(Machine, Command) )
     procedure interprete_$1_to cmdhdr; body(  )
     procedure compile_$1_to cmdhdr; body(  )
     procedure run_$1_to cmdhdr; body(  )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
    |)
|)
define(~exception_commands|, 
  ~
  procedure _sys_exceptions_execute cmdhdr;
  procedure _sys_exceptions_pop cmdhdr;
  procedure _throw cmdhdr;
  define(~all_create|, all_create
    ExceptionsS := 1024;
    SetLength(Exceptions, ExceptionsS);
    ExceptionsB := @Exceptions[0];
    ExceptionsP := @Exceptions[0]
  )
  define(~all_implement|, all_implement 
    ~
     procedure _sys_exceptions_execute cmdhdr;
     var
       Res: Integer;
     body( 
       Integer(ExceptionsP^) := 0;
       Inc(ExceptionsP, SizeOf(Integer));
       Integer(ExceptionsP^) := EC;
       Inc(ExceptionsP, SizeOf(Integer));
       Pointer(ExceptionsP^) := WP;
       Inc(ExceptionsP, SizeOf(Pointer));
       Pointer(ExceptionsP^) := RP;
       Inc(ExceptionsP, SizeOf(Pointer));
       execute(Machine, Command);
     )
     procedure _sys_exceptions_pop cmdhdr;
     body(
       Dec(ExceptionsP, 2*SizeOf(Integer) + 2*SizeOf(Pointer));
       WUI(Integer(ExceptionsP^));
     )
     procedure _throw cmdhdr; 
     body( 
       Integer((@PArrayOfByte(ExceptionsP)^[-2*SizeOf(Pointer)-2*SizeOf(Integer)])^) := WOI;
       EC := Integer((@PArrayOfByte(ExceptionsP)^[-2*SizeOf(Pointer)-SizeOf(Integer)])^);
       RP := Pointer((@PArrayOfByte(ExceptionsP)^[-1*SizeOf(Pointer)])^);
       WP := Pointer((@PArrayOfByte(ExceptionsP)^[-2*SizeOf(Pointer)])^);
     )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
      AddCommand('sys-exceptions-execute', _sys_exceptions_execute);
      AddCommand('sys-exceptions-pop', _sys_exceptions_pop);
      AddCommand('throw', _throw);
    |)
|)
define(~long_commands|, 
  ~
     procedure LongAlloc(var L: PLong; Len: Integer);
     procedure LongIncRef(L: PLong);
     procedure LongDecRef(L: PLong);
     procedure WULong(L: PLong);
     function WOLong: PLong;
     procedure long_add cmdhdr;
     procedure long_sub cmdhdr;
     procedure long_inc cmdhdr;
     procedure long_dec cmdhdr;
     procedure long_mul cmdhdr; 
     procedure long_div cmdhdr;
     procedure long_mod cmdhdr;
     procedure long_divmod cmdhdr;
     procedure int_to_long cmdhdr;
     procedure long_to_int cmdhdr;
  define(~all_implement|, all_implement 
    ~
       function AddWithCarryAndUpdate(
         A, B: Integer; 
         var Carry: Integer): Integer; register; inline;
       asm
         mov Result, 0
         add Result, A
         add Result, B
         add Result, Carry
         jc @@setcarry
         mov Carry, 0
         jmp @@end
       @@setcarry:
         mov Carry, 1
       @@end:
       )
       procedure LongAlloc(var L: PLong; Len: Integer);
       body(
         GetMem(L, SizeOf(Integer) * (4 + Len));
         L^.Ref := 0;
         L^.Flags := 0;
         L^.Len := 0;
         L^.Max := Len;
       )
       procedure LongIncRef(L: PLong);
       body(
         if L^.Ref > 0 then 
           Inc(L^.Ref);
       )
       procedure LongDecRef(L: PLong);
       body(
         if L^.Ref > 0 then 
           Dec(L^.Ref);
         if L^.Ref = 0 then
           FreeMem(L);
       )
       procedure WULong(L: PLong);
       body(
         LongIncRef(L);
       )
       function TForthMachine.WOLong: PLong;
       body(
         Result := PLong(WP^);
         Dec(WP, SizeOf(PLong));
       )
       procedure long_add cmdhdr;
       var
         A, B, C: PLong;
         I, Carry: Integer;
       body(
         B := WOLong;
         A := WOLong;
         LongAlloc(C, Max(A^.Len, B^.Len) + 1);
         Carry := 0;
         for I := 0 to Min(A^.Len, B^.Len) - 1 do begin
           C^.V[I] := A^.V[I] + B^.V[I] + Carry;
           Carry := 0;
         end;
       )
       procedure long_sub cmdhdr;
       body(
       )
       procedure long_inc cmdhdr;
       body(
       )
       procedure long_dec cmdhdr;
       body(
       )
       procedure long_mul cmdhdr; 
       body(
       )
       procedure long_div cmdhdr;
       body(
       )
       procedure long_mod cmdhdr;
       body(
       )
       procedure long_divmod cmdhdr;
       body(
       )
       procedure int_to_long cmdhdr;
       body(
       )
       procedure long_to_int cmdhdr;
       body(
       )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
    |)
|)
define(~arithmetic_commands|, 
  ~
  procedure $1_plus cmdhdr;
  procedure $1_minus cmdhdr;
  procedure $1_star cmdhdr;
  procedure $1_equel cmdhdr;
  procedure $1_nequel cmdhdr;
  procedure $1_lt cmdhdr;
  procedure $1_gt cmdhdr;
  procedure $1_lte cmdhdr;
  procedure $1_gte cmdhdr;  
  procedure $1_0_equel cmdhdr;
  procedure $1_0_nequel cmdhdr;
  procedure $1_0_lt cmdhdr;
  procedure $1_0_gt cmdhdr;
  procedure $1_0_lte cmdhdr;
  procedure $1_0_gte cmdhdr;
  procedure $1_ask_dup cmdhdr;
  procedure $1_0_exit cmdhdr;
  procedure $1_max cmdhdr;
  procedure $1_min cmdhdr;
  procedure $1_minmax cmdhdr;
  procedure $1_dot cmdhdr;
  procedure $1_dollar cmdhdr;
  procedure $1_ptr_plus_exclamation cmdhdr;
  procedure $1_conv_to_str cmdhdr;
  procedure $1_conv_from_str cmdhdr
  define(~all_implement|, all_implement 
    ~
      procedure $1_plus  cmdhdr; body( $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) + $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); )
      procedure $1_minus cmdhdr; body( $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) - $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); )
      procedure $1_star  cmdhdr; body( $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) * $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); )
      procedure $1_equel cmdhdr; body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) = $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_nequel cmdhdr; body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) <> $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_lt cmdhdr;    body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) < $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_gt cmdhdr;    body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) > $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_lte cmdhdr;   body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) <= $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_gte cmdhdr;   body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) >= $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_0_equel cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) = 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_0_nequel cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) <> 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_0_lt cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) < 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_0_gt cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) > 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_0_lte cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) <= 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_0_gte cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) >= 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_ask_dup cmdhdr; body( if ($2(WVar(-1*SizeOf($2)))) <> 0 then begin $2(WP^) := $2(WVar(-1*SizeOf($2))); Inc(WP, SizeOf($2)); end; )
      procedure $1_0_exit cmdhdr; body( if $2(WVar(-SizeOf($2))) = 0 then begin Dec(WP, SizeOf($2)); _exit(Machine, Command); end )
      procedure $1_max cmdhdr;
      body(
        if $2(WVar(-2*SizeOf($2))) < $2(WVar(-1*SizeOf($2))) then
          Move(WVar(-1*SizeOf($2)), WVar(-2*SizeOf($2)), SizeOf($2));
        Dec(WP, SizeOf($2));
      )
      procedure $1_min cmdhdr;
      body(
        if $2(WVar(-2*SizeOf($2))) > $2(WVar(-1*SizeOf($2))) then
          Move(WVar(-1*SizeOf($2)), WVar(-2*SizeOf($2)), SizeOf($2));
        Dec(WP, SizeOf($2));
      )
      procedure $1_minmax cmdhdr;
      body(
        if $2(WVar(-2*SizeOf($2))) > $2(WVar(-1*SizeOf($2))) then begin
          Move(WVar(-2*SizeOf($2)), WVar(-0*SizeOf($2)), SizeOf($2));
          Move(WVar(-1*SizeOf($2)), WVar(-2*SizeOf($2)), SizeOf($2));
          Move(WVar(-0*SizeOf($2)), WVar(-1*SizeOf($2)), SizeOf($2));
        end;
      )
      procedure $1_dot cmdhdr;    body( Dec(WP, SizeOf($2)); Write($2(WP^), ' '); )
      procedure $1_dollar cmdhdr; var Temp: $2; body( Read(Temp); Move(Temp, WP^, SizeOf($2)); Inc(WP, SizeOf($2)); )
      procedure $1_ptr_plus_exclamation cmdhdr; body( $2(Pointer(WVar(-SizeOf(Pointer)))^) := $2(Pointer(WVar(-SizeOf(Pointer)))^) + $2(WVar(-SizeOf(Pointer)-SizeOf($2))); Dec(WP, SizeOf(Pointer) + SizeOf($2)); )
      procedure $1_conv_to_str cmdhdr;
      var
        B: TString;
      body(
        Str($2(WVar(-SizeOf($2))), B);
        Dec(WP, SizeOf($2));
        str_push(Machine, Command, B);
      )
      procedure $1_conv_from_str cmdhdr;
      var
        B: TStr;
        Res: Word;
      body(
        B := str_pop(Machine, Command);
        Val(PChar(@(TStrRec(B^).Sym[0])), $2(WP^), Res);
        Inc(WP, SizeOf($2));
        DelRef(B);
      )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     AddCommand('$1+', $1_plus);
     AddCommand('$1-', $1_minus);
     AddCommand('$1*', $1_star);
     AddCommand('$1=', $1_equel);
     AddCommand('$1<>', $1_nequel);
     AddCommand('$1<', $1_lt);
     AddCommand('$1>', $1_gt);
     AddCommand('$1<=', $1_lte);
     AddCommand('$1>=', $1_gte);
     AddCommand('genname($1, 0=)', $1_0_equel);
     AddCommand('genname($1, 0<>)', $1_0_nequel);
     AddCommand('genname($1, 0<)', $1_0_lt);
     AddCommand('genname($1, 0>)', $1_0_gt);
     AddCommand('genname($1, 0<=)', $1_0_lte);
     AddCommand('genname($1, 0>=)', $1_0_gte);
     AddCommand('genname($1, ?dup)', $1_ask_dup);
     AddCommand('genname($1, 0;)', $1_0_exit);
     AddCommand('genname($1, min)', $1_min);
     AddCommand('genname($1, max)', $1_max);
     AddCommand('genname($1, minmax)', $1_minmax);
     AddCommand('$1.', $1_dot);
     AddCommand('$1$', $1_dollar);
     AddCommand('$1+!', $1_ptr_plus_exclamation);
     AddCommand('$1->str', $1_conv_to_str);
     AddCommand('str->$1', $1_conv_from_str);
    |)
|)
define(~signed_arithmetic_commands|, 
  ~
  procedure $1_abs cmdhdr;
  procedure $1_neg cmdhdr
  define(~all_implement|, all_implement 
    ~procedure $1_abs cmdhdr; body( $2(WVar(-SizeOf($2))) := Abs($2(WVar(-SizeOf($2)))); )
     procedure $1_neg cmdhdr; body( $2(WVar(-SizeOf($2))) := - $2(WVar(-SizeOf($2))); )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~AddCommand('genname($1, abs)', $1_abs);
     AddCommand('genname($1, neg)', $1_neg);
    |)
|)
define(~number_arithmetic_commands|, 
  ~
  procedure $1_push  cmdhdr;
  procedure $1_interpret_push  cmdhdr;
  procedure $1_compile_push  cmdhdr;
  procedure $1_run_push  cmdhdr;
  procedure $1_1_plus cmdhdr;
  procedure $1_1_minus cmdhdr;
  procedure $1_div cmdhdr;
  procedure $1_mod cmdhdr;
  procedure $1_divmod cmdhdr;
  procedure $1_ptr_inc cmdhdr;
  procedure $1_ptr_dec cmdhdr
  define(~all_implement|, all_implement 
    ~
     procedure $1_push  cmdhdr; body( if FState = FS_COMPILE then $1_compile_push(Machine, Command) else $1_interpret_push(Machine, Command) )
     procedure $1_interpret_push  cmdhdr; body( $2(WP^) := $2(StrToInt(NextName)); Inc(WP, SizeOf($2)); )
     procedure $1_compile_push  cmdhdr; body( EWO('run@$1-push'); EW_$1(StrToInt(NextName)); )
     procedure $1_run_push  cmdhdr; body( $2(WP^) := ER_$1; Inc(WP, SizeOf($2)); )
     procedure $1_1_plus cmdhdr;  body( Inc($2(WVar(-SizeOf($2)))) )
     procedure $1_1_minus cmdhdr; body( Dec($2(WVar(-SizeOf($2)))) )
     procedure $1_div cmdhdr; body( $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) div $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); )
     procedure $1_mod cmdhdr; body( $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) mod $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); )
     procedure $1_divmod cmdhdr; body( $2(WVar(0)) := $2(WVar(-2*SizeOf($2))) mod $2(WVar(-SizeOf($2))); 
                                                     $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) div $2(WVar(-SizeOf($2)));
                                                     $2(WVar(-  SizeOf($2))) := $2(WVar(0)); 
                                               )
     procedure $1_ptr_inc cmdhdr;
     body(
       $2(Pointer(WVar(-SizeOf(Pointer)))^) := 
                         $2(Pointer(WVar(-SizeOf(Pointer)))^) + 1; 
       Dec(WP, SizeOf(Pointer));
     )
     procedure $1_ptr_dec cmdhdr;
     body(
       $2(Pointer(WVar(-SizeOf(Pointer)))^) := 
                         $2(Pointer(WVar(-SizeOf(Pointer)))^) - 1; 
       Dec(WP, SizeOf(Pointer));
     )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     AddCommand('$1-push', $1_push, True);
     AddCommand('run@$1-push', $1_run_push);
     AddCommand('genname($1, inc)', $1_1_plus);
     AddCommand('genname($1, dec)', $1_1_minus);
     ifelse($1, ~|, AddCommand('1+', $1_1_plus);)
     ifelse($1, ~|, AddCommand('1-', $1_1_minus);)
     AddCommand('genname($1, inc!)', $1_ptr_inc);
     AddCommand('genname($1, dec!)', $1_ptr_dec);
     ifelse($1, ~|, AddCommand('1+!', $1_ptr_inc);)
     ifelse($1, ~|, AddCommand('1-!', $1_ptr_dec);)
     AddCommand('genname($1, div)', $1_div);
     AddCommand('genname($1, mod)', $1_mod);
     AddCommand('genname($1, divmod)', $1_divmod);
    |)
|)
define(~convert_number_arithmetic_commands|, 
  ~
  procedure $1_convert_to_$3 cmdhdr
  define(~all_implement|, all_implement 
    ~
     procedure $1_convert_to_$3 cmdhdr; body( $4(WVar(-SizeOf($2))) := $2(WVar(-SizeOf($2))); 
                                                            Dec(WP, SizeOf($2) - SizeOf($4)); )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~AddCommand('$1->$3', $1_convert_to_$3);
    |)
|)
define(~float_arithmetic_commands|, 
  ~
   procedure $1_push  cmdhdr;
   procedure $1_interpret_push  cmdhdr;
   procedure $1_compile_push  cmdhdr;
   procedure $1_run_push  cmdhdr;
   procedure $1_slash cmdhdr;
   procedure $1_cos cmdhdr;
   procedure $1_sin cmdhdr;
   procedure $1_tan cmdhdr;
   procedure $1_atan cmdhdr;
   procedure $1_atan2 cmdhdr
  define(~all_implement|, all_implement 
    ~
     procedure $1_push  cmdhdr; body( if FState = FS_COMPILE then $1_compile_push(Machine, Command) else $1_interpret_push(Machine, Command) )
     procedure $1_interpret_push  cmdhdr; body( $2(WP^) := (StrToFloat(NextName)); Inc(WP, SizeOf($2)); )
     procedure $1_compile_push  cmdhdr; body( EWO('run@$1-push'); EW_$1(StrToFloat(NextName)); )
     procedure $1_run_push  cmdhdr; body( $2(WP^) := ER_$1; Inc(WP, SizeOf($2)); )
     procedure $1_slash cmdhdr; body( $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) / $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); )
     procedure $1_cos cmdhdr; body( $2(WVar(-SizeOf($2))) := Cos($2(WVar(-SizeOf($2)))); )
     procedure $1_sin cmdhdr; body( $2(WVar(-SizeOf($2))) := Sin($2(WVar(-SizeOf($2)))); )
     procedure $1_tan cmdhdr; body( $2(WVar(-SizeOf($2))) := Tan($2(WVar(-SizeOf($2)))); )
     procedure $1_atan cmdhdr; body( $2(WVar(-SizeOf($2))) := ArcTan($2(WVar(-SizeOf($2)))); )
     procedure $1_atan2 cmdhdr; body( $2(WVar(-2*SizeOf($2))) := ArcTan2($2(WVar(-2*SizeOf($2))), $2(WVar(-SizeOf($2)))); Dec(WP, SizeOf($2)) )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     AddCommand('$1-push', $1_push, True);
     AddCommand('run@$1-push', $1_run_push);
     AddCommand('$1/', $1_slash);
     AddCommand('genname($1,cos)', $1_cos);
     AddCommand('genname($1,sin)', $1_sin);
     AddCommand('genname($1,tan)', $1_tan);
     AddCommand('genname($1,atan)', $1_atan);
     AddCommand('genname($1,atan2)', $1_atan2);
    |)
|)
define(~sysar_commands|, 
  ~
  function ConvertStrTo$1(const B: TString; var X: $2): Integer
  define(~all_implement|, all_implement 
    ~
       function TForthMachine.ConvertStrTo$1(const B: TString; var X: $2): Integer;
       const
         Digits: array[0..15] of TChar = ('0', '1', '2', '3', '4', '5', '6', 
                                          '7', '8', '9', 'A', 'B', 'C', 'D',
                                          'E', 'F');
       var
         D: Byte;
             function GetDigit(C: TChar; var D: Byte): Boolean;
             begin
               Result := True;
               case C of
                 '0'..'9': D := Ord(C) - Ord('0');
                 'a'..'f': D := Ord(C) - Ord('a') + 10;
                 'A'..'F': D := Ord(C) - Ord('F') + 10;
               else
                 Result := False;
               end;
             end;
       begin
         X := 0;
         Result := Ord(Length(B) <> 0);
         if Result = 0 then
           Exit; 
         if B[1] = 'h' then begin
           Inc(Result);
           while Result <= Length(B) do begin
             if not GetDigit(B[Result], D) then
               Exit;
             X := (X shl 4) or D;
             Inc(Result);
           end;
           Result := 0;
         end else
           Val(B, X, Result);
       end;
    |
  )
|)
define(~system_commands|, 
  ~
  procedure EW_$1 (V: $2);
  function ER_$1: $2
  define(~all_implement|, all_implement 
    ~
      procedure TForthMachine.EW_$1; begin EWV(@V, SizeOf(V)) end;
      function TForthMachine.ER_$1; begin ERV(@Result, SizeOf(Result)) end;
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
    |)
|)
define(~push_interface|, ~procedure $1(const V: $2); overload 
  define(~all_implement|, all_implement 
     procedure TForthMachine.$1(const V: $2); begin $2($3^) := V; Inc($3, SizeOf(V)) end;
  )|)
define(~pop_interface|, ~function $1: $2 
  define(~all_implement|, all_implement 
    ~function TForthMachine.$1: $2; begin Dec($3, SizeOf(Result)); Result := $2($3^); end;
    |)|)
define(~misc_commands|, 
  ~
  procedure _timer cmdhdr;
  procedure _DogwpTemp cmdhdr;
  procedure _wp cmdhdr;
  procedure _rp cmdhdr;
  procedure _lp cmdhdr;
  procedure _lb cmdhdr;
  procedure _r_dog cmdhdr;
  procedure _r_gt cmdhdr;
  procedure _lt_r cmdhdr;
  procedure _l_dog cmdhdr;
  procedure _l_exclamation cmdhdr;
  procedure _l_plus cmdhdr;
  procedure version cmdhdr;
  procedure _state cmdhdr;
  procedure _time cmdhdr;
  procedure _local cmdhdr;
  procedure source_next_char cmdhdr;
  procedure source_next_name cmdhdr;
  procedure source_next_name_passive cmdhdr;
  procedure interpret_source_next_name_passive cmdhdr;
  procedure compile_source_next_name_passive cmdhdr;
  procedure run_source_next_name_passive cmdhdr;
  procedure source_read_to_char cmdhdr;
  procedure ptr_nil cmdhdr;
  procedure interpret_start cmdhdr;
  procedure compile_start cmdhdr;
  procedure run_start cmdhdr;
  //procedure allot cmdhdr
  procedure opcode_to_command cmdhdr;
  procedure literal cmdhdr;
  procedure sq_ap_sq cmdhdr;
  procedure interpret_sq_ap_sq cmdhdr;
  procedure compile_sq_ap_sq cmdhdr;
  procedure run_sq_ap_sq cmdhdr;
  procedure _tick cmdhdr;
  procedure execute cmdhdr;
  procedure _does_gt cmdhdr;
  procedure _sq_does_gt_sq cmdhdr;
  procedure CallDoesGt cmdhdr;
  procedure Cells cmdhdr;
  procedure Cell_plus cmdhdr;
  procedure _malloc cmdhdr;
  procedure _free cmdhdr;
  procedure _last cmdhdr;
  procedure _xt_dot_n cmdhdr;
  procedure _xt_dot_d cmdhdr;
  procedure _move cmdhdr;
  define(~all_implement|, all_implement 
    ~
      procedure _timer cmdhdr; body( WUI(GetTimer); )
      procedure _DogwpTemp cmdhdr; body( Pointer(WP^) := @WP; Inc(WP, SizeOf(Pointer)); )
      procedure _wp cmdhdr; body( Pointer(WP^) := WP; Inc(WP, SizeOf(Pointer)); )
      procedure _rp cmdhdr; body( Pointer(WP^) := RP; Inc(WP, SizeOf(Pointer)); )
      procedure _lp cmdhdr; body( Pointer(WP^) := LP; Inc(WP, SizeOf(Pointer)); )
      procedure _lb cmdhdr; body( Pointer(WP^) := LB; Inc(WP, SizeOf(Pointer)); )
      procedure _r_dog cmdhdr; body( Pointer(WP^) := Pointer(Pointer(Cardinal(RP) - SizeOf(Pointer))^); Inc(WP, SizeOf(Pointer)); )
      procedure _r_gt cmdhdr; body( Dec(RP, SizeOf(Pointer)); Pointer(WP^) := Pointer(RP^); Inc(WP, SizeOf(Pointer)); )
      procedure _lt_r cmdhdr; body( Dec(WP, SizeOf(Pointer)); Pointer(RP^) := Pointer(WP^); Inc(RP, SizeOf(Pointer)); )
      procedure _l_dog cmdhdr; body( Pointer(WVar(-SizeOf(Pointer))) := Pointer(LVar(Integer(WVar(-SizeOf(Pointer))))); )
      procedure _l_exclamation cmdhdr; body( Pointer(LVar(Integer(WVar(-SizeOf(Pointer))))) := Pointer(WVar(-2*SizeOf(Pointer))); Dec(WP, 2*SizeOf(Pointer)); )
      procedure _l_plus cmdhdr; body( Dec(WP, SizeOf(TInt)); Inc(LP, TInt(WP^)) )
      procedure version cmdhdr; body( TInt(WP^) := DFORTHMACHINE_VERSION; Inc(WP, SizeOf(TInt)); )
      procedure _state cmdhdr; body( Pointer(WP^) := @FState; Inc(WP, SizeOf(Pointer)); )
      procedure _time cmdhdr; body( Integer(WP^) := GetTimer; Inc(WP, SizeOf(TInt)); )
      procedure _local cmdhdr; body( RunCommand(PForthCommand((@E[Integer(Command^.Data)])^)); )
      procedure source_next_char cmdhdr; body( WUU8(Byte(NextChar)) )
      procedure source_next_name cmdhdr; body( str_push(Machine, Command, NextName) )
      procedure source_next_name_passive cmdhdr; body( // if FState <> FS_INTERPRET then compile_source_next_name_passive(Machine, Command) else 
                                                                                                   interpret_source_next_name_passive(Machine, Command) )
      procedure interpret_source_next_name_passive cmdhdr; body( str_push(Machine, Command, NextNamePassive) )
      procedure compile_source_next_name_passive cmdhdr; body( EWO('(str)"'); EWStr(NextNamePassive); )
      procedure run_source_next_name_passive cmdhdr; body( str_push(Machine, Command, @E[EC]); )
      procedure source_read_to_char cmdhdr; var I: Integer; body( I := SC; Dec(WP, 1); while (S[I] <> TChar(0))and(S[I] <> TChar(WP^)) do Inc(I); str_push(Machine, Command, TString(Copy(S, SC + 1, I - SC))); SC := I; )
      procedure ptr_nil cmdhdr; body( WUP(nil); )
      procedure compile_start cmdhdr; body( FState := FS_COMPILE )
      procedure interpret_start cmdhdr; body( FState := FS_INTERPRET )
      procedure run_start cmdhdr; body( FState := FS_INTERPRET )
      procedure opcode_to_command cmdhdr; body( Pointer(WVar(-SizeOf(Integer))) := GetCommandByOpcode(Integer(WVar(-SizeOf(Integer)))) )
      procedure literal cmdhdr; body( EWO('(literal)'); EWI(WOI); )
      procedure sq_ap_sq cmdhdr; body( {if FState <> FS_INTERPRET then compile_sq_ap_sq(Machine, Command) else interpret_sq_ap_sq(Machine, Command)}
                WUI(GetOpcodeByName(NextName)); Literal(Machine, Command);
                EWO('opcode->command'); )
      procedure interpret_sq_ap_sq cmdhdr; body( WUP(FindCommand(NextName)) )
      procedure compile_sq_ap_sq cmdhdr; body( EWO('run@['']'); EWO(NextName); )
      procedure run_sq_ap_sq cmdhdr; body( WUP(C[ERO]); )
      procedure _tick cmdhdr; body( Pointer(WP^) := FindCommand(NextName); Inc(WP, SizeOf(Pointer)); )
      procedure execute cmdhdr; var P: PForthCommand; body( 
                                             P := WOP; P.Code(Machine, P) )
      procedure _does_gt cmdhdr; body( EWO('(does>)'); EWO('exit'); )
      procedure _sq_does_gt_sq cmdhdr; body( Integer(C[FLastMnemonic].Param) := Integer(C[FLastMnemonic].Data); Integer(C[FLastMnemonic].Data) := EC + 4; C[FLastMnemonic].Code := CallDoesGt; )
      procedure CallDoesGt cmdhdr; body( Call(Machine, Command); Pointer(WP^) := Pointer(Command.Param); Inc(WP, SizeOf(Pointer)); )
      procedure Cells cmdhdr; body( TInt(WVar(-SizeOf(TInt))) := TInt(WVar(-SizeOf(TInt)))*SizeOf(Integer); )
      procedure Cell_plus cmdhdr; body( TInt(WVar(-SizeOf(TInt))) := TInt(WVar(-SizeOf(TInt))) + SizeOf(TInt); )
      procedure _malloc cmdhdr; var P: Pointer; body( P := Pointer(WVar(-SizeOf(Integer))); GetMem(P, Integer(WVar(-SizeOf(Integer)))); Pointer(WVar(-SizeOf(Integer))) := P; )
      procedure _free cmdhdr; var P: Pointer; body( Dec(WP, SizeOf(Pointer)); P := Pointer(WP^); FreeMem(P); )
      procedure _last cmdhdr; var P: Pointer; body( Pointer(WP^) := C[High(C)]; {Writeln(Integer(WP^));} Inc(WP, SizeOf(Pointer)); )
      procedure _xt_dot_n cmdhdr; body( Pointer(WVar(-SizeOf(Pointer))) := @(PForthCommand(WVar(-SizeOf(Pointer))).Name[0]); )
      procedure _xt_dot_d cmdhdr; body( Pointer(WVar(-SizeOf(Pointer))) := PForthCommand(WVar(-SizeOf(Pointer))).Data )
      procedure _move cmdhdr; body( Dec(WP, SizeOf(Pointer)*3); Move(Pointer(WVar(0))^, Pointer(WVar(SizeOf(Pointer)))^, TUint(WVar(2*SizeOf(Pointer)))); {Writeln(TUInt(WVar(0)), TUInt(WVar(SizeOf(Pointer))), TUint(WVar(2*SizeOf(Pointer))));} )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     AddCommand('timer', _timer);
     AddCommand('wp', _wp);
     AddCommand('@wp', _DogwpTemp);
     AddCommand('rp', _rp);
     AddCommand('lp', _lp);
     AddCommand('lb', _lb);
     AddCommand('r@', _r_dog);
     AddCommand('r>', _r_gt);
     AddCommand('>r', _lt_r);
     AddCommand('l@', _l_dog);
     AddCommand('l!', _l_exclamation);
     AddCommand('l+', _l_plus);
     AddCommand('sys-version', version);
     AddCommand('state', _state);
     AddCommand('time', _time);
     AddCommand('local', _local);
     AddCommand('source-next-char', source_next_char);
     AddCommand('source-next-name', source_next_name);
     AddCommand('source-next-name-passive', source_next_name_passive);
     AddCommand('interpret@source-next-name-passive', source_next_name_passive);
     AddCommand('compile@source-next-name-passive', source_next_name_passive);
     AddCommand('run@source-next-name-passive', source_next_name_passive);
     AddCommand('source-read-to-char', source_read_to_char);
     AddCommand('ptr-nil', ptr_nil);
     AddCommand('interpret@', interpret_start);
     AddCommand('compile@', compile_start);
     AddCommand('run@', run_start);
     //AddCommand('allot', allot);
     //AddCommand('literal', literal, True);
     AddCommand('['']', sq_ap_sq, True);
     AddCommand('opcode->command', opcode_to_command);
     //AddCommand('run@['']', run_sq_ap_sq);
     //AddCommand('compile@['']', compile_sq_ap_sq);
     //AddCommand('interpret@['']', interpret_sq_ap_sq);
     AddCommand('''', _tick);
     AddCommand('execute', execute);
     AddCommand('does>', _does_gt, True);
     AddCommand('(does>)', _sq_does_gt_sq);
     AddCommand('cells', Cells);
     AddCommand('cell+', Cell_plus);
     AddCommand('malloc', _malloc);
     AddCommand('free', _free);
     AddCommand('last', _last);
     AddCommand('xt.n@', _xt_dot_n);
     AddCommand('xt.d@', _xt_dot_d);
     AddCommand('move', _move);
    |)
|)
define(~file_commands|, 
  ~
  procedure file_open cmdhdr;
  procedure file_close cmdhdr;
  procedure file_w cmdhdr;
  procedure file_r cmdhdr;
  procedure file_write cmdhdr;
  procedure file_read cmdhdr;
  procedure file_write_from_w cmdhdr;
  procedure file_read_to_w cmdhdr;
  procedure file_size cmdhdr;
  define(~all_implement|, all_implement 
    ~
      type
        PdfFile = ^TdfFile;
        TdfFile = record
          Data: TData;
          Name: String;
          Mode: TInt;
        end;
      procedure file_open cmdhdr; 
      var 
        F: PdfFile;
        B: TStr;
      body( 
         New(F);
         F^.Mode := WOI; 
         B := str_pop(Machine, Command); 
         F^.Name := PChar(@(PStrRec(B)^.Sym[0]));
         if F^.Mode = DF_FILE_R then
           F^.Data := TData.Create(F^.Name)
         else
           F^.Data := TData.Create;
         WUP(F); 
         DelRef(B);
      )
      procedure file_close cmdhdr; 
      var
        F: PdfFile;
      body( 
        F := WOP;
        if F^.Mode = DF_FILE_W then
          F^.Data.WriteToFile(F^.Name);
        F^.Data.Free;
        Dispose(F); 
      )
      procedure file_w cmdhdr; body( WUI(DF_FILE_W) )
      procedure file_r cmdhdr; body( WUI(DF_FILE_R) )
      procedure file_write cmdhdr; 
      var
        Src: Pointer;
        I: TInt;
        F: PdfFile;
      body( 
        F := WOP;
        I := WOI;
        Src := WOP;
        F^.Data.WriteVar(WOP, I);
      )
      procedure file_read cmdhdr;
      var
        Src: Pointer;
        I: TInt;
        F: PdfFile;
      body( 
        //I := WOI; 
        //Src := WOP; 
        //F := WOP; 
        //F^.Data.ReadVar(Src, I);
        //PdfFile(WVar(-SizeOf(PdfFile)))^.Data.ReadVar(Src, I);
        F := WOP;
        I := WOI;
        Src := WOP;
        F^.Data.WriteVar(WOP, I);
      )
      procedure file_write_from_w cmdhdr;
      body(
      )
      procedure file_read_to_w cmdhdr;
      body(
      )
      procedure file_size cmdhdr; body( WUI(PdfFile(WOP)^.Data.Size); )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     AddCommand('file-open', file_open);
     AddCommand('file-close', file_close);
     AddCommand('file-w', file_w);
     AddCommand('file-r', file_r);
     AddCommand('file-write', file_write);
     AddCommand('file-read', file_read);
     AddCommand('file-size', file_size);
    |)
|)

const
  BOOL_FALSE: Integer   = 0;
  BOOL_TRUE: Integer    = -1;

  CONV_STDCALL: Integer = 100;
  CONV_CDECL: Integer   = 101;

  MACHINE_MODE_READY            = $00;
  MACHINE_MODE_BREAKPOINT       = $01;
  MACHINE_MODE_WAITSOURCE       = $02;
  MACHINE_MODE_WORK             = $03;

  FS_INTERPRET                  = $00;
  FS_COMPILE                    = not $00;
  // FS_RUN                        = $02;

  DF_FILE_R                     = $A0;
  DF_FILE_W                     = $A1;

  EOL: String                   = #13;

type
  TForthMachine = class;

  PForthCommand = ^TForthCommand;
  TCode = procedure (Machine: TForthMachine; Command: PForthCommand); register;
  TForthCommand = record 
          Code: TCode;
          Data: Pointer;
          Flags: Byte;
          Name: PChar; 
          Param: Pointer;
        end;

  TCallback = procedure (machine: Pointer); stdcall;
  TForthRuntimeProc = procedure (machine: TForthMachine; Command: PForthCommand) 
                                                                      of object;
  TForthCommandProc = procedure (machine: TForthMachine) of object;

  TMnemonic = TInt;
  TOpcode = TInt;
  TPtr = Pointer;
  TEmbroPtr = TInt;

  TStrRec = packed record
    Ref: TInt;
    Len: TInt;
    Sym: array[0..1] of TChar;
  end;
  PStrRec = ^TStrRec;
  TStr = PStrRec;

  PLong = ^TLong;
  TLong = record
    Ref: Integer; // -1 если не нужно высвобождать из памяти, иначе --- число ссылок
    Flags: Integer; // Flags and 1 > 0 если число отрицательно
    Len: Integer; // Такое число, что V[I] = 0 для всех I >= Len
    Max: Integer; // Число элементов в массиве V
    V: array[0..1] of Integer;
  end;

  TType = record
    Name: PChar;
    Size: Integer;
  end;
  PType = ^TType;

  TWordSpace = record
    C: array of PForthCommand;
    L: Integer;
    S: Integer;
  end;
{$IFNDEF FLAG_FPC}{$REGION 'TForthMachine'}{$ENDIF}
TForthMachine = class
 private
  FUserData: Pointer;
{$IFNDEF FLAG_FPC}{$REGION 'Strings'}{$ENDIF}
  // когда они создаются при интерпритации, нужно где-то хранить
  FPChars: array of array of TChar;

  TempS: TStr;
  FStrNil: TStr;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'exceptions'}{$ENDIF}
 public
  Exceptions: array of Byte;
  ExceptionsB: Pointer;
  ExceptionsP: Pointer;
  ExceptionsS: Integer;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
  //C: array of TForthCommand;
  FData: array of Byte;
  //FHere: Integer;
  FCompilation: Boolean;
  FRunning: Boolean;
  FSource: PChar;
  FCurrentChar: Integer;
  //FPC: Cardinal;
  FCurrentName: TString;
  // FS_*
  FState: Integer;
  FSession: Boolean;
  FLastMnemonic: Integer;
  FEmbroDump: array of TString;
  FEmbro: array of Byte;
  FTypes: array of TType;
  FMemoryDebug: TDebug;
  FAlien: TAlien;
  procedure CompileSource(Source: PChar);
  function CompileName(W: PChar): Boolean; overload;
  function NextMnemonic: Cardinal;
  procedure Run(Index: Integer);
  procedure RunMnemonic(M: Cardinal);
  procedure RunCommand(Command: PForthCommand);
  procedure RunError(const S: TString);
  procedure RunWarring(const S: TString);
  procedure IncHere(Count: Integer);
  procedure AddType(const Name: TString; Size: Integer);
 public
  system_commands(, TInt);
  system_commands(int, TInt);
  system_commands(int8, TInt8);
  system_commands(int16, TInt16);
  system_commands(int32, TInt32);
  system_commands(int64, TInt64);
  system_commands(uint, TUInt);
  system_commands(uint8, TUInt8);
  system_commands(uint16, TUInt16);
  system_commands(uint32, TUInt32);
  system_commands(uint64, TUInt64);
  system_commands(single, Single);
  system_commands(double, Double);
  system_commands(extended, Extended);
  sysar_commands(, TInt);
  sysar_commands(int, TInt);
  sysar_commands(int8, TInt8);
  sysar_commands(int16, TInt16);
  sysar_commands(int32, TInt32);
  sysar_commands(int64, TInt64);
  sysar_commands(uint, TUInt);
  sysar_commands(uint8, TUInt8);
  sysar_commands(uint16, TUInt16);
  sysar_commands(uint32, TUInt32);
  sysar_commands(uint64, TUInt64);
{$IFNDEF FLAG_FPC}{$REGION 'machine datas'}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'E'}{$ENDIF}
 public
  E: array of Byte; // Embro
  EB: Pointer; // Embro Base (@E[0])
  EC: Integer; // Embro Counter (E[EC])
  EL: Integer; // Embro Last compiled
  ES: Integer; // Embro Size (Length(E))
  procedure EA(Size: Integer); // Embro Alloc
  function Here: Pointer; overload;
  procedure EWV(V: Pointer; Size: Integer); // Embro Write Var
  procedure EWI(V: Integer); // Embro Write Integer
  procedure EWE(V: TEmbroPtr);
  procedure EWO(V: TOpcode); overload;
  procedure EWO(V: TString); overload;
  procedure EWR(V: TOpcode); overload;
  procedure EWI8(V: TInt8);
  procedure EWI16(V: TInt16);
  procedure EWI32(V: TInt32);
  procedure EWI64(V: TInt64);
  procedure EWU(V: TUInt);
  procedure EWU8(V: TUInt8);
  procedure EWU16(V: TUInt16);
  procedure EWU32(V: TUInt32);
  procedure EWU64(V: TUInt64);
  procedure EWC(V: Char);
  procedure EWS(V: Single);
  procedure EWD(const V: Double);
  procedure EWExtended(const V: Extended);
  procedure EWPChar(V: PChar);
  procedure EWStr(V: TString);
  procedure ERV(V: Pointer; Size: Integer); // Embro Read Var
  function ERI: Integer; // Embro Read Integer
  function ERE: TEmbroPtr;
  function ERO: TOpcode;
  function ERI8: TInt8;
  function ERI16: TInt16;
  function ERI32: TInt32;
  function ERI64: TInt64;
  function ERU: TUInt;
  function ERU8: TUInt8;
  function ERU16: TUInt16;
  function ERU32: TUInt32;
  function ERU64: TUInt64;
  function ERC: Char;
  function ERS: Single;
  function ERD: Double;
  function ERExtended: Extended;
  function ERPChar: PChar;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'R'}{$ENDIF}
 public
  R: array of Byte; // Return stack
  RB: Pointer; // Return stack Base
  RP: Pointer; // Return stack Pointer
  RS: Integer; // Return stack Size
  procedure RUV(const P: Pointer; Size: Integer);
  procedure ROV(const P: Pointer; Size: Integer);
  pop_interface(ROP, Pointer, RP); // Return stack pOp Pointer
  push_interface(RUI, TInt, RP); // Return stack pUsh Integer
  push_interface(RUI8, TInt8, RP); 
  push_interface(RUI16, TInt16, RP);
  push_interface(RUI32, TInt32, RP);
  push_interface(RUI64, TInt64, RP);
  push_interface(RUU, TUInt, RP);
  push_interface(RUU8, TUInt8, RP); 
  push_interface(RUU16, TUInt16, RP);
  push_interface(RUU32, TUInt32, RP);
  push_interface(RUU64, TUInt64, RP);
  push_interface(RUP, Pointer, RP); // Return stack pUsh Pointer
  pop_interface(ROI, TInt, RP); // Return stack pOp Integer
  pop_interface(ROI8, TInt8, RP); 
  pop_interface(ROI16, TInt16, RP);
  pop_interface(ROI32, TInt32, RP);
  pop_interface(ROI64, TInt64, RP);
  pop_interface(ROU, TUInt, RP);
  pop_interface(ROU8, TUInt8, RP); 
  pop_interface(ROU16, TUInt16, RP);
  pop_interface(ROU32, TUInt32, RP);
  pop_interface(ROU64, TUInt64, RP);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'W'}{$ENDIF}
 public
  W: array of Byte; // Work stack
  WB: Pointer; // Work stack Base (@W[0])
  WP: Pointer; // Work stack Pointer
  WS: Integer; // Work stack Size
  CW: array of Pointer; // Counter Work stack
  CWB: Pointer;
  CWP: Pointer;
  CWS: Integer;
  procedure CWU(C: Pointer); // Counter Work pUsh
  function CWO: Pointer; // Counter Work pOp
  push_interface(WUI, TInt, WP); // Work stack pUsh Integer
  push_interface(WUP, Pointer, WP); // Work stack pUsh Pointer
  pop_interface(WOI, TInt, WP); // Work stack pOp Integer
  pop_interface(WOP, Pointer, WP); // Work stack pOp Pointer
  push_interface(WUI8, TInt8, WP); 
  push_interface(WUI16, TInt16, WP);
  push_interface(WUI32, TInt32, WP);
  push_interface(WUI64, TInt64, WP);
  push_interface(WUU, TUInt, WP);
  push_interface(WUU8, TUInt8, WP); 
  push_interface(WUU16, TUInt16, WP);
  push_interface(WUU32, TUInt32, WP);
  push_interface(WUU64, TUInt64, WP);
  pop_interface(WOI8, TInt8, WP); 
  pop_interface(WOI16, TInt16, WP);
  pop_interface(WOI32, TInt32, WP);
  pop_interface(WOI64, TInt64, WP);
  pop_interface(WOU, TUInt, WP);
  pop_interface(WOU8, TUInt8, WP); 
  pop_interface(WOU16, TUInt16, WP);
  pop_interface(WOU32, TUInt32, WP);
  pop_interface(WOU64, TUInt64, WP);
  procedure WUV(const P: Pointer; Size: Integer);
  procedure WOV(const P: Pointer; Size: Integer);
  procedure WUS(const S: TString);
  function WOS: TString;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'C'}{$ENDIF}
 public
  C: array of PForthCommand; // Commands
  CB: Pointer; // Commands Base (@C[0])
  CC: Integer; // Commands Counter (C[CC] - last added command)
  CS: Integer; // Commands Size (Length(C))
  // Command REserve
  // Command FInd
  // Command EXecute
  // Command COmpile
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'LOCALS'}{$ENDIF}
 public
   Local: TWordSpace;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'D'}{$ENDIF}
 public
 {D: array of Byte; // Data
  DB: Pointer; // Data Base
  DP: Pointer; // Data Pointer (traditionaly called HERE in forth)
  DS: Integer; // Data Size
  procedure DA(Size: Integer); // Data Allot}
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'S'}{$ENDIF}
 public
  // doesn't work in run state
  S: PChar; // Source
  SC: Integer; // Source Counter
  function SE: Boolean; // Source End
  function SNC: TChar; // Source Next Char
  function SNN: TString; // Source Next Name
  procedure SSS; // Source Skip Spaces
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'L'}{$ENDIF}
 public
  L: array of Byte; // Local stack
  LB: Pointer; // Local stack Base (@W[0])
  LP: Pointer; // Local stack Pointer
  LS: Integer; // Local stack Size
  procedure LUV(const P: Pointer; Size: Integer);
  procedure LOV(const P: Pointer; Size: Integer);
  push_interface(LUI, TInt, LP); // Work stack pUsh Integer
  push_interface(LUP, Pointer, LP); // Work stack pUsh Pointer
  pop_interface(LOI, TInt, LP); // Work stack pOp Integer
  pop_interface(LOP, Pointer, LP); // Work stack pOp Pointer
  push_interface(LUI8, TInt8, LP); 
  push_interface(LUI16, TInt16, LP);
  push_interface(LUI32, TInt32, LP);
  push_interface(LUI64, TInt64, LP);
  push_interface(LUU, TUInt, LP);
  push_interface(LUU8, TUInt8, LP); 
  push_interface(LUU16, TUInt16, LP);
  push_interface(LUU32, TUInt32, LP);
  push_interface(LUU64, TUInt64, LP);
  pop_interface(LOI8, TInt8, LP); 
  pop_interface(LOI16, TInt16, LP);
  pop_interface(LOI32, TInt32, LP);
  pop_interface(LOI64, TInt64, LP);
  pop_interface(LOU, TUInt, LP);
  pop_interface(LOU8, TUInt8, LP); 
  pop_interface(LOU16, TUInt16, LP);
  pop_interface(LOU32, TUInt32, LP);
  pop_interface(LOU64, TUInt64, LP);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'V'}{$ENDIF}
 public
  Context: array of PVoc;
  Target: array of PVoc;
  vGLOBAL: PVoc;
  vLOCAL: PVoc;
  procedure ContextPush(V: PVoc);
  function ContextPop: PVoc;
  procedure TargetPush(V: PVoc);
  function TargetPop: PVoc;
  procedure UseVoc(V: PVoc);
  procedure UnuseVoc;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'plugin datas'}{$ENDIF}
 public
  Code: packed record
    Count: Cardinal;
    Chunks: Pointer;
  end;
  Chunks: array of packed record
                            Opcode: Cardinal;
                            Len: Cardinal;
                            Data: Pointer;
                            Count: Cardinal;
                            Refs: Pointer;
                          end;
  Refs: array of array of Cardinal;
  Commands: array of packed record
                       Name: PChar;
                       Flags: Integer;
                       Code: Integer;
                       Data: Integer;
                     end;
  FOutput: TString;
  FAppType: Integer;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
  constructor Create;
  destructor Destroy; override;
  procedure AddCommand(Name: PChar; Code: TCode; Immediate: Boolean = False;
                       Builtin: Boolean = True);
  procedure OnUpdateCommand(Opcode: Integer); overload;
  procedure OnUpdateCommand(Command: PForthCommand); overload;

  procedure InterpretName(W: PChar); overload;
  procedure Interpret(const S: PChar); overload;
  procedure InterpretFile(const FileName: TString);
  procedure CallCommand(Command: PForthCommand);
  procedure MainLoop;
  procedure InterpretStep;
  procedure CompileStep;
  procedure RunStep;
  
  // команды времени компиляции
  procedure CompileError(const S: TString);
  procedure CompileWarring(const S: TString);
  procedure LogError(const S: TString);
  function NextChar: TChar;
  function NextName: TString; overload;
  function NextName(S: PChar; var I: Integer): TString; overload;
  function NextNamePassive: TString;
  function EOS: Boolean; // end of source
  procedure WriteEmbro(P: Pointer; Size: Integer);
  procedure WriteEmbroInt(I: Integer); overload;
  procedure WriteEmbroUInt(U: Cardinal); overload;
  procedure WriteEmbroChar(C: Char); overload;
  procedure WriteEmbroByte(B: Byte); overload;
  procedure PopEmbro(P: Pointer; Size: Integer);
  procedure WriteMnemonic(M: Cardinal);
  procedure WriteMnemonicByName(const Name: TString);
  function GetOpcodeByName(const Name: TString): TMnemonic;
  function GetCommandByOpcode(Opcode: Integer): PForthCommand;
  procedure CancelMnemonic;
  function ReserveName(const Name: TString): PForthCommand;
  
  procedure ReadEmbro(P: Pointer; Size: Integer);
  function ReadMnemonic: TMnemonic;

  function GetEmbroDumpLines: Integer;
  function GetEmbroDumpLine(Index: Integer): TString;
  function FindCommand(const Name: TString; Index: PInteger = nil): PForthCommand;

  property UserData: Pointer read FUserData write FUserData;
  property Current: Integer;
  property State: Integer read FState write FState;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'all commands'}{$ENDIF}
  dnl typed_commands(1, 1);
  dnl typed_commands(2, 2);
  dnl typed_commands(4, 4);
  dnl typed_commands(8, 8);
  typed_commands(~|, 4);
  typed_commands(ptr, 4);
  typed_commands(int, 4);
  typed_commands(int8, 1);
  typed_commands(int16, 2);
  typed_commands(int32, 4);
  typed_commands(int64, 8);
  typed_commands(uint, 4);
  typed_commands(uint8, 1);
  typed_commands(uint16, 2);
  typed_commands(uint32, 4);
  typed_commands(uint64, 8);
  typed_commands(embro, 4);
  arithmetic_commands(, TInt);
  arithmetic_commands(int, TInt);
  arithmetic_commands(int8, TInt8);
  arithmetic_commands(int16, TInt16);
  arithmetic_commands(int32, TInt32);
  arithmetic_commands(int64, TInt64);
  arithmetic_commands(uint, TUInt);
  arithmetic_commands(uint8, TUInt8);
  arithmetic_commands(uint16, TUInt16);
  arithmetic_commands(uint32, TUInt32);
  arithmetic_commands(uint64, TUInt64);
  arithmetic_commands(single, Single);
  arithmetic_commands(double, Double);
  arithmetic_commands(extended, Extended);
  signed_arithmetic_commands(, TInt);
  signed_arithmetic_commands(int, TInt);
  signed_arithmetic_commands(int8, TInt8);
  signed_arithmetic_commands(int16, TInt16);
  signed_arithmetic_commands(int32, TInt32);
  signed_arithmetic_commands(int64, TInt64);
  signed_arithmetic_commands(single, Single);
  signed_arithmetic_commands(double, Double);
  number_arithmetic_commands(, TInt);
  number_arithmetic_commands(int, TInt);
  number_arithmetic_commands(int8, TInt8);
  number_arithmetic_commands(int16, TInt16);
  number_arithmetic_commands(int32, TInt32);
  number_arithmetic_commands(int64, TInt64);
  number_arithmetic_commands(uint, TUInt);
  number_arithmetic_commands(uint8, TUInt8);
  number_arithmetic_commands(uint16, TUInt16);
  number_arithmetic_commands(uint32, TUInt32);
  number_arithmetic_commands(uint64, TUInt64);
  convert_number_arithmetic_commands(int,      TInt,     int8,     TInt8);
  convert_number_arithmetic_commands(int,      TInt,     int16,    TInt16);
  convert_number_arithmetic_commands(int,      TInt,     int32,    TInt32);
  convert_number_arithmetic_commands(int,      TInt,     int64,    TInt64);
  convert_number_arithmetic_commands(int8,     TInt8,    int,      TInt);
  convert_number_arithmetic_commands(int16,    TInt16,   int,      TInt);
  convert_number_arithmetic_commands(int32,    TInt32,   int,      TInt);
  convert_number_arithmetic_commands(int64,    TInt64,   int,      TInt);
  convert_number_arithmetic_commands(uint,     TUInt,    uint8,    TUInt8);
  convert_number_arithmetic_commands(uint,     TUInt,    uint16,   TUInt16);
  convert_number_arithmetic_commands(uint,     TUInt,    uint32,   TUInt32);
  convert_number_arithmetic_commands(uint,     TUInt,    uint64,   TUInt64);
  convert_number_arithmetic_commands(uint8,    TUInt8,   uint,     TUInt);
  convert_number_arithmetic_commands(uint16,   TUInt16,  uint,     TUInt);
  convert_number_arithmetic_commands(uint32,   TUInt32,  uint,     TUInt);
  convert_number_arithmetic_commands(uint64,   TUInt64,  uint,     TUInt);
  convert_number_arithmetic_commands(single,   Single,   double,   Double);
  convert_number_arithmetic_commands(double,   Double,   single,   Single);
  convert_number_arithmetic_commands(single,   Single,   extended, Extended);
  convert_number_arithmetic_commands(double,   Double,   extended, Extended);
  convert_number_arithmetic_commands(extended, Extended, double,   Double);
  convert_number_arithmetic_commands(extended, Extended, single,   Single);
  float_arithmetic_commands(single, Single);
  float_arithmetic_commands(double, Double);
  float_arithmetic_commands(extended, Extended);
  misc_commands
  exception_commands
  file_commands
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'misc commands'}{$ENDIF}
  procedure CompileComment(Machine: TForthMachine; Command: PForthCommand);
  procedure CompileLineComment(Machine: TForthMachine; Command: PForthCommand);
  procedure _vocabulary(Machine: TForthMachine; Command: PForthCommand);
  procedure _vLOCAL(Machine: TForthMachine; Command: PForthCommand);
  procedure _vGLOBAL(Machine: TForthMachine; Command: PForthCommand);
  procedure _TargetPush(Machine: TForthMachine; Command: PForthCommand);
  procedure _TargetPop(Machine: TForthMachine; Command: PForthCommand);
  procedure _ContextPush(Machine: TForthMachine; Command: PForthCommand);
  procedure _ContextPop(Machine: TForthMachine; Command: PForthCommand);
  procedure _here(Machine: TForthMachine; Command: PForthCommand); overload;
  procedure _CtoW(Machine: TForthMachine; Command: PForthCommand);
  procedure _WtoC(Machine: TForthMachine; Command: PForthCommand);
  procedure Evaluate(Machine: TForthMachine; Command: PForthCommand);
  procedure EvaluateFile(Machine: TForthMachine; Command: PForthCommand);
  procedure _FIND_(Machine: TForthMachine; Command: PForthCommand);
  procedure _NOTFOUND_(Machine: TForthMachine; Command: PForthCommand);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TBoolCommands'}{$ENDIF}
procedure _bool_push(Machine: TForthMachine; Command: PForthCommand);
procedure _false(Machine: TForthMachine; Command: PForthCommand);
procedure _true(Machine: TForthMachine; Command: PForthCommand);
procedure _not(Machine: TForthMachine; Command: PForthCommand);
procedure _or(Machine: TForthMachine; Command: PForthCommand);
procedure _and(Machine: TForthMachine; Command: PForthCommand);
procedure _xor(Machine: TForthMachine; Command: PForthCommand);
procedure _bool_dot(Machine: TForthMachine; Command: PForthCommand);
//procedure _bool_compile_push(Machine: TForthMachine);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TConsoleCommands'}{$ENDIF}
procedure cr(Machine: TForthMachine; Command: PForthCommand);
procedure emit(Machine: TForthMachine; Command: PForthCommand);
procedure space(Machine: TForthMachine; Command: PForthCommand);
procedure spaces(Machine: TForthMachine; Command: PForthCommand);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TControlCommands'}{$ENDIF}
procedure branch(Machine: TForthMachine; Command: PForthCommand);
procedure _ask_branch(Machine: TForthMachine; Command: PForthCommand);
procedure _gt_mark(Machine: TForthMachine; Command: PForthCommand);
procedure _gt_resolve(Machine: TForthMachine; Command: PForthCommand);
procedure _lt_mark(Machine: TForthMachine; Command: PForthCommand);
procedure _lt_resolve(Machine: TForthMachine; Command: PForthCommand);
procedure _exit(Machine: TForthMachine; Command: PForthCommand);
procedure recurse(Machine: TForthMachine; Command: PForthCommand);
procedure call(Machine: TForthMachine; Command: PForthCommand);
procedure compile_def(Machine: TForthMachine; Command: PForthCommand);
procedure compile_noname(Machine: TForthMachine; Command: PForthCommand);
procedure compile_skip_to_end(Machine: TForthMachine; Command: PForthCommand);
procedure compile_enddef(Machine: TForthMachine; Command: PForthCommand);
procedure compile_scattered_def(Machine: TForthMachine; Command: PForthCommand);
procedure compile_scattered_enddef(Machine: TForthMachine; Command: PForthCommand); 
procedure scattered_dots(Machine: TForthMachine; Command: PForthCommand); 
procedure immediate(Machine: TForthMachine; Command: PForthCommand);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TEmbroCommands'}{$ENDIF}
procedure compile(Machine: TForthMachine; Command: PForthCommand);
procedure q_compile_q(Machine: TForthMachine; Command: PForthCommand);
procedure _execute(Machine: TForthMachine; Command: PForthCommand);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TDataCommands'}{$ENDIF}
  procedure _nil(Machine: TForthMachine; Command: PForthCommand);
  procedure ptr_comma(Machine: TForthMachine; Command: PForthCommand);

  procedure _create(Machine: TForthMachine; Command: PForthCommand);
  procedure _created(Machine: TForthMachine; Command: PForthCommand);
  procedure putdataptr(Machine: TForthMachine; Command: PForthCommand);
  procedure here(Machine: TForthMachine; Command: PForthCommand);
  procedure allot(Machine: TForthMachine; Command: PForthCommand);

  procedure compile_to(Machine: TForthMachine; const Name: TString; Size: Integer);
  procedure interpete_to(Machine: TForthMachine; const Name: TString; Size: Integer);

  procedure to_int(Machine: TForthMachine; Command: PForthCommand);
  procedure to_int8(Machine: TForthMachine; Command: PForthCommand);
  procedure to_int16(Machine: TForthMachine; Command: PForthCommand);
  procedure to_int32(Machine: TForthMachine; Command: PForthCommand);
  procedure to_int64(Machine: TForthMachine; Command: PForthCommand);
  procedure to_uint(Machine: TForthMachine; Command: PForthCommand);
  procedure to_uint8(Machine: TForthMachine; Command: PForthCommand);
  procedure to_uint16(Machine: TForthMachine; Command: PForthCommand);
  procedure to_uint32(Machine: TForthMachine; Command: PForthCommand);
  procedure to_uint64(Machine: TForthMachine; Command: PForthCommand);
  procedure to_ptr(Machine: TForthMachine; Command: PForthCommand);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TTypeCommands'}{$ENDIF}
  procedure typeof(Machine: TForthMachine; Command: PForthCommand);
  procedure type_size(Machine: TForthMachine; Command: PForthCommand);
  procedure compile_type(Machine: TForthMachine; Name: PChar);
  procedure interpete_type(Machine: TForthMachine; Name: PChar);
  procedure run_type(Machine: TForthMachine; Command: PForthCommand);
  procedure _void(Machine: TForthMachine; Command: PForthCommand);
  procedure _int(Machine: TForthMachine; Command: PForthCommand);
  procedure _int8(Machine: TForthMachine; Command: PForthCommand);
  procedure _int16(Machine: TForthMachine; Command: PForthCommand);
  procedure _int32(Machine: TForthMachine; Command: PForthCommand);
  procedure _int64(Machine: TForthMachine; Command: PForthCommand);
  procedure _uint(Machine: TForthMachine; Command: PForthCommand);
  procedure _uint8(Machine: TForthMachine; Command: PForthCommand);
  procedure _uint16(Machine: TForthMachine; Command: PForthCommand);
  procedure _uint32(Machine: TForthMachine; Command: PForthCommand);
  procedure _uint64(Machine: TForthMachine; Command: PForthCommand);
  procedure _bool(Machine: TForthMachine; Command: PForthCommand);
  procedure _str(Machine: TForthMachine; Command: PForthCommand);
  procedure _pchar(Machine: TForthMachine; Command: PForthCommand);
  procedure _ptr(Machine: TForthMachine; Command: PForthCommand);
  procedure _type(Machine: TForthMachine; Command: PForthCommand);
  procedure _single(Machine: TForthMachine; Command: PForthCommand);
  procedure _double(Machine: TForthMachine; Command: PForthCommand);
  procedure _extended(Machine: TForthMachine; Command: PForthCommand);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TAlienCommands'}{$ENDIF}
  procedure lib_load(Machine: TForthMachine; Command: PForthCommand);
  procedure lib_unload(Machine: TForthMachine; Command: PForthCommand);
  procedure lib_fun(Machine: TForthMachine; Command: PForthCommand);
  procedure alien_fun(Machine: TForthMachine; Command: PForthCommand);
  procedure alien_endfun(Machine: TForthMachine; Command: PForthCommand);
  procedure callback_fun(Machine: TForthMachine; Command: PForthCommand);
  procedure callback_endfun(Machine: TForthMachine; Command: PForthCommand);
  procedure invoke_stdcall(Machine: TForthMachine; Command: PForthCommand);
  procedure invoke_cdecl(Machine: TForthMachine; Command: PForthCommand);
  procedure _conv_stdcall(Machine: TForthMachine; Command: PForthCommand);
  procedure _conv_cdecl(Machine: TForthMachine; Command: PForthCommand);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TStringCommands'}{$ENDIF}
  procedure pchar_alloc(Machine: TForthMachine; Command: PForthCommand);
  procedure pchar_free(Machine: TForthMachine; Command: PForthCommand);
  procedure pchar_len(Machine: TForthMachine; Command: PForthCommand);
  procedure pchar_concat(Machine: TForthMachine; Command: PForthCommand);
  procedure pchar_equel(Machine: TForthMachine; Command: PForthCommand);
  procedure pchar_dq(Machine: TForthMachine; Command: PForthCommand);
  procedure compile_pchar_dq(Machine: TForthMachine; Command: PForthCommand);
  procedure run_pchar_dq(Machine: TForthMachine; Command: PForthCommand);
  procedure pchar_dot(Machine: TForthMachine; Command: PForthCommand);

  procedure str_drop(Machine: TForthMachine; Command: PForthCommand);
  procedure str_dup(Machine: TForthMachine; Command: PForthCommand);
  procedure str_over(Machine: TForthMachine; Command: PForthCommand);

  procedure str_len(Machine: TForthMachine; Command: PForthCommand);
  procedure str_dq(Machine: TForthMachine; Command: PForthCommand);
  procedure compile_str_dq(Machine: TForthMachine; Command: PForthCommand);
  procedure run_str_dq(Machine: TForthMachine; Command: PForthCommand);
  procedure str_equel(Machine: TForthMachine; Command: PForthCommand);
  procedure str_concat(Machine: TForthMachine; Command: PForthCommand);
  procedure str_nil(Machine: TForthMachine; Command: PForthCommand);
  procedure str_dot(Machine: TForthMachine; Command: PForthCommand);
  procedure str_dollar(Machine: TForthMachine; Command: PForthCommand);
  procedure str_dog(Machine: TForthMachine; Command: PForthCommand);
  procedure str_exclamation(Machine: TForthMachine; Command: PForthCommand);
  procedure pchar_to_str(Machine: TForthMachine; Command: PForthCommand);
  procedure Format(Machine: TForthMachine; Command: PForthCommand);

  // подсчёт ссылок у строк
  procedure AddRef(B: TStr);
  procedure DelRef(B: TStr);

  // стековые команды над строками отличаются
  procedure str_push(Machine: TForthMachine; Command: PForthCommand; B: TString); overload;
  procedure str_push(Machine: TForthMachine; Command: PForthCommand; B: TStr); overload;
  function str_pop(Machine: TForthMachine; Command: PForthCommand): TStr;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}

function IsImmediate(Command: PForthCommand): Boolean;
procedure SetImmediate(Command: PForthCommand; I: Boolean);
function IsBuiltin(Command: PForthCommand): Boolean;
procedure SetBuiltin(Command: PForthCommand; I: Boolean);
function CopyStrToPChar(const B: TString): PChar;

procedure WordListClear(var WL: TWordSpace);
function WordListInsert(var WL: TWordSpace; Command: PForthCommand): Integer;
function WordListFind(var WL: TWordSpace; B: TString; var Opcode: TOpcode): Boolean;

implementation

function IsImmediate(Command: PForthCommand): Boolean;
begin
  Result := (Command^.Flags and 1) > 0;
end;

procedure SetImmediate(Command: PForthCommand; I: Boolean);
begin
  with Command^ do
    if I then
      Flags := Flags or 1
    else
      Flags := Flags and not 1
end;

function IsBuiltin(Command: PForthCommand): Boolean;
begin
  Result := (Command^.Flags and 2) > 0;
end;

procedure SetBuiltin(Command: PForthCommand; I: Boolean);
begin
  Command^.Flags := Command^.Flags or (Ord(I) shl 1);
  with Command^ do
    if I then
      Flags := Flags or 2
    else
      Flags := Flags and not 2
end;

function CopyStrToPChar(const B: TString): PChar;
begin
  Result := StrAlloc(Length(B) + 1);
  StrCopy(Result, PChar(B));
end;

procedure WordListClear(var WL: TWordSpace);
begin
  SetLength(WL.C, 0);
  WL.L := 0;
  WL.S := 0;
end;

function WordListInsert(var WL: TWordSpace; Command: PForthCommand): Integer;
begin
  SetLength(WL.C, Length(WL.C) + 1);
  WL.C[High(WL.C)] := Command;
  WL.L := Length(WL.C);
  Result := High(WL.C);
end;

function WordListFind(var WL: TWordSpace; B: TString; var Opcode: TOpcode): Boolean;
var
  I: Integer;
begin
  for I := WL.L - 1 downto 0 do
    if TString(WL.C[I]) = B then begin
      Result := True;
      Opcode := I;
      Exit;
    end;
  Result := False;
end;

{$IFNDEF FLAG_FPC}{$REGION 'TBoolCommands'}{$ENDIF}
procedure _bool_push;
var
  B: TInt;
begin
  with Machine do begin
    Machine.ReadEmbro(@B, SizeOf(B));
    Machine.WUI(B);
  end;
end;

{procedure compile_push;
var
  Name: TString;
begin
  with Machine do begin
    Name := Machine.NextName;
    if Name = 'true' then
      Machine.WriteEmbroInt(BOOL_TRUE)
    else if Name = 'false' then
      Machine.WriteEmbroInt(BOOL_FALSE)
    else
      Machine.CompileError('need bool constant, but "' + Name + '" found');
  end;
end;}

procedure _false;
begin
  with Machine do begin
    Machine.WUI(BOOL_FALSE);
  end;
end;

procedure _true;
begin
  with Machine do begin
    Machine.WUI(BOOL_TRUE);
  end;
end;

procedure _not;
//var
//  a: TInt;
begin
  with Machine do begin
    {Machine.WUI(a);
    if a = BOOL_FALSE then
      a := BOOL_TRUE
    else
      a := BOOL_FALSE;
    Machine.WUI(a);}
    Machine.WUI(not Machine.WOI);
  end;
end;

procedure _or;
var
  a, b: TInt;
begin
  with Machine do begin
    {Machine.WUI(a);
    Machine.WUI(b);
    if (a = BOOL_FALSE) and (b = BOOL_FALSE) then
      a := BOOL_FALSE
    else
      a := BOOL_TRUE;
    Machine.WUI(a);}
    Machine.WUI(Machine.WOI or Machine.WOI);
  end;
end;

procedure _and;
//var
//  a, b: TInt;
begin
  with Machine do begin
    {a := Machine.WOI;
    b := Machine.WOI;
    if (a = BOOL_FALSE) or (b = BOOL_FALSE) then
      a := BOOL_FALSE
    else
      a := BOOL_TRUE;
    Machine.WUI(a);}
    Machine.WUI(Machine.WOI and Machine.WOI);
  end;
end;

procedure _xor;
//var
//  a, b: TInt;
begin
  with Machine do begin
    {a := Machine.WOI;
    b := Machine.WOI;
    if (a = BOOL_FALSE) xor (b = BOOL_FALSE) then
      a := BOOL_TRUE
    else
      a := BOOL_FALSE;
    Machine.WUI(a);}
    Machine.WUI(Machine.WOI xor Machine.WOI);
  end;
end;

procedure _bool_dot;
var
  a: TInt;
begin
  with Machine do begin
    a := Machine.WOI;
    if a = 0 then
      Write('FALSE ')
    else
      Write('TRUE ')
  end;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TConsoleCommands'}{$ENDIF}
procedure cr;
begin
  with Machine do begin
    Writeln;
  end;
end;

procedure emit;
var
  I: Integer;
begin
  with Machine do begin
    //Machine.Stack.Pop(@I, SizeOf(I));
    Write(TChar(I));
  end;
end;

procedure space;
begin
  with Machine do begin
    Write(' ');
  end;
end;

procedure spaces;
var
  I: TInt;
begin
  with Machine do begin
    I := Machine.WOI;
    while I > 0 do begin
      SPACE(Machine, Command);
      Dec(I);
    end;
  end;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TControlCommands'}{$ENDIF}
procedure branch;
begin
  with Machine do begin
    Machine.EC := Machine.ERU;
  end;
end;

procedure _ask_branch;
var
  B: TInt;
  Temp: Cardinal;
begin
  with Machine do begin
    B := Machine.WOI;
    Temp := Machine.ERU;
    if B = BOOL_FALSE then
      Machine.EC := Temp;
  end;
end;

procedure _gt_mark;
var
  Temp: Cardinal;
begin
  with Machine do begin
    Temp := Machine.EL;
    Machine.WUU(Temp);
    Machine.EWU(Temp);
  end;
end;

procedure _gt_resolve;
var
  Temp: Cardinal;
  PC: Cardinal;
begin
  with Machine do begin
    Temp := Machine.WOU;
    PC := Machine.EL;
    Move(PC, Pointer(@Machine.E[Temp])^, SizeOf(PC));
  end;
end;

procedure _lt_mark;
var
  Temp: Cardinal;
begin
  with Machine do begin
    Temp := Machine.EL;
    Machine.WUU(Temp);
  end;
end;

procedure _lt_resolve;
var
  Temp: Cardinal;
  PC: Cardinal;
begin
  with Machine do begin
    Temp := Machine.WOU;
    Machine.EWU(Temp);
  end;
end;

procedure _exit;
begin
  with Machine do begin
    // Log('EXIT');
    if TUInt(Machine.RB) < TUInt(Machine.RP) then begin
      Machine.EC := Machine.ROI;
    end else if TUInt(Machine.RB) = TUInt(Machine.RP) then begin
      //Machine.EC := Length(Machine.FEmbro)
      Machine.RB := Machine.ROP;
      // Machine.FState := Machine.ROI;
      Machine.FRunning := False;
    end else begin
      Machine.LogError('[exit] R stack error (' +
                         IntToStr(TUInt(Machine.RP) - TUInt(Machine.RB)) + ')');
      Machine.FSession := False;
    end;
    Machine.LP := Machine.LB;
    Machine.LB := Machine.ROP;
  end;
end;

procedure recurse(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    Machine.EWO(Machine.FLastMnemonic);
  end;
end;

procedure call(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    // Writeln('INSIDE CALL "' + Command^.Name + '"');
    //Writeln('called function ' + Command^.Name);
    Machine.RUP(Machine.LB);
    Machine.LB := Machine.LP;
    if Machine.FRunning then
      Machine.RUI(Machine.EC)
    else begin
      // Machine.RUI(Machine.FState);
      Machine.RUP(Machine.RB);
      Machine.RB := Machine.RP;
    end;
    Machine.EC := Integer(Command^.Data);
    Machine.FRunning := True;
    // Writeln('WP = ', Cardinal(Machine.WP));
  end;
end;

procedure compile_def(Machine: TForthMachine; Command: PForthCommand);
var
  Name: TString;
  NewCommand: PForthCommand;
  PName: PChar;
begin
  with Machine do begin
    Name := Machine.NextName;
    PName := CopyStrToPChar(Name);
    NewCommand := Machine.ReserveName('');
    NewCommand^.Code := call;
    SetImmediate(NewCommand, False);
    Integer(NewCommand^.Data) := Machine.EL;
    Machine.FState := FS_COMPILE;
    Machine.LUI(Machine.FLastMnemonic);
    Machine.LUP(PName);
    Machine.LUI(101);
  end;
end;

procedure compile_noname(Machine: TForthMachine; Command: PForthCommand);
var
  NewCommand: PForthCommand;
begin
  with Machine do begin
    NewCommand := Machine.ReserveName('');
    NewCommand^.Code := call;
    SetImmediate(NewCommand, False);
    Integer(NewCommand^.Data) := Machine.EL;
    Machine.FState := FS_COMPILE;
    Machine.WUP(NewCommand);
    Machine.LUI(Machine.FLastMnemonic);
    Machine.LUP(Pointer(PChar('')));
    Machine.LUI(101);
  end;
end;

procedure compile_skip_to_end(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Integer(Machine.LP^) <> 101 then begin
      Machine.LogError('Нельзя использовать skip-to; внутри конструкций (на вершине стека не colon-id)');
      Exit;
    end;
    _gt_mark(Machine, nil);
    Machine.LUI(201);
  end;
end;

procedure compile_enddef(Machine: TForthMachine; Command: PForthCommand);
var
  B: TString;
  Index: TInt;
  P: PChar;
  ID: Integer;
begin
  with Machine do begin
    //B := str_pop(Machine, Command);
    //Machine.C[Machine.WOI]^.Name := PChar(TString(PChar(@TStrRec(B^).Sym[0])));
    //DelRef(B);
    ID := Machine.LOI;
    if ID = 201 then begin
      _gt_resolve(Machine, nil);
    end;
    P := Machine.LOP;
    Index := Machine.LOI;
    Machine.C[Index]^.Name := P;
    Machine.EWO('exit');
    Machine.FState := FS_INTERPRET;
    Machine.C[Index]^.Flags := Machine.C[Index]^.Flags and not 1;
    Machine.OnUpdateCommand(Index);
    //Writeln('LAST COMMAND ', High(Machine.C), ' ' + Machine.C[High(Machine.C)].Name);
  end;
end;

procedure compile_scattered_def(Machine: TForthMachine; Command: PForthCommand);
var
  Name: TString;
  C: PForthCommand;
begin
 // with Machine do begin
    Machine.FState := FS_COMPILE;
    Name := Machine.NextName;
    C := Machine.FindCommand(Name);
    if C = nil then begin
      Machine.LogError('Command not found: ' + Name);
      Exit;
    end;
    Machine.WUU(Cardinal((@Machine.E[Cardinal(C^.Param)])^));
    Cardinal((@Machine.E[Cardinal(C^.Param)])^) := Machine.EL;
    Machine.WUP(C);
 // end;
end;

procedure compile_scattered_enddef(Machine: TForthMachine; Command: PForthCommand);
var
  C: PForthCommand;
  P: Cardinal;
begin
 // with Machine do begin
    C := Machine.WOP;
    P := Cardinal(C^.Param);
    Machine.EWO('branch');
    Cardinal(C^.Param) := Machine.EL;
    Machine.EWU(Machine.WOU);
    Machine.FState := FS_INTERPRET;
 // end;
end;

procedure scattered_dots(Machine: TForthMachine; Command: PForthCommand); 
begin
  with Machine do begin
    Machine.EWO('branch');
    Cardinal(Machine.C[Machine.FLastMnemonic]^.Param) := Machine.EL;
    Machine.EWU(Machine.EL + SizeOf(TUInt));
  end;
end;

procedure immediate(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    SetImmediate(Machine.C[Machine.FLastMnemonic], True);
  end;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TEmbroCommands'}{$ENDIF}
procedure compile(Machine: TForthMachine; Command: PForthCommand);
var
  U: TUInt;
begin
  with Machine do begin
    //if Machine.State = FS_COMPILE then begin
      Machine.EWO('(compile)');
      Machine.EWO(Machine.NextName);
    //end else begin
    //  Machine.EWO(Machine.C[Machine.ERU].Name);
    //end;
  end;
end;

procedure q_compile_q(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    Machine.EWO(Machine.C[Machine.ERU].Name);
  end;
end;

procedure _execute(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    Machine.InterpretName(PChar(Machine.NextName));
  end;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TDataCommands'}{$ENDIF}
procedure _create(Machine: TForthMachine; Command: PForthCommand);
var
  Name: TString;
  NewCommand: PForthCommand;
begin
  with Machine do begin
    Name := Machine.NextName;
    NewCommand := Machine.ReserveName(Name);
    NewCommand^.Code := putdataptr;
    NewCommand^.Data := Machine.Here;
    Machine.OnUpdateCommand(NewCommand);
  end;
end;

procedure _created(Machine: TForthMachine; Command: PForthCommand);
var
  Name: TString;
  NewCommand: PForthCommand;
begin
  with Machine do begin
    Name := Machine.WOS;
    NewCommand := Machine.ReserveName(Name);
    NewCommand^.Code := putdataptr;
    NewCommand^.Data := Machine.Here;
    Machine.OnUpdateCommand(NewCommand);
  end;
end;

procedure putdataptr(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  with Machine do begin
    P := Command^.Data;
    Machine.WUP(P);
  end;
end;

procedure here(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  with Machine do begin
    // FIXME: P не постоянен
    P := Machine.Here;
    Machine.WUP(P);
  end;
end;

procedure allot(Machine: TForthMachine; Command: PForthCommand);
var
  I: Integer;
begin
  with Machine do begin
    I := Machine.WOI;
    Machine.IncHere(I);
  end;
end;

procedure to_int(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TInt))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TInt));
  end;
end;

procedure to_int8(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TInt8))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TInt8));
  end;
end;

procedure to_int16(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TInt16))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TInt16));
  end;
end;

procedure to_int32(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TInt32))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TInt32));
  end;
end;

procedure to_int64(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TInt64))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TInt64));
  end;
end;

procedure to_uint(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TUInt))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TUInt));
  end;
end;

procedure to_uint8(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TUInt8))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TUInt8));
  end;
end;

procedure to_uint16(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TUInt16))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TUInt16));
  end;
end;

procedure to_uint32(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TUInt32))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TUInt32));
  end;
end;

procedure to_uint64(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TUint64))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TUint64));
  end;
end;

procedure to_ptr(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(Pointer))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(Pointer));
  end;
end;

procedure compile_to;
begin
  with Machine do begin
    case Size of
      1: Machine.WriteMnemonicByName(' 8to');
      2: Machine.WriteMnemonicByName(' 16to');
      4: Machine.WriteMnemonicByName(' 32to');
      8: Machine.WriteMnemonicByName(' 64to');
    else
      Machine.WriteMnemonicByName(' to');
      Machine.WriteEmbroByte(Size);
    end;
    Machine.WriteMnemonicByName(Name);
  end;
end;

procedure interpete_to;
var
  C: PForthCommand;
  Temp: array of Byte;
begin
 // with Machine do begin
    C := Machine.FindCommand(Name);
    if C = nil then begin
      Machine.LogError('cannot find command ' + Name);
      Exit;
    end;
    SetLength(Temp, Size);
    // FIXME
    //Machine.(@Temp[0], Size);
    Move(Temp[0], C^.Data^, Size);
 // end;
end;

procedure _nil(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  with Machine do begin
    P := nil;
    Machine.WUP(nil);
  end;
end;

procedure ptr_comma(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  with Machine do begin
    P := Machine.WOP;
    Move(P, Machine.Here^, SizeOf(Pointer));
    Machine.IncHere(SizeOf(Pointer)); 
  end;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TTypeCommands'}{$ENDIF}
procedure typeof(machine: tforthmachine; command: pforthcommand);
var
  Name: TString;
  I: Integer;
  P: PType;
begin
  with Machine do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, PChar(Machine.NextName))
    else begin
      Name := Machine.NextName;
      for I := 0 to High(Machine.FTypes) do
        if TString(Machine.FTypes[I].Name) = Name then begin
          P := @Machine.FTypes[I];
          Machine.WUP(P);
          Exit;
        end;
      Machine.LogError('cannot find type "' + Name + '"');
    end;
  end;
end;

procedure type_size(Machine: TForthMachine; Command: PForthCommand);
var
  P: PType;
begin
  with Machine do begin
    P := Machine.WOP;
    Machine.WUI(P^.Size);
  end;
end;

procedure compile_type(Machine: TForthMachine; Name: PChar);
var
  I: Integer;
  P: PType;
begin
  with Machine do begin
    for I := 0 to High(Machine.FTypes) do
      if TString(Machine.FTypes[I].Name) = TString(Name) then begin
        Machine.EWO(' typeof');
        Machine.EWI(I);
        Exit;
      end;
    Machine.LogError('cannot find type "' + Name + '"');
  end;
end;

procedure interpete_type(Machine: TForthMachine; Name: PChar);
var
  I: Integer;
  P: PType;
begin
  with Machine do begin
    for I := 0 to High(Machine.FTypes) do
      if TString(Machine.FTypes[I].Name) = TString(Name) then begin
        Machine.WUP(@Machine.FTypes[I]);
        Exit;
      end;
    Machine.LogError('cannot find type "' + Name + '"');
  end;
end;

procedure run_type;
var
  I: TInt;
  P: PType;
begin
  with Machine do begin
    I := Machine.ERI;
    P := @Machine.FTypes[I];
    Machine.WUP(P);
  end;
end;

procedure _void(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'void')
    else
      interpete_type(Machine, 'void');
  end;
end;

procedure _int(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'int')
    else
      interpete_type(Machine, 'int');
  end;
end;

procedure _int8(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'int8')
    else
      interpete_type(Machine, 'int8');
  end;
end;

procedure _int16(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'int16')
    else
      interpete_type(Machine, 'int16');
  end;
end;

procedure _int32(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'int32')
    else
      interpete_type(Machine, 'int32');
  end;
end;

procedure _int64(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'int64')
    else
      interpete_type(Machine, 'int64');
  end;
end;

procedure _uint(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'uint')
    else
      interpete_type(Machine, 'uint');
  end;
end;

procedure _uint8(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'uint8')
    else
      interpete_type(Machine, 'uint8');
  end;
end;

procedure _uint16(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'uint16')
    else
      interpete_type(Machine, 'uint16');
  end;
end;

procedure _uint32(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'uint32')
    else
      interpete_type(Machine, 'uint32');
  end;
end;

procedure _uint64(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'uint64')
    else
      interpete_type(Machine, 'uint64');
  end;
end;

procedure _bool(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'bool')
    else
      interpete_type(Machine, 'bool');
  end;
end;

procedure _str(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'str')
    else
      interpete_type(Machine, 'str');
  end;
end;

procedure _pchar(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'pchar')
    else
      interpete_type(Machine, 'pchar');
  end;
end;

procedure _ptr(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'ptr')
    else
      interpete_type(Machine, 'ptr');
  end;
end;

procedure _type(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'type')
    else
      interpete_type(Machine, 'type');
  end;
end;

procedure _single(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'single')
    else
      interpete_type(Machine, 'single');
  end;
end;

procedure _double(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'double')
    else
      interpete_type(Machine, 'double');
  end;
end;

procedure _extended(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    if Machine.FState = FS_COMPILE then
      compile_type(Machine, 'extended')
    else
      interpete_type(Machine, 'extended');
  end;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TAlienCommands'}{$ENDIF}
procedure lib_load(Machine: TForthMachine; Command: PForthCommand);
var
  B: TString;
  L: TLib;
  I: TInt;
begin
  //with Machine do begin
    //Machine.FPtrStackCommands.Pop(@P);
    B := Machine.WOS;
    L := TLib.Create(PChar(B));   
    Machine.WUP(L);
    I := BOOL_TRUE * Ord(L.Ready) + BOOL_FALSE * Ord(not L.Ready);
    Machine.WUI(I);
  //end;
end;

procedure lib_unload(Machine: TForthMachine; Command: PForthCommand);
var
  L: TLib;
begin
  //with Machine do begin
    L := Machine.WOP;
    L.Free;
  //end;
end;

procedure lib_fun(Machine: TForthMachine; Command: PForthCommand);
var
  L: TLib;
  B: TString;
  P: Pointer;
begin
 // with Machine do begin
    B := Machine.WOS;
    L := Machine.WOP;
    P := L.GetProcAddress(PChar(B));
    // Machine.WUI(L);
    Machine.WUP(P);
 // end;
end;

procedure alien_fun(Machine: TForthMachine; Command: PForthCommand);
var
  Name: TString;
  C: PForthCommand;
  T: PType;
begin
 // with Machine do begin
    if Machine.State = FS_COMPILE then begin
      Machine.LogError(Command^.Name + ' command cannot work in compile mode');
      Exit;
    end;
    Name := Machine.NextName;
    New(C);
    C^.Name := StrAlloc(Length(Name) + 1);
    StrCopy(C^.Name, PChar(Name));
    //Log('Pushed command ' + C^.Name);
    Machine.WUP(C);
    T := @Machine.FTypes[0];
    Machine.WUP(T);
 // end;
end;

procedure Test1(A, B: Integer); stdcall;
begin
  Log('Test1 ' + IntToStr(A - B));
end;

function Test2(A, B: Integer): Integer; stdcall;
begin
  Log('Test2 ' + IntToStr(A - B));
  Result := A - B;
end;

function Test3(A, B: TInt64): TInt64; stdcall;
begin
  Log('Test3 ' + IntToStr(A - B));
  Result := A - B;
end;

procedure alien_endfun(Machine: TForthMachine; Command: PForthCommand);
var
  Conv: Integer;
  ReturnType: PType;
  T: PType;
  Types: array of PType;
  C, C2: PForthCommand;
  P: Pointer; 
  B: Byte;
  I: Integer;
  Small: TInt8;
begin
  //with Machine do begin
    if Machine.State = FS_COMPILE then begin
      Machine.LogError(Command^.Name + ' command cannot work in compile mode');
      Exit;
    end;
    Conv := Machine.WOI;
    ReturnType := Machine.WOP;
    T := Machine.WOP;
    SetLength(Types, 0);
    while T <> @Machine.FTypes[0] do begin
      //Log(IntToStr(Length(Types)) + ': ' + T^.Name);
      SetLength(Types, Length(Types) + 1);
      Types[High(Types)] := T;
      T := Machine.WOP;
    end;
    C2 := Machine.WOP;
    //Log('Poped command ' + C2^.Name);
    C := Machine.ReserveName(TString(C2^.Name));
    StrDispose(C2^.Name);
    Dispose(C2);
    if Conv = CONV_STDCALL then 
          begin
            C^.Code := invoke_stdcall;
            C^.Data := Machine.Here;
            if C^.Name = 'test1' then
              P := @Test1
            else if C^.Name = 'test2' then
              P := @Test2;
            Move(P, Machine.Here^, SizeOf(P));
            Machine.IncHere(SizeOf(P));
            B := ReturnType^.Size;
            if B <= 8 then begin
              Small := B;
              if Small > 4 then
                Small := 4;
              //Writeln('Return-size(1): ', Small);
              Move(Small, Machine.Here^, SizeOf(Small));
              Machine.IncHere(SizeOf(Small));
              B := B - Small;
              Small := B;
              if Small > 4 then
                Small := 4;
              //Writeln('Return-size(2): ', Small);
              Move(Small, Machine.Here^, SizeOf(Small));
              Machine.IncHere(SizeOf(Small));
              Small := 0;
              //Writeln('Return-size(3): ', Small);
              Move(Small, Machine.Here^, SizeOf(Small));
              Machine.IncHere(SizeOf(Small));
            end else begin
              Small := 0;
              Move(Small, Machine.Here^, SizeOf(Small));
              Machine.IncHere(SizeOf(Small));
              Small := 0;
              Move(Small, Machine.Here^, SizeOf(Small));
              Machine.IncHere(SizeOf(Small));
              Small := B;
              Move(Small, Machine.Here^, SizeOf(Small));
              Machine.IncHere(SizeOf(Small));
            end;
            for I := 0 to High(Types) do begin
              B := Types[I]^.Size;
              while B > 0 do begin
                Small := B mod 4;
                if Small = 0 then
                  Small := 4;
                B := B - Small;
                Small := -Small;
                Move(Small, Machine.Here^, SizeOf(Small));
                Machine.IncHere(SizeOf(Small));
              end;
            end;
            B := 0;
            Move(B, Machine.Here^, SizeOf(B));
            Machine.IncHere(SizeOf(B));
          end
    else if Conv = CONV_CDECL then 
          begin
            C^.Code := invoke_cdecl;
            C^.Data := Machine.Here;
            P := nil;
            Move(P, Machine.Here^, SizeOf(P));
          end
    else begin
      Machine.LogError(C^.Name + ' unknown code convension');
      Exit;
    end;
    //Log('Created command ' + C^.Name);
 // end;
end;

procedure __Callback(Machine: TForthMachine; Command: PForthCommand; DogWP: Pointer); stdcall;
begin
  // Writeln('** __Callback ** ', Cardinal(@Machine.WP), ' ', Cardinal(DogWP), ' ', Cardinal(Machine.WP), ' ', Cardinal(Pointer(Cardinal(Machine.WP)-SizeOf(Integer))^), ' ', Cardinal(Machine));
  // Command^.Code(Machine, Command);
  Machine.CallCommand(Command);
end;

procedure callback_fun;
var
  Name: TString;
  C: PForthCommand;
begin
 // with Machine do begin
    Name := Machine.NextName;
    New(C);
    C^.Name := StrAlloc(Length(Name) + 1);
    StrCopy(C^.Name, PChar(Name));
    Machine.WUP(C);
    Machine.WUP(@Machine.FTypes[0]);
 // end;
end;

procedure callback_endfun;
var
  Conv: Integer;
  ReturnType: PType;
  T: PType;
  Types: array of PType;
  NewC, C2: PForthCommand;
  XT: PForthCommand;
  Sizes: array of Integer;
  I: Integer;
  F: File;
begin
  with Machine do begin
    if Machine.State = FS_COMPILE then begin
      Machine.LogError(Command^.Name + ' command cannot work in compile mode');
      Exit;
    end;
    Conv := Machine.WOI;
    ReturnType := Machine.WOP;
    T := Machine.WOP;
    SetLength(Types, 0);
    while T <> @Machine.FTypes[0] do begin
      //Log(IntToStr(Length(Types)) + ': ' + T^.Name);
      SetLength(Types, Length(Types) + 1);
      Types[High(Types)] := T;
      T := Machine.WOP;
    end;
    C2 := Machine.WOP;
    //Log('Poped command ' + C2^.Name);
    NewC := Machine.ReserveName(TString(C2^.Name));
    StrDispose(C2^.Name);
    Dispose(C2);
    XT := WOP;
    NewC^.Code := PutDataPtr;
    SetLength(Sizes, Length(Types));
    for I := 0 to High(Types) do
      Sizes[I] := Types[I]^.Size;
    while (Integer(Machine.Here) mod 16) <> 6 do begin
      Byte(Machine.Here^) := 0;
      Machine.IncHere(1);
    end;
    // Machine.IncHere(22 - (Integer(Machine.Here) mod 16));
    // Writeln('AFTER INC HERE ', Integer(Machine.Here));
    NewC^.Data := Machine.Here;
    FAlien.GenerateCallback(Machine.Here, ES - EC, Sizes, ReturnType^.Size,
                            @Machine.WP, Machine, XT, @__Callback);
    // Writeln('@WP = ', TUInt(@Machine.WP), ' ', FAlien.MachineCode.GetError(nil), ' Machine=', Cardinal(Machine));
    Assign(F, 'generated.bin');
    Rewrite(F);
    BlockWrite(F, Machine.Here^, FAlien.MachineCode.Size);
    Close(F);
    Machine.IncHere(FAlien.MachineCode.Size);
    for I := 0 to 256 - 1 do begin
      Byte(Machine.Here^) := 0;
      Machine.IncHere(1);
    end;
  end;
end;

procedure invoke_stdcall(Machine: TForthMachine; Command: PForthCommand);
var
  Fun: Pointer;
  Stack: Pointer;
  Data: Pointer;
begin
  with Machine do begin
    Data := Command^.Data;
    Fun := Pointer(Command^.Data^);
    Stack := Machine.WP;
    asm
      mov ebx, Stack
      mov ecx, Data
      add ecx, 7 // пропускаем Fun и return-size
      jmp @startcycle
      @cycle:
        add ebx, eax
        push DWORD [ebx] // переносим очередной параметр на стек
        inc ecx
      @startcycle:
        movsx eax, BYTE [ecx] // получаем знаковое значение текущего байта
        cmp eax, 0
        jnz @cycle // если 0, то выходим из цикла
      @endcycle:
        mov Stack, ebx
        call [Fun] // вызываем функцию
        mov ebx,Stack
      @readeax:
        mov ecx,Data
        movsx ecx, BYTE [ecx+4] // нужно ли читать ecx
        cmp ecx, 0
        jz @readedx
        mov [ebx], eax
        add ebx, 4
      @readedx:
        mov ecx,Data
        movsx ecx, BYTE [ecx+5] // нужно ли читать edx
        cmp ecx, 0
        jz @readstack
        mov [ebx], edx
        add ebx, 4
      @readstack:
        mov ecx,Data
        movsx ecx, BYTE [ecx+6] // что читаем со стека
        cmp ecx, 0
        jz @endofcall
      @readstackloop:
        pop eax
        mov [ebx], eax
        add ebx, 4
        sub ecx, 4
        jnz @readstackloop
      @endofcall:
        mov Stack, ebx // запоминаем положение стека
    end;
    //Log('SUB: ' + IntToStr(TUInt(Machine.WP) - TUInt(Stack)));
    Machine.WP := Stack;
  end;
end;

procedure invoke_cdecl(Machine: TForthMachine; Command: PForthCommand);
begin
end;

procedure _conv_stdcall(Machine: TForthMachine; Command: PForthCommand);
begin
  Machine.WUI(CONV_STDCALL);
end;

procedure _conv_cdecl(Machine: TForthMachine; Command: PForthCommand);
begin
  Machine.WUI(CONV_CDECL);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TStringCommands'}{$ENDIF}
procedure pchar_alloc(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
  Size: Integer;
begin
  with Machine do begin
    Size := Machine.WOI;
    GetMem(P, Size + 1);
    Machine.WUP(P);
  end;
end;

procedure pchar_free(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  with Machine do begin
    P := Machine.WOP;
    FreeMem(P);
  end;
end;

procedure pchar_len(Machine: TForthMachine; Command: PForthCommand);
var
  P: PByte;
  L: Integer;
begin
  //with Machine do begin
    P := Machine.WOP;
    L := strlen(PChar(P));
    Machine.WUI(L);
 // end;
end;

procedure pchar_concat(Machine: TForthMachine; Command: PForthCommand);
var
  S1, S2, D: PChar;
begin
  with Machine do begin
    S2 := Machine.WOP;
    S1 := Machine.WOP;
    D := StrAlloc(StrLen(S1) + StrLen(S2) + 1);
    Move(S1^, D^, StrLen(S1));
    Move(S2^, (@(PArrayOfByte(D)^[StrLen(S1)]))^, StrLen(S2));
    D[StrLen(S1) + StrLen(S2)] := #0;
    Machine.WUP(D);
  end;
end;

procedure pchar_equel(Machine: TForthMachine; Command: PForthCommand);
var
  S1, S2: PChar;
begin
  with Machine do begin
    S1 := Machine.WOP;
    S2 := Machine.WOP;
    if StrComp(S1, S2) = 0 then
      Machine.WUI(BOOL_TRUE)
    else
      Machine.WUI(BOOL_FALSE)
  end;
end;

procedure pchar_dq(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
  C: TChar;
begin
 // with Machine do begin
    if Machine.FState = FS_COMPILE then begin
      compile_pchar_dq(Machine, Command);
    end else begin
      SetLength(Machine.FPChars, Length(Machine.FPChars) + 1);
      SetLength(Machine.FPChars[High(Machine.FPChars)], 0); 
      C := Machine.NextChar;
      while C <> '"' do begin
        SetLength(Machine.FPChars[High(Machine.FPChars)], Length(Machine.FPChars[High(Machine.FPChars)]) + 1); 
        Machine.FPChars[High(Machine.FPChars)][High(Machine.FPChars[High(Machine.FPChars)])] := C; 
        C := Machine.NextChar;
      end; 
      SetLength(Machine.FPChars[High(Machine.FPChars)], Length(Machine.FPChars[High(Machine.FPChars)]) + 1); 
      Machine.FPChars[High(Machine.FPChars)][High(Machine.FPChars[High(Machine.FPChars)])] := #0; 
      Machine.WUP(Machine.FPChars[High(Machine.FPChars)]);
    end;
 // end;
end;

procedure compile_pchar_dq(Machine: TForthMachine; Command: PForthCommand);
var
  C: TChar;
begin
 // with Machine do begin
    Machine.EWO(' pchar"');
    C := Machine.NextChar;
    while C <> '"' do begin
      Machine.EWC(C);
      C := Machine.NextChar;
    end;
    C := #0;
    Machine.EWC(C);
 // end;
end;

procedure run_pchar_dq(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
 // with Machine do begin
    P := @Machine.E[Machine.EC];
    Machine.WUP(P);
    while Machine.E[Machine.EC] <> 0 do
      Inc(Machine.EC);
    Inc(Machine.EC);
 // end;
end;

procedure pchar_dot(Machine: TForthMachine; Command: PForthCommand);
var
  B: PChar;
begin
  B := Machine.WOP;
  Write(B);
end;

procedure AddRef(B: TStr);
begin
  if B = nil then 
    Exit;
  Inc(PStrRec(B)^.Ref);
  //Machine.FMemoryDebug.Log(ToStr([' + str" ', PChar(@B^.Sym[0]), '" ', B^.Ref]));
end;

procedure DelRef(B: TStr);
begin
  if B = nil then 
    Exit;
  //Dec(PStrRec(B)^.Ref);
  if PStrRec(B)^.Ref < 1 then begin
    // Writeln('Free string "', PChar(@(PStrRec(B)^.Sym[0])), '"');
    FreeMem(B);
    //Machine.FMemoryDebug.Log(ToStr([' - str" ', PChar(@B^.Sym[0]), '" (free)']));
  end;// else
    //Machine.FMemoryDebug.Log(ToStr([' - str" ', PChar(@B^.Sym[0]), '" ', B^.Ref]));
end;

procedure str_push(Machine: TForthMachine; Command: PForthCommand; B: TString);
var
  FS: TStr;
begin
  with Machine do begin
    GetMem(FS, SizeOf(Integer)*2 + Length(B) + 1);
    PStrRec(FS)^.Len := Length(B);
    PStrRec(FS)^.Ref := 0;
    Move(B[1], PStrRec(FS)^.Sym[0], Length(B));
    PStrRec(FS)^.Sym[Length(B)] := #0;
    str_push(Machine, Command, FS);
  end;
end;

procedure str_push(Machine: TForthMachine; Command: PForthCommand; B: TStr);
begin
  with Machine do begin
    AddRef(B);
    Machine.WUP(B);
  end;
end;

function str_pop(Machine: TForthMachine; Command: PForthCommand): TStr;
begin
  with Machine do begin
    Result := Machine.WOP;
  end;
end;

procedure str_drop(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    DelRef(str_pop(Machine, Command));
  end;
end;

procedure str_dup(Machine: TForthMachine; Command: PForthCommand);
var
  B: TStr;
begin
  with Machine do begin
    //B := str_pop(Machine, Command);
    //str_push(Machine, Command, B);
    //str_push(Machine, Command, B);
    //DelRef(B);
    with MAchine do begin
      Pointer(Machine.WP^) := Pointer(WVar(-SizeOf(Pointer)));
      AddRef(TStr(WP^));
      Inc(WP, SizeOf(Pointer));
    end;
  end;
end;

procedure str_over(Machine: TForthMachine; Command: PForthCommand);
var
  A, B: TStr;
begin
  with Machine do begin
    B := str_pop(Machine, Command);
    A := str_pop(Machine, Command);
    str_push(Machine, Command, A);
    str_push(Machine, Command, B);
    str_push(Machine, Command, A);
    DelRef(A);
    DelRef(B);
  end;
end;


procedure str_len(Machine: TForthMachine; Command: PForthCommand);
var
  B: TStr;
begin
  with Machine do begin
    B := Machine.WOP;
    Machine.WUI(PStrRec(B)^.Len);
    DelRef(B);
  end;
end;

procedure str_dq(Machine: TForthMachine; Command: PForthCommand);
var
  C: TChar;
  Temp: array of Char;
  B: TStr;
begin
 // with Machine do begin
    //if Machine.FState = FS_COMPILE then begin
    //  compile_str_dq(Machine, Command);
    //end else begin
      SetLength(Temp, 0); 
      C := Machine.NextChar;
      while C <> '"' do begin
        SetLength(Temp, Length(Temp) + 1); 
        Temp[High(Temp)] := C; 
        C := Machine.NextChar;
      end; 
      GetMem(B, 2*SizeOf(TInt) + Length(Temp) + 1);
      PStrRec(B)^.Len := Length(Temp);
      PStrRec(B)^.Ref := 0;
      Move(Temp[0], PStrRec(B)^.Sym[0], Length(Temp));
      PStrRec(B)^.Sym[Length(Temp)] := #0;
      str_push(Machine, Command, B);
    //end;
 // end;
end;

procedure compile_str_dq(Machine: TForthMachine; Command: PForthCommand);
var
  C: TChar;
  E: Cardinal;
  L: Integer;
begin
 // with Machine do begin
    Machine.EWO('(str)"');
    Machine.EWI(1);
    E := Machine.EL;
    Machine.EWI(0);
    C := Machine.NextChar;
    L := 0;
    while C <> '"' do begin
      Machine.EWC(C);
      C := Machine.NextChar;
      Inc(L);
    end;
    Machine.EWC(#0);
    Move(L, Machine.E[E], SizeOf(TInt));
 // end;
end;

procedure run_str_dq(Machine: TForthMachine; Command: PForthCommand);
var
  B: TStr;
begin
 // with Machine do begin
    B := @Machine.E[Machine.EC];
    str_push(Machine, Command, B);
    Inc(Machine.EC, 2*SizeOf(TInt) + PStrRec(B)^.Len + 1);
 // end;
end;

procedure str_equel(Machine: TForthMachine; Command: PForthCommand);
var
  A, B: TStr;
  I: Integer;
begin
 // with Machine do begin
    B := str_pop(Machine, Command);
    A := str_pop(Machine, Command);
    if PStrRec(A)^.Len <> PStrRec(B)^.Len then
      Machine.WUI(BOOL_FALSE)
    else begin
      (* for I := 0 to PStrRec(A)^.Len - 1 do *)
      (*   if PStrRec(A)^.Sym[I] <> PStrRec(B)^.Sym[I] then begin *)
      (*     Machine.WUI(BOOL_FALSE); *)
      (*     DelRef(A); *)
      (*     DelRef(B); *)
      (*     Exit; *)
      (*   end; *)
      (* Machine.WUI(BOOL_TRUE); *)
      if StrComp(@PStrRec(A)^.Sym[0], @PStrRec(B)^.Sym[0]) = 0 then
        Machine.WUI(BOOL_TRUE)
      else
        Machine.WUI(BOOL_FALSE);
    end;
    DelRef(A);
    DelRef(B);
 // end;
end;

procedure str_concat(Machine: TForthMachine; Command: PForthCommand);
var
  A, B: TStr;
begin
 // with Machine do begin
    B := str_pop(Machine, Command);
    A := str_pop(Machine, Command);
    GetMem(B, 2*SizeOf(TInt) + PStrRec(A)^.Len + PStrRec(B)^.Len + 1);
    PStrRec(B)^.Ref := 0;
    PStrRec(B)^.Len := PStrRec(A)^.Len + PStrRec(B)^.Len;
    Move(PStrRec(A)^.Sym[0], PStrRec(B)^.Sym[0], PStrRec(A)^.Len);
    Move(PStrRec(B)^.Sym[0], PStrRec(B)^.Sym[PStrRec(A)^.Len], PStrRec(B)^.Len);
    PStrRec(B)^.Sym[PStrRec(B)^.Len] := #0;
    DelRef(A);
    DelRef(B);
    str_push(Machine, Command, B);
 // end;
end;

procedure str_nil(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    str_push(Machine, Command, @FStrNil);
  end;
end;

procedure str_dot(Machine: TForthMachine; Command: PForthCommand);
var
  I: Integer;
  B: TStr;
begin
  with Machine do begin
    B := str_pop(Machine, Command);
    I := 0;
    while I < PStrRec(B)^.Len do begin
      if PStrRec(B)^.Sym[I] = #13{'\'} then begin
        //if PStrRec(B)^.Sym[I+1] = 'n' then begin
          Writeln;
        //  Inc(I);
        //end;
      end else
        Write(PStrRec(B)^.Sym[I]);
      Inc(I);
    end;
    DelRef(B);
  end;
end;

procedure str_dollar(Machine: TForthMachine; Command: PForthCommand);
var
  P: TStr;
  B: TString;
begin
  with Machine do begin
    Read(B); 
    GetMem(P, 2*SizeOf(Integer) + Length(B) + 1);
    PStrRec(P)^.Ref := 0;
    PStrRec(P)^.Len := Length(B);
    Move(B[1], PStrRec(P)^.Sym[0], Length(B));
    PStrRec(P)^.Sym[Length(B)] := #0;
    str_push(Machine, Command, P);
  end;
end;

procedure str_dog(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    with Machine do begin
      Pointer(WVar(-SizeOf(Pointer))) := Pointer(Pointer(WVar(-SizeOf(Pointer)))^);
      AddRef(Pointer(WVar(-SizeOf(Pointer))));
    end;
  end;
end;

procedure str_exclamation(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    with Machine do begin
      DelRef(Pointer(Pointer(WVar(-SizeOf(Pointer)))^));
      Pointer(Pointer(WVar(-SizeOf(Pointer)))^) := Pointer(WVar(-2*SizeOf(Pointer)));
      Dec(WP, 2*SizeOf(Pointer));
      AddRef(Pointer(WP^));
    end;
  end;
end;

procedure pchar_to_str(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    Dec(Machine.WP, SizeOf(Pointer));
    Machine.WUS(TString(PChar(Machine.WP^)));
  end;
end;

procedure Format(Machine: TForthMachine; Command: PForthCommand);
var
  P: PChar;
  I, J: Integer;
  Sub: array of string;
  STemp: TStr;
begin
  with Machine do begin
    STemp := str_pop(Machine, Command);
    I := STemp^.Len;
    while I > 0 do begin
      Dec(I);
      SetLength(Sub, Length(Sub) + 1);
      if TChar(STemp^.Sym[I]) = '%' then begin
        if TChar(STemp^.Sym[I+1]) = '%' then begin
          Sub[High(Sub)] := '%';
        end else if TChar(STemp^.Sym[I+1]) = 's' then begin
          STemp := str_pop(Machine, Command);
          DelRef(STemp);
        end;
      end else begin
        J := I;
        while (J >= 0) and (TChar(STemp^.Sym[I+1]) <> '%') do
          Dec(J);
        SetLength(Sub[High(Sub)], I - J);
        I := J;
      end;
    end;
    DelRef(STemp);
  end;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TForthMachine'}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'folded'}{$ENDIF}
procedure TForthMachine.AddCommand(Name: PChar; Code: TCode; Immediate: Boolean = False; Builtin: Boolean = True);
begin
  SetLength(C, Length(C) + 1);
  New(C[High(C)]);
  C[High(C)].Name := StrAlloc(StrLen(Name)+1);
  StrCopy(C[High(C)].Name, Name);
  C[High(C)].Code := Code;
  SetImmediate(C[High(C)], Immediate);
  SetBuiltin(C[High(C)], Builtin);
  OnUpdateCommand(High(C));
end;

procedure TForthMachine.OnUpdateCommand(Opcode: Integer);
begin
  VocAdd(Target[High(Target)], Opcode);
  // Writeln('Add command ', C[Opcode]^.Name);
  if C[Opcode]^.Name = '_FIND_' then
    Target[High(Target)].sFIND := Opcode
  else if C[Opcode]^.Name = '_NOTFOUND_' then
    Target[High(Target)].sNOTFOUND := Opcode
end;

procedure TForthMachine.OnUpdateCommand(Command: PForthCommand);
var
  I: Integer;
begin
  for I := High(C) downto 0 do
    if C[I] = Command then begin
      OnUpdateCommand(I);
      Exit;
    end;
end;

procedure TForthMachine.CompileSource(Source: PChar);
var
  I: Integer;
begin
  FSource := Source;
  FCompilation := True;
  FState := FS_COMPILE;
  FCurrentChar := 0;
  while (not EOS) and FCompilation do begin
    FCurrentName := NextName;
    if FCurrentName = '' then
      Break;
    EWO(FCurrentName);
    CompileName(@FCurrentName[1]);
  end;
  //for I := 0 to High(FEmbro) do
  //  Write(IntToHex(FEmbro[I], 2), ' ');
  //Writeln;
  FCompilation := False;
end;

procedure _vocabulary(Machine: TForthMachine; Command: PForthCommand);
var
  V: PVoc;
begin
  with Machine do begin
    New(V);
    V^.Item := nil;
    V^.sFIND := -1;
    V^.sNOTFOUND := -1;
    WUP(V);
  end;
end;

procedure _vLOCAL(Machine: TForthMachine; Command: PForthCommand);
begin 
  with Machine do begin
    WUP(vLOCAL);
  end;
end;

procedure _vGLOBAL(Machine: TForthMachine; Command: PForthCommand);
begin 
  with Machine do begin
    WUP(vGLOBAL);
  end;
end;

procedure _TargetPush(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    TargetPush(WOP);
  end;
end;

procedure _TargetPop(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    WUP(TargetPop);
  end;
end;

procedure _ContextPush(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    ContextPush(WOP);
  end;
end;

procedure _ContextPop(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    WUP(ContextPop);
  end;
end;

procedure CompileComment(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    {( это для m4}
    while Machine.NextChar <> ')' do
      if Machine.EOS then begin
        {( это для m4 }CompileError('need ")", but end of source found');
        Break;
      end;
  end;
end;

procedure CompileLineComment(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    while Machine.NextChar <> #13 do
      if Machine.EOS then
        Break;
  end;
end;

function TForthMachine.NextMnemonic: Cardinal;
begin
  Result := Cardinal((@FEmbro[EC])^);
  Inc(EC, SizeOf(Cardinal));
end;

procedure TForthMachine.Run(Index: Integer);
var
  M: Cardinal;
  SavedState: Integer;
begin
  // Writeln('Deprecated code');
  LogError('Deprecated code');
  // Halt(-1);
end;

procedure TForthMachine.RunMnemonic(M: Cardinal);
begin
  //Writeln('RUN MNEMONIC "' + C[M].Name + '" ' + IntToStr(M) + ' EC:' + IntToStr(EC));
  // Writeln('RUN STEP "', C[M].Name, '"');
  if M = Cardinal(-1) then begin
    LogError('trying to run command with opcode -1');
    Exit;
  end;
  C[M].Code(Self, C[M]);
end;

procedure TForthMachine.RunCommand(Command: PForthCommand);
begin
  Command^.Code(Self, Command);
end;

procedure TForthMachine.RunError(const S: TString);
begin
  Error(' Runtime: ' + S);
  // FRunning := False;
end;

procedure TForthMachine.RunWarring(const S: TString);
begin
  Warrning('Runtime warring: ' + S);
end;

procedure TForthMachine.IncHere(Count: Integer);
begin
  //Inc(Here, Count);
  EA(Count);
  //if Length(FData) - FHere < 1024 then
  //  SetLength(FData, Length(FData) + 1024);
end;

procedure TForthMachine.AddType(const Name: TString; Size: Integer);
var
  Command: PForthCommand;
begin
  SetLength(FTypes, Length(FTypes) + 1);
  FTypes[High(FTypes)].Name := PChar(Name);
  FTypes[High(FTypes)].Size := Size;

  Command := ReserveName(Name);
  SetImmediate(Command, True);
  SetBuiltin(Command, True);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'E'}{$ENDIF}
procedure TForthMachine.EA(Size: Integer); // Embro Alloc
begin
  Inc(EL, Size);
end;

function TForthMachine.Here: Pointer;
begin
  Result := @E[EL];
end;

procedure _here(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine do begin
    Pointer(WP^) := @E[EL];
    Inc(WP, SizeOf(Pointer));
  end;
end;

procedure TForthMachine.EWV(V: Pointer; Size: Integer); // Embro Write Data
begin
  Move(V^, (@E[EL])^, Size);
  Inc(EL, Size);

  Inc(Chunks[High(Chunks)].Len, Size);
end;

procedure TForthMachine.EWI(V: Integer);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' ' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWE(V: TEmbroPtr);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' embro:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWO(V: TOpcode);
begin
  Move(V, (@E[EL])^, SizeOf(V));
  Inc(EL, SizeOf(V));

  SetLength(FEmbroDump, Length(FEmbroDump) + 1);
  FEmbroDump[High(FEmbroDump)] := C[V].Name + ' ';

  SetLength(Chunks, Length(Chunks) + 1);
  Chunks[High(Chunks)].Opcode := V;
  Chunks[High(Chunks)].Data := @E[EL];
  Chunks[High(Chunks)].Len := 0;
  Chunks[High(Chunks)].Count := 0;
  Chunks[High(Chunks)].Refs := nil;
  SetLength(Refs, Length(Refs) + 1);
  //Writeln('WRITE OPCODE: ' + IntToStr(V));
end;

procedure TForthMachine.EWO(V: TString);
var
  I: TOpcode;
begin
  for I := High(C) downto 0 do
    if TString(C[I].Name) = V then begin
      EWO(I);
      Exit;
    end;
  FSession := False;
  LogError('command "' + V + '" not found');
end;

procedure TForthMachine.EWR(V: TOpcode);
begin
  // TODO
end;

procedure TForthMachine.EWI8(V: TInt8);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' int8:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWI16(V: TInt16);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' int16:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWI32(V: TInt32);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' int32:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWI64(V: TInt64);
begin
  EWV(@V, SizeOf(V));
  
  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' int64:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWU(V: TUInt);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' u' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWU8(V: TUInt8);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' uint8:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWU16(V: TUInt16);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' uint16:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWU32(V: TUInt32);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' uint32:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWU64(V: TUInt64);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' uint64:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWC(V: Char);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + V;
end;

procedure TForthMachine.EWS(V: Single);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' s' + FloatToStr(V) + ' ';
end;

procedure TForthMachine.EWD(const V: Double);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' d' + FloatToStr(V) + ' ';
end;

procedure TForthMachine.EWExtended(const V: Extended);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' e' + FloatToStr(V) + ' ';
end;

procedure TForthMachine.EWPChar(V: PChar);
begin
  // TODO
end;

function CreateStr(const S: TString): TStr;
begin
  GetMem(Result, SizeOf(Integer)*2 + Length(S) + 1);
  PStrRec(Result)^.Ref := 0;
  PStrRec(Result)^.Len := Length(S);
  Move(S[1], PStrRec(Result)^.Sym[0], Length(S));
  PStrRec(Result)^.Sym[LengtH(S)] := #0;
end;

procedure TForthMachine.EWStr(V: TString);
var
  S: TStr;
begin
  S := CreateStr(V);
  PStrRec(S)^.Ref := 1;
  EWV(S, SizeOf(Integer)*2 + PStrRec(S)^.Len + 1);

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' "' + V + '" ';
end;

procedure TForthMachine.ERV(V: Pointer; Size: Integer);
begin
  Move((@E[EC])^, V^, Size);
  Inc(EC, Size);
end;

function TForthMachine.ERI: Integer;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERE: TEmbroPtr;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERO: TOpcode;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERI8: TInt8;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERI16: TInt16;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERI32: TInt32;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERI64: TInt64;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERU: TUInt;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERU8: TUInt8;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERU16: TUInt16;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERU32: TUInt32;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERU64: TUInt64;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERC: Char;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERS: Single;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERD: Double;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERExtended: Extended;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERPChar: PChar;
begin
  // TODO
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'D'}{$ENDIF}
{procedure TForthMachine.DA(Size: Integer);
begin
  Inc(Here, Size);
end;}
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'S'}{$ENDIF}
function TForthMachine.SE: Boolean;
begin
  Result := S[SC] = #0;
end;

function TForthMachine.SNC: TChar;
begin
  Result := S[SC];
  if not SE then
    Inc(SC);
end;

function TForthMachine.SNN: TString;
var
  C: TChar;
begin
  Result := '';
  repeat
    C := SNC;
  until (not (C in [#0..#32])) or SE;
  repeat
    Result := Result + C;
    if SE then
      Exit;
    C := SNC;
  until (C in [#0..#32]) or SE;
  if not (C in [#0..#32]) then
    Result := Result + C;
end;

procedure TForthMachine.SSS;
begin
  while (not SE) and (S[SC] in [#1..#32]) do
    SNC;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'R'}{$ENDIF}
procedure TForthMachine.RUV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(P^, RP^, Size);
  Inc(RP, Size);
end;

procedure TForthMachine.ROV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(RP^, P^, Size);
  Dec(RP, Size);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'W'}{$ENDIF}
procedure TForthMachine.CWU(C: Pointer);
begin
  Pointer(CWP^) := C;
  Inc(CWP, SizeOf(Pointer));
end;

function TForthMachine.CWO: Pointer;
begin
  Dec(CWP, SizeOf(Pointer));
  Result := Pointer(CWP^);
end;

procedure _CtoW(Machine: TForthMachine; Command: PForthCommand);
begin
  Machine.WUP(Machine.CWO);
end;

procedure _WtoC(Machine: TForthMachine; Command: PForthCommand);
begin
  Machine.CWU(Machine.WOP);
end;

procedure TForthMachine.WUV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(P^, WP^, Size);
  Inc(WP, Size);
end;

procedure TForthMachine.WOV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(WP^, P^, Size);
  Dec(WP, Size);
end;

procedure TForthMachine.WUS(const S: TString);
begin
  str_push(Self, nil, S);
end;

function TForthMachine.WOS: TString;
var
  S: PStrRec;
begin
  S := str_pop(Self, nil);
  Result := TString(PChar(@S^.Sym[0]));
  DelRef(S);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'L'}{$ENDIF}
procedure TForthMachine.LUV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(P^, LP^, Size);
  Inc(LP, Size);
end;

procedure TForthMachine.LOV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(LP^, P^, Size);
  Dec(LP, Size);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'L'}{$ENDIF}
procedure TForthMachine.ContextPush(V: PVoc);
begin
  SetLength(Context, Length(Context) + 1);
  Context[High(Context)] := V;
end;

function TForthMachine.ContextPop: PVoc;
begin
  if Length(Context) = 0 then
    Exit;
  Result := Context[High(Context)];
  if Length(Context) = 1 then begin
    LogError('trying to pop root context vocabulary');
    Exit;
  end;
  SetLength(Context, Length(Context) - 1);
end;

procedure TForthMachine.TargetPush(V: PVoc);
begin
  SetLength(Target, Length(Target) + 1);
  Target[High(Target)] := V;
end;

function TForthMachine.TargetPop: PVoc;
begin
  if Length(Target) = 0 then
    Exit;
  Result := Target[High(Target)];
  if Length(Target) = 1 then begin
    LogError('trying to pop root target vocabulary');
    Exit;
  end;
  SetLength(Target, Length(Target) - 1);
end;

procedure TForthMachine.UseVoc(V: PVoc);
begin
  TargetPush(V);
  ContextPush(V);
end;

procedure TForthMachine.UnuseVoc;
begin
  TargetPop;
  ContextPop;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}

constructor TForthMachine.Create;
begin
  GetMem(FStrNil, 2*SizeOf(TInt) + 1);
  PStrRec(FStrNil)^.Ref := 1;
  PStrRec(FStrNil)^.Len := 0;
  PStrRec(FStrNil)^.Sym := #0;

  SetLength(E, 1024 * 1024);
  EB := @E[0];
  EC := 0;
  EL := 0;
  ES := Length(E);
  SetLength(R,   16 * 1024);
  RB := @R[0];
  RP := RB;
  RS := Length(R);
  SetLength(W,   16 * 1024);
  WB := @W[0];
  WP := WB;
  WS := Length(W);
  SetLength(CW,  4 * 1024);
  CWB := @CW[0];
  CWP := CWB;
  CWS := Length(CW);
  SetLength(C,   0);
  CB := @C[0];
  CC := 0;
  CS := Length(C);
  WordListClear(Local);
  {SetLength(D, 1024 * 1024);
  DB := @D[0];
  Here := DB;
  DS := Length(D);}
  SetLength(L, 1024 * 1024);
  LB := @L[0];
  LP := LB;
  LS := Length(L);
  S  := nil;
  SC := 0;
  FUserData := nil;
  FState := FS_INTERPRET;
  SetLength(FData, 2048);
  //FHere := 0;
  FMemoryDebug := TDebug.Create('memory.tmp');
  FMemoryDebug.Console := False;

  FAlien := TAlien.Create;

  new(vGLOBAL);
  new(vLOCAL);
  vGLOBAL^.Item := nil;
  vLOCAL^.Item := nil;
  vGLOBAL^.sFIND := -1;
  vGLOBAL^.sNOTFOUND := -1;
  vLOCAL^.sFIND := -1;
  vLOCAL^.sNOTFOUND := -1;
  UseVoc(vGLOBAL);
  ContextPush(vLOCAL);
  // it must have zero opcode
  AddCommand('exit', _exit);
  AddCommand('_FIND_', _FIND_);
  AddCommand('_NOTFOUND_', _NOTFOUND_);
  AddCommand('vocabulary-new', _vocabulary);
  AddCommand('vLOCAL', _vLOCAL);
  AddCommand('vGLOBAL', _vGLOBAL);
  AddCommand('target<', _TargetPush);
  AddCommand('target>', _TargetPop);
  AddCommand('context<', _ContextPush);
  AddCommand('context>', _ContextPop);

  SetLength(FTypes, 0);
  all_create;
  AddType('', 0);
  AddType('void', 0);
  AddType('int', SizeOf(TInt));
  AddType('int8', SizeOf(TInt8));
  AddType('int16', SizeOf(TInt16));
  AddType('int32', SizeOf(TInt32));
  AddType('int64', SizeOf(TInt64));
  AddType('uint', SizeOf(TUInt));
  AddType('uint8', SizeOf(TUInt8));
  AddType('uint16', SizeOf(TUInt16));
  AddType('uint32', SizeOf(TUInt32));
  AddType('uint64', SizeOf(TUInt64));
  AddType('bool', SizeOf(TInt));
  AddType('ptr', SizeOf(Pointer));
  AddType('pchar', SizeOf(PChar));
  AddType('str', SizeOf(TStr));
  AddType('type', SizeOf(PType));
  AddType('single', SizeOf(PType));
  AddType('double', SizeOf(PType));
  AddType('extended', SizeOf(PType));

  AddCommand('exit', _exit);
  AddCommand('(', CompileComment, True); {) для m4}
  AddCommand('//', CompileLineComment, True);
{$IFNDEF FLAG_FPC}{$REGION 'control commands'}{$ENDIF}
  AddCommand(':', compile_def);
  AddCommand(':noname', compile_noname);
  AddCommand(';', compile_enddef, True);
  AddCommand('skip-to;', compile_enddef, True);
  AddCommand('...', scattered_dots, True);
  AddCommand('..:', compile_scattered_def);
  AddCommand(';..', compile_scattered_enddef, True);
  AddCommand('branch', branch);
  AddCommand('?branch', _ask_branch);
  AddCommand('>mark', _gt_mark);
  AddCommand('>resolve', _gt_resolve);
  AddCommand('<mark', _lt_mark);
  AddCommand('<resolve', _lt_resolve);
  AddCommand('recurse', recurse, True);
  AddCommand('immediate', immediate);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'embro commands'}{$ENDIF}
  AddCommand('compile', compile, True);
  AddCommand('(compile)', q_compile_q, True);
  AddCommand('evaluate', Evaluate);
  ~AddCommand('evaluate-file', EvaluateFile);|
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'data commands'}{$ENDIF}
  AddCommand('nil', _nil);
  AddCommand('ptr,', ptr_comma);

  AddCommand('create', _create);
  AddCommand('created', _created);
  AddCommand('here', _here);
  AddCommand('allot', allot);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'bool'}{$ENDIF}
  AddCommand('bool-push', _bool_push, True);
  AddCommand('bool-false', _false);
  AddCommand('bool-true', _true);
  AddCommand('bool-not', _not);
  AddCommand('bool-or', _or);
  AddCommand('bool-and', _and);
  AddCommand('bool-xor', _xor);
  AddCommand('bool.', _bool_dot);
  AddCommand('false', _false);
  AddCommand('true', _true);
  AddCommand('not', _not);
  AddCommand('or', _or);
  AddCommand('and', _and);
  AddCommand('xor', _xor);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'type commands'}{$ENDIF}
  AddCommand('typeof', typeof, True);
  AddCommand(' typeof', run_type);
  AddCommand('type-size', type_size);
  AddCommand('t_void', _void, True);
  AddCommand('t_int', _int, True);
  AddCommand('t_int8', _int8, True);
  AddCommand('t_int16', _int16, True);
  AddCommand('t_int32', _int32, True);
  AddCommand('t_int64', _int64, True);
  AddCommand('t_uint', _uint, True);
  AddCommand('t_uint8', _uint8, True);
  AddCommand('t_uint16', _uint16, True);
  AddCommand('t_uint32', _uint32, True);
  AddCommand('t_uint64', _uint64, True);
  AddCommand('t_bool', _bool, True);
  AddCommand('t_str', _str, True);
  AddCommand('t_pchar', _pchar, True);
  AddCommand('t_ptr', _ptr, True);
  AddCommand('t_type', _type, True);
  AddCommand('t_single', _single, True);
  AddCommand('t_double', _double, True);
  AddCommand('t_extended', _extended, True);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'alien commands'}{$ENDIF}
  AddCommand('lib-load', lib_load);
  AddCommand('lib-unload', lib_unload);
  AddCommand('lib-fun', lib_fun);
  AddCommand(':a', alien_fun);
  AddCommand('a;', alien_endfun);
  AddCommand(':c', callback_fun);
  AddCommand('c;', callback_endfun);
  AddCommand('stdcall', _conv_stdcall);
  AddCommand('cdecl', _conv_cdecl);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'string commands'}{$ENDIF}
  AddCommand('pchar"', pchar_dq, True);
  AddCommand(' pchar"', run_pchar_dq);
  AddCommand('pchar.', pchar_dot);
  AddCommand('pchar-alloc', pchar_alloc);
  AddCommand('pchar-free', pchar_free);
  AddCommand('pchar-len', pchar_len);
  AddCommand('pchar-concat', pchar_concat);
  AddCommand('pchar=', pchar_equel);

  AddCommand('str"', str_dq);
  AddCommand('[str]"', compile_str_dq, True);
  AddCommand('(str)"', run_str_dq);
  AddCommand('str.', str_dot);
  AddCommand('str$', str_dollar);
  AddCommand('str@', str_dog);
  AddCommand('str!', str_exclamation);
  AddCommand('str#', str_len);
  AddCommand('str=', str_equel);
  AddCommand('str0', str_nil);
  AddCommand('str+', str_concat);
  AddCommand('str-drop', str_drop);
  AddCommand('str-dup', str_dup);
  AddCommand('str-swap', swap_ptr);
  AddCommand('str-over', str_over);
  AddCommand('str-rot', lrot_ptr);
  AddCommand('str-lrot', lrot_ptr);
  AddCommand('str-rrot', rrot_ptr);
  AddCommand('str-lrotn', lrotn_ptr);
  AddCommand('str-rrotn', rrotn_ptr);
  AddCommand('pchar->str', pchar_to_str);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'console commands'}{$ENDIF}
  AddCommand('cr', cr);
  AddCommand('emit', emit);
  AddCommand('space', space);
  AddCommand('spaces', spaces);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
  regist_all_commands;
end;

destructor TForthMachine.Destroy; 
begin
  all_free;
  FAlien.Free;
  FMemoryDebug.Free;
end;

procedure TForthMachine.InterpretName(W: PChar);
var
  I: Integer;
  Command: PForthCommand;
  S: TString;
  //Time: Integer;
begin
  // Writeln('INTERPRET ', W);
  (* for I := High(C) downto 0 do *)
  (*   if StrComp(C[I].Name, W) = 0 then begin *)
  (*     //Writeln('START ' + W); *)
  (*     C[I].Code(Self, C[I]); *)
  (*     // Writeln('DONE ' + W); *)
  (*     Exit; *)
  (*   end; *)
  S := W;
  Command := FindCommand(S);
  // Writeln('FOUND COMMAND: ', Integer(Command));
  if Command <> nil then begin
    // Writeln('INTERPRET COMMAND ', Command^.Name);
    Command.Code(Self, Command);
    Exit;
  end;
  //Time := GetTimer;
  for I := High(Context) downto 0 do begin
    if Context[I]^.sNOTFOUND = -1 then
      continue;
    WUS(S);
    CallCommand(C[Context[I]^.sNOTFOUND]);
    if WOI = 0 then
      Exit;
  end;
  LogError('unknown command "' + S + '"');
end;

function TForthMachine.CompileName(W: PChar): Boolean;
var
  I: Integer;
  Command: PForthCommand;
begin
  Command := FindCommand(W, @I);
  if Command <> nil then begin
    if IsImmediate(C[I]) then
      C[I].Code(Self, C[I])
    else
      EWO(I);
    Exit;
  end;
  (* for I := High(C) downto 0 do *)
  (*   if StrComp(C[I].Name, W) = 0 then begin *)
  (*     if IsImmediate(C[I]) then *)
  (*       C[I].Code(Self, C[I]) *)
  (*     else *)
  (*       EWO(I); *)
  (*     Exit; *)
  (*   end; *)
  if ConvertStrToInt(W, I) <> 0 then
    LogError('Unknown command: ' + W)
  else begin
    EWO('(literal)');
    EWI(I);
  end;
end;

procedure TForthMachine.Interpret(const S: PChar);
begin
  if S = nil then
    Exit;
  (* Writeln('RB=', Cardinal(RB), *)
  (*         ' RP=', Cardinal(RP),  *)
  (*         ' SC=', SC,  *)
  (*         ' EC=', EC, *)
  (*         ' S=', S); *)
  RUI(FState);
  RUI(Ord(FSession) * BOOL_TRUE);
  RUI(Ord(FRunning) * BOOL_TRUE);
  RUI(EC);
  RUP(Self.S);
  RUI(SC);
  RUP(RB);
  Self.S := S;
  //Self.SB := S;
  Self.SC := 0;
  FState := FS_INTERPRET;
  FSession := True;
  FRunning := False;
  MainLoop;
  RB := ROP; 
  SC := ROI;
  Self.S  := ROP;
  EC := ROI;
  FRunning := ROI <> BOOL_FALSE;
  FSession := ROI <> BOOL_FALSE;
  // Writeln('RB=', Cardinal(RB), ' SC=', SC, ' S=', Integer(S), ' EC=', EC);
  FState := ROI;
end;

procedure TForthMachine.InterpretFile(const FileName: TString);
var
  F: TextFile;
  S: TString;
  B: TString;
  T: TString;
begin
  S := FileName;
  Assign(F, S);
  {$I-}
  Reset(F);
  {$I+}
  if IOResult <> 0 then begin
    LogError('cannot open file "' + S + '"');
    Exit;
  end;
  B := '';
  while not EOF(F) do begin
    Readln(F, T);
    B := B + T + EOL;
  end;
  Close(F);
  Interpret(PChar(B));
end;

procedure Evaluate(Machine: TForthMachine; Command: PForthCommand);
var
  S: TStr;
begin
  S := str_pop(Machine, Command);
  Machine.Interpret(PChar(@(PStrRec(S)^.Sym[0])));
  DelRef(S);
end;

procedure EvaluateFile(Machine: TForthMachine; Command: PForthCommand);
var
  //F: File of Byte;
  F: TextFile;
  S: TStr;
  //B: array of Byte;
  B: TString;
  T: TString;
begin
  S := str_pop(Machine, Command);
  // Writeln('Evaluate file "', PChar(@(PStrRec(S)^.Sym[0])), '"');
  Assign(F, PChar(GetCurrentDirectory) + '\' + PChar(@(PStrRec(S)^.Sym[0])));
  {$I-}
  Reset(F);
  {$I+}
  if IOResult <> 0 then begin
    Assign(F, PChar(GetExeDirectory) + '\' + PChar(@(PStrRec(S)^.Sym[0])));
    {$I-}
    Reset(F);
    {$I+}
    if IOResult <> 0 then begin
      Machine.LogError('cannot open file "' + PChar(@(PStrRec(S)^.Sym[0])) + '"');
      Exit;
    end;
  end;
  B := '';
  while not EOF(F) do begin
    Readln(F, T);
    B := B + T + EOL;
  end;
  Close(F);
  Machine.Interpret(PChar(B));
  DelRef(S);
  // Writeln('End of evaluate file "', PChar(@S^.Sym[0]), '"');
end;

procedure TForthMachine.CallCommand(Command: PForthCommand);
begin
  if Command = nil then
    Exit;
  // Writeln('Call command ', Command^.Name);
  RUI(Ord(FSession) * BOOL_TRUE);
  RUI(Ord(FRunning) * BOOL_TRUE);
  RUI(EC);
  RUP(RB);
  RUP(RP);
  RB := RP;
  FSession := True;
  FRunning := False;
  Command^.Code(Self, Command);
  if FRunning then
    MainLoop;
  RP := ROP;
  RB := ROP; 
  EC := ROI;
  FRunning := ROI <> BOOL_FALSE;
  FSession := ROI <> BOOL_FALSE;
  // Writeln('Command done');
end;

procedure TForthMachine.MainLoop;
begin
  while FSession do begin
    //Writeln('MainLoop');
    if FRunning then
      RunStep
    else
      case FState of
        FS_INTERPRET: InterpretStep;
        FS_COMPILE:   CompileStep;
      else
        LogError('Illegal FState');
        FSession := False;
      end;
    // Writeln('Main Loop FState="', FState, '" FRunning="', FRunning, '"');
  end;
end;

procedure TForthMachine.InterpretStep;
begin
  // Writeln('INTERPRET STEP');
  SSS;
  if SE then begin
    FSession := False;
  end else
    InterpretName(PChar(SNN));
end;

procedure TForthMachine.CompileStep;
begin
  // Writeln('COMPILE STEP');
  SSS;
  if SE then
    FSession := False
  else
    CompileName(PChar(SNN));
end;

procedure TForthMachine.RunStep;
begin
  RunMnemonic(ERO);
end;

procedure TForthMachine.CompileError(const S: TString);
begin
  Error(' Compilation: "' + S + '"');
  FCompilation := False;
end;

procedure TForthMachine.CompileWarring(const S: TString);
begin
  Warrning(' Compilation: "' + S + '"');
end;

procedure TForthMachine.LogError(const S: TString);
begin
  if FState = FS_COMPILE then
    CompileError(S)
  else
    RunError(S);
end;

function TForthMachine.NextChar: TChar;
begin
  Result := SNC;
  {if EOS then
    Result := #0
  else begin
    Result := FSource[FCurrentChar];
    Inc(FCurrentChar);
  end;}
end;

function TForthMachine.NextName: TString;
var
  C: TChar;
begin
  Result := SNN;
  {Result := '';
  repeat
    C := NextChar;
  until (not (C in [#0..#32])) or EOS;
  repeat
    Result := Result + C;
    if EOS then
      Exit;
    C := NextChar;
  until (C in [#0..#32]) or EOS;
  if not (C in [#0..#32]) then
    Result := Result + C;}
end;

function TForthMachine.NextName(S: PChar; var I: Integer): TString;
var
  C: TChar;
begin
  Result := '';
  repeat
    C := S[I];
    if C <> #0 then
      Inc(I);
  until (not (C in [#0..#32])) or (C = #0);
  repeat
    Result := Result + C;
    if S[I] = #0 then
      Exit;
    C := S[I];
    if C <> #0 then
      Inc(I);
  until (C in [#0..#32]) or (C = #0);
  if not (C in [#0..#32]) then
    Result := Result + C;
end;

function TForthMachine.NextNamePassive: TString;
var
  Temp: Integer;
begin
  Temp := SC;
  Result := NextName(S, Temp);
end;

function TForthMachine.EOS: Boolean; // end of source
begin
  Result := SE;
  //Result := FSource[FCurrentChar] = #0;
end;

procedure TForthMachine.WriteEmbro(P: Pointer; Size: Integer);
begin
  SetLength(FEmbro, Length(FEmbro) + Size);
  Move(P^, FEmbro[Length(FEmbro) - Size], Size);
end;

procedure TForthMachine.WriteEmbroInt(I: Integer);
begin
  WriteEmbro(@I, SizeOf(I));
  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' ' + IntToStr(I) + ' ';
end;

procedure TForthMachine.WriteEmbroUInt(U: Cardinal);
begin
  WriteEmbro(@U, SizeOf(U));
  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' u' + IntToStr(U) + ' ';
end;

procedure TForthMachine.WriteEmbroChar(C: Char);
begin
  WriteEmbro(@C, SizeOf(C));
  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + '''' + IntToHex(Ord(C), 2);
end;

procedure TForthMachine.WriteEmbroByte(B: Byte);
begin
  WriteEmbro(@B, SizeOf(B));
  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + 'b' + IntToHex(Ord(B), 2);
end;

procedure TForthMachine.PopEmbro(P: Pointer; Size: Integer);
begin
  Move(FEmbro[Length(FEmbro) - Size], P^, Size);
  SetLength(FEmbro, Length(FEmbro) - Size);
end;

procedure TForthMachine.WriteMnemonic(M: Cardinal);
begin
  WriteEmbro(@M, SizeOf(M));
  SetLength(FEmbroDump, Length(FEmbroDump) + 1);
  FEmbroDump[High(FEmbroDump)] := C[M].Name + ' ';
end;

procedure TForthMachine.WriteMnemonicByName(const Name: TString);
var
  I: Integer;
begin
  //Writeln('Write mnemonic by name ' + Name);
  for I := High(C) downto 0 do
    if TString(C[I].Name) = Name then begin
      WriteMnemonic(I);
      Exit;
    end;
  (* I := StrToIntDef(Name, -3535); *)
  (* if I = -3535 then *)
  (*   CompileError('Unknown name "' + Name + '"') *)
  (* else begin *)
  (*   WriteMnemonicByName('int-push'); *)
  (*   WriteEmbroInt(I); *)
  (* end; *)
  if ConvertStrToInt(Name, I) <> 0 then
    LogError('Unknown command: ' + Name)
  else begin
    EWO('(literal)');
    EWI(I);
  end;
end;

function TForthMachine.GetOpcodeByName(const Name: TString): TMnemonic;
var
  I: Integer;
begin
  for I := High(C) downto 0 do
    if TString(C[I].Name) = Name then begin
      //Writeln(I);
      Result := I;
      Exit;
    end;
  Result := 0;
end;

function TForthMachine.GetCommandByOpcode(Opcode: Integer): PForthCommand;
begin
  //Writeln(Opcode);
  Result := C[Opcode];
end;

procedure TForthMachine.CancelMnemonic;
begin
  SetLength(FEmbro, Length(FEmbro) - SizeOf(Cardinal));
end;

function TForthMachine.ReserveName(const Name: TString): PForthCommand;
var
  I: Integer;
begin
  FLastMnemonic := -1;
  {{for I := 0 to High(C) do
    if TString(C[I].Name) = Name then begin
      Result := C[I];
      FLastMnemonic := I;
      Break;
    end;}
  if FLastMnemonic = -1 then begin
    SetLength(C, Length(C) + 1);
    New(C[High(C)]);
    C[High(C)].Name := StrAlloc(Length(Name)+1);
    StrCopy(C[High(C)].Name, PChar(Name));
  end;
  SetImmediate(C[High(C)], False);
  C[High(C)].Code := call;
  FLastMnemonic := High(C);
  Result := C[High(C)];
  if Name <> '' then
    OnUpdateCommand(High(C));
end;

procedure TForthMachine.ReadEmbro(P: Pointer; Size: Integer);
begin
  Move(FEmbro[EC], P^, Size);
  Inc(EC, Size);
end;

function TForthMachine.ReadMnemonic: TMnemonic;
begin
  ReadEmbro(@Result, SizeOf(TMnemonic));
end;

function TForthMachine.GetEmbroDumpLines: Integer;
begin
  Result := Length(FEmbroDump);
end;

function TForthMachine.GetEmbroDumpLine;
begin
  Result := FEmbroDump[Index];
end;

procedure _FIND_(Machine: TForthMachine; Command: PForthCommand);
var
  B: TString;
  I: Integer;
  Item: PVocItem;
begin
  with Machine do begin
    B := WOS;
    with Machine do begin
      for I := High(Context) downto 0 do begin
        Item := Context[I].Item;
        while Item <> nil do begin
          if TString(C[Item^.Index]^.Name) = B then begin
            //Writeln('FOUND ', Item^.Index, ' ', C[Item^.Index]^.Name);
            WUI(Item^.Index);
            WUI(0);
            Exit;
          end;
          Item := Item^.Next;
        end;
      end;
      // Writeln('_FIND_(', B, ')');
      //for I := High(C) downto 0 do
      //  if TString(C[I].Name) = B then begin
      //    WUI(I);
      //    WUI(0);
      //    // Writeln('_FIND_(', B, ') done');
      //    Exit;
      //  end;
      WUI(-1);
      // Writeln('_FIND_(', B, ') failed');
    end;
  end;
end;

procedure _NOTFOUND_(Machine: TForthMachine; Command: PForthCommand);
var
  B: TString;
  I: Integer;
begin
  with Machine do begin
    B := Machine.WOS;
    // Writeln('_NOTFOUND_(', B, ')');
    if ConvertStrToInt(B, I) = 0 then begin
      WUI(I);
      WUI(BOOL_FALSE);
      Exit;
    end;
    WUI(BOOL_TRUE);
  end;
end;

function TForthMachine.FindCommand(const Name: TString; Index: PInteger = nil): PForthCommand;
var
  I: Integer;
begin
  I := High(Context);
  while I >= 0 do
    if Context[I].sFIND = -1 then
      Dec(I)
    else
      Break;
  // Writeln('I = ', I);
  if I <> -1 then begin
    WUS(Name);
    CallCommand(C[Context[I].sFIND]);
    if WOI = 0 then begin
      if Index <> nil then begin
        Index^ := WOI;
        Result := C[Index^];
      end else
        Result := C[WOI];
    end else begin
      Result := nil;
    end;
  end else
    Result := nil;
  // if Result = nil then
  //   Writeln('Command not found');
  {for I := High(C) downto 0 do
    if TString(C[I].Name) = Name then begin
      //Writeln('Found command ', C[I].Name);
      Result := C[I];
      Exit;
    end;
  Result := nil;}
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
// ( Вся соль :)
all_implement

end.

{
var
  testptr,param:pointer;
  mm:TMemoryStream;
  i,paramsize:integer;
begin
  testptr:=@test;
  mm:=TMemoryStream.Create;
// в обратном порядке кидаю параметры в память
  i:=20;
  mm.Write(i,sizeof(i));
  i:=10;
  mm.Write(i,sizeof(i));
// здесь надо кидать по 4 байта - или указатель, или значение.
  mm.Position:=0;
  paramsize:=mm.Size;
  param:=mm.Memory;
  asm
    mov eax,0
    mov ecx,0
    lab:
    mov ebx,[Param+ecx]
    // получаю значение под указателем
    // если этого не сделать, то положим указатель на память вместо значения.
    mov ebx,[ebx]
    // в стек
    push ebx
    add ecx,4
    cmp ecx,ParamSize
    jne lab
    // сам вызов
    call [testptr]
  end;
    mov eax, work
    mov ecx, param
    cycle:
      mov ebx, BYTE [ecx] // получаем значение текущего байта
      jz endcycle // если 0, то выходим из цикла
      push [eax] // переносим очередной параметр на стек
      sub eax, ebx // сдвигаем указатели
      inc ecx
      jmp cycle // повторяем операцию
    endcycle:
      inc ecx
      call [ecx] // вызываем функцию
      add ecx, 4
      pop [eax] // переносим результат на рабочий стек форта
      add eax, BYTE [ecx]
      mov work, eax // сменяем положение стека
end;




Чистить стек можно с помощью любого регистра pop-ами, а можно сделать проще - просто сохранить esp где ни будь и восстановить. Вобще то любую переменную больше 4 байт обычно передают по адресу, так как она уже является массивом и считывать ее придется уже побайтово, тоесть инкрементируя адрес. Но я правда не уверен насчет языков высокого уровня, что там из себя представляют переменные. Я бы делал для надежности так :
int a;
LEA eax,a
mov ebx,[eax]
ну это конечно утрировано, но зато надежно.

mov ebx,[Param+ecx]
mov ebx,[ebx]

Вот в эту шаманскую песенку я не вкурил. [Param+ecx] это уже ваша переменная со смещением, двойное слово. Или там в param список адресов? 





В param - адрес на память, где находятся параметры.
param:=mm.Memory;

сначала ecx=0, с каждым проходом цикла он увеличивается на 4
add ecx,4

и так пока ecx не станет равным ParamSize - общей сумме размеров параметров.

а что такое
LEA eax,a
mov ebx,[eax]
? для типа extended не работает - он передается как 2 dword и один word.
Например, для (-5.5):
push $0000c001
push $b0000000
push $00
из CPU-debug. 

}
))))))))))))))))))))))))))))))))))))))))))))))))
_out
