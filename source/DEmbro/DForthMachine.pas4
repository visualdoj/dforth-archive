_file(
unit DForthMachine;

interface

uses
  {$I units.inc},

  Math,
  strings,
  DForthStack;

const
  DFORTHMACHINE_VERSION = 11;

dnl define(~_comma|, ~~,||)
define(~all_implement|, ~|)
define(~regist_all_commands|, ~|)
define(~all_create|, ~|)
define(~all_free|, ~|)
define(~cmdhdr|, ~(Machine: TForthMachine; Command: PForthCommand)|)
define(~WVar|, ~(Pointer(TUInt(WP) + ($1))^)|)
define(~WInc|, ~Inc(WP, $1)|)
define(~WDec|, ~Dec(TUInt(WP), $1)|)
define(~PSize|, ~(SizeOf(Pointer))|)
define(~genname|, ~ifelse($1, ~|, $2, len($1), ~1|, $2, $1-$2)|)
define(~typed_commands|, 
  ~
    procedure drop_$1 cmdhdr;
    procedure dup_$1 cmdhdr;
    procedure nip_$1 cmdhdr;
    procedure swap_$1 cmdhdr;
    procedure over_$1 cmdhdr;
    procedure tuck_$1 cmdhdr;
    procedure lrot_$1 cmdhdr;
    procedure rrot_$1 cmdhdr;
    procedure lrotn_$1 cmdhdr;
    procedure rrotn_$1 cmdhdr;
    procedure pick_$1 cmdhdr;
    procedure _comma_$1 cmdhdr;
    procedure _dog_$1 cmdhdr;
    procedure _exclamation_$1 cmdhdr;
    procedure ptr_plus_$1 cmdhdr;
    procedure _to_$1 cmdhdr;
    procedure _compile_to_$1 cmdhdr;
    procedure _run_to_$1 cmdhdr;
    procedure _interpret_to_$1 cmdhdr;
    procedure _value_$1 cmdhdr;
    procedure _variable_$1 cmdhdr;
    procedure RunValue_$1 cmdhdr;
    procedure literal_$1 cmdhdr;
    procedure run_literal_$1 cmdhdr
  define(~all_implement|, all_implement 
    ~
     procedure TForthMachine.drop_$1 cmdhdr; begin Dec(WP, $2) end;
     procedure TForthMachine.dup_$1 cmdhdr; begin Move(WVar(-$2), WVar(0), $2); WInc($2) end;
     procedure TForthMachine.nip_$1 cmdhdr; begin Move(WVar(-1*$2), WVar(-2*$2), $2); Dec(WP, $2) end;
     procedure TForthMachine.swap_$1 cmdhdr; begin Move(WVar(-$2), WP^, $2); Move(WVar(-2*$2), WVar(-$2), $2); Move(WP^, WVar(-2*$2), $2); end;
     procedure TForthMachine.over_$1 cmdhdr; begin Move(WVar(-2*$2), WVar(0), $2); Inc(WP, $2) end;
     procedure TForthMachine.tuck_$1 cmdhdr; begin Move(WVar(-2*$2), WVar(-1*$2), 2*$2); Move(WVar(0), WVar(-2*$2), $2); WInc($2); end;
     procedure TForthMachine.lrot_$1 cmdhdr; 
     begin 
       Move(WVar(-1*$2), WP^, $2);
       Move(WVar(-3*$2), WVar(-1*$2), $2);
       Move(WVar(-2*$2), WVar(-3*$2), $2);
       Move(WP^, WVar(-2*$2), $2);
     end;
     procedure TForthMachine.rrot_$1 cmdhdr;
     begin 
       Move(WVar(-1*$2), WP^, $2);
       Move(WVar(-2*$2), WVar(-1*$2), $2);
       Move(WVar(-3*$2), WVar(-2*$2), $2);
       Move(WP^, WVar(-3*$2), $2);
     end;
     procedure TForthMachine.lrotn_$1 cmdhdr; 
     var
       N: Integer;
     begin 
       Dec(WP, SizeOf(TInt));
       N := TInt(WP^);
       Move(WVar(-$2*N), WVar(0), $2);
       while N > 0 do begin
         Move(WVar(-$2*(N-1)), WVar(-$2*N), $2);
         Dec(N);
       end;
       //Move(WVar(0), WVar(-$2), $2);
     end;
     procedure TForthMachine.rrotn_$1 cmdhdr;
     var
       I: Integer;
       N: Integer;
     begin
       Dec(WP, SizeOf(TInt));
       N := TInt(WP^);
       //Move(WVar(-$2), WVar(0), $2);
       for I := 0 to N - 1 do
         Move(WVar(-$2*(I+1)), WVar(-$2*I), $2);
       Move(WVar(0), WVar(-N*$2), $2);
     end;
     procedure TForthMachine.pick_$1 cmdhdr; 
     begin 
       Move(WVar(-SizeOf(TInt) -$2*TInt(WVar(-SizeOf(TInt)))), 
            WVar(-SizeOf(TInt)),
            $2);
       WInc($2 - SizeOf(TInt));
     end;
     procedure TForthMachine._comma_$1 cmdhdr; begin Dec(WP, $2); Move(WP^, Here^, $2); EA($2); end;
     procedure TForthMachine._dog_$1 cmdhdr; begin Move(Pointer(WVar(-PSize))^, WVar(-PSize), $2); Inc(WP, $2 - PSize) end;
     procedure TForthMachine._exclamation_$1 cmdhdr; begin Move(WVar(-PSize-$2), Pointer(WVar(-PSize))^, $2); Dec(WP, PSize + $2) end;
     procedure TForthMachine.ptr_plus_$1 cmdhdr; begin PtrInt(WVar(-SizeOf(Pointer))) := PtrInt(WVar(-SizeOf(Pointer))) + $2; end;
     procedure TForthMachine._to_$1 cmdhdr; begin if FState <> FS_INTERPRET then _compile_to_$1(Machine, Command) else _interpret_to_$1(Machine, Command); end;
     procedure TForthMachine._compile_to_$1 cmdhdr; begin EWO('run@genname($1, ~to|)'); EWO(NextName); end;
     procedure TForthMachine._run_to_$1 cmdhdr; begin Move(WVar(-$2), C[ERO].Data^, $2); Dec(WP, $2); end;
     procedure TForthMachine._interpret_to_$1 cmdhdr; var N: TString; C: PForthCommand; begin N := NextName; C := FindCommand(N);
               if C = nil then begin LogError('unkown name after genname($1, ~to|): ' + N); FSession := False; Exit; end; 
               Move(WVar(-$2), C.Data^, $2); Dec(WP, $2);
             end;
     procedure TForthMachine._value_$1 cmdhdr; begin with ReserveName(SNN)^ do begin Data := Here; Code := RunValue_$1; Move(WVar(-$2), Here^, $2); Dec(WP, $2); EA($2); end; end;
     procedure TForthMachine._variable_$1 cmdhdr; begin with ReserveName(SNN)^ do begin Data := Here; Code := FDataCommands.PutDataPtr; {Dec(WP, $2); Move(WP^, Here^, $2);} EA($2); end; end;
     procedure TForthMachine.RunValue_$1 cmdhdr; begin Move(Command.Data^, WP^, $2); Inc(WP, $2); end;
    procedure TForthMachine.literal_$1 cmdhdr; begin EWO('genname($1, (literal))'); Dec(WP, $2); EWV(WP, $2); end;
    procedure TForthMachine.run_literal_$1 cmdhdr; begin ERV(WP, $2); Inc(WP, $2); end;
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     AddCommand('genname($1, drop)', drop_$1);
     AddCommand('genname($1, dup)', dup_$1);
     AddCommand('genname($1, nip)', nip_$1);
     AddCommand('genname($1, swap)', swap_$1);
     AddCommand('genname($1, over)', over_$1);
     AddCommand('genname($1, tuck)', tuck_$1);
     AddCommand('genname($1, lrot)', lrot_$1);
     AddCommand('genname($1, rrot)', rrot_$1);
     AddCommand('genname($1, lrotn)', lrotn_$1);
     AddCommand('genname($1, rrotn)', rrotn_$1);
     AddCommand('genname($1, pick)', pick_$1);
     AddCommand('$1,', _comma_$1);
     AddCommand('$1@', _dog_$1);
     AddCommand('$1!', _exclamation_$1);
     AddCommand('ptr+$1', ptr_plus_$1);
     AddCommand('genname($1, to)', _to_$1, True);
     AddCommand('compile@genname($1, to)', _compile_to_$1);
     AddCommand('run@genname($1, to)', _run_to_$1);
     AddCommand('interpret@genname($1, to)', _interpret_to_$1);
     AddCommand('genname($1, value)', _value_$1);
     AddCommand('genname($1, constant)', _value_$1);
     AddCommand('genname($1, variable)', _variable_$1);
     AddCommand('genname($1, literal)', literal_$1, True);
     AddCommand('genname($1, (literal))', run_literal_$1);
    |)
|)
define(~data_commands|, 
  ~
  procedure $1_to cmdhdr;
  procedure interprete_$1_to cmdhdr;
  procedure compile_$1_to cmdhdr;
  procedure run_$1_to cmdhdr
  define(~all_implement|, all_implement 
    ~
     procedure TForthMachine.$1_to cmdhdr; begin if Machine.State = FS_COMPILE then compile_$1_to(Machine, Command) else interpete_$1_to(Machine, Command) end;
     procedure TForthMachine.interprete_$1_to cmdhdr; begin  end;
     procedure TForthMachine.compile_$1_to cmdhdr; begin  end;
     procedure TForthMachine.run_$1_to cmdhdr; begin  end;
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
    |
|)
define(~exception_commands|, 
  ~
 public
  Exceptions: array of Byte;
  ExceptionsB: Pointer;
  ExceptionsP: Pointer;
  ExceptionsS: Integer;
  procedure _sys_exceptions_execute cmdhdr;
  procedure _sys_exceptions_pop cmdhdr;
  procedure _throw cmdhdr;
  define(~all_create|, all_create
    ExceptionsS := 1024;
    SetLength(Exceptions, ExceptionsS);
    ExceptionsB := @Exceptions[0];
    ExceptionsP := @Exceptions[0]
  )
  define(~all_implement|, all_implement 
    ~
     procedure TForthMachine._sys_exceptions_execute cmdhdr;
     var
       Res: Integer;
     begin 
       Integer(ExceptionsP^) := 0;
       Inc(ExceptionsP, SizeOf(Integer));
       Integer(ExceptionsP^) := EC;
       Inc(ExceptionsP, SizeOf(Integer));
       Pointer(ExceptionsP^) := WP;
       Inc(ExceptionsP, SizeOf(Pointer));
       Pointer(ExceptionsP^) := RP;
       Inc(ExceptionsP, SizeOf(Pointer));
       execute(Machine, Command);
     end;
     procedure TForthMachine._sys_exceptions_pop cmdhdr;
     begin
       Dec(ExceptionsP, 2*SizeOf(Integer) + 2*SizeOf(Pointer));
       WUI(Integer(ExceptionsP^));
     end;
     procedure TForthMachine._throw cmdhdr; 
     begin 
       Integer((@PArrayOfByte(ExceptionsP)^[-2*SizeOf(Pointer)-2*SizeOf(Integer)])^) := WOI;
       EC := Integer((@PArrayOfByte(ExceptionsP)^[-2*SizeOf(Pointer)-SizeOf(Integer)])^);
       RP := Pointer((@PArrayOfByte(ExceptionsP)^[-1*SizeOf(Pointer)])^);
       WP := Pointer((@PArrayOfByte(ExceptionsP)^[-2*SizeOf(Pointer)])^);
     end;
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
      AddCommand('sys-exceptions-execute', _sys_exceptions_execute);
      AddCommand('sys-exceptions-pop', _sys_exceptions_pop);
      AddCommand('throw', _throw);
    |)
  dnl(
        _doc_article(~exceptions|, 
                     ~Исключения|, 
~Для работы с исключениями в DForth нужно подключить библиотеку exceptions.df
_code(~str" exceptions.df" evaluate-file|)
После этого становятся доступными две команды: throw и catch.
_code(~catch ( ... xt -- ... i ) выполняет команду со стека (помещённую туда например командой ['']). В случае если исключения не было на стеке будет помещено 0. Если же сработало исключение (командой throw) то указатель рабочего и возвратного стека будут возвращены в состояние которое имели перед выполнением команды catch и на стек будет помещён код исключения
throw ( ... i -- ... i ) последовательно выходит из функций до тех пор пока не встретит вызов командой catch. После чего передаёт управление в неё. |)
                     |)
  )
|)
{$IFNDEF FLAG_FPC}{$REGION 'long commands'}{$ENDIF}
define(~long_commands|, 
  ~
     procedure LongAlloc(var L: PLong; Len: Integer);
     procedure LongIncRef(L: PLong);
     procedure LongDecRef(L: PLong);
     procedure WULong(L: PLong);
     function WOLong: PLong;
     procedure long_add cmdhdr;
     procedure long_sub cmdhdr;
     procedure long_inc cmdhdr;
     procedure long_dec cmdhdr;
     procedure long_mul cmdhdr; 
     procedure long_div cmdhdr;
     procedure long_mod cmdhdr;
     procedure long_divmod cmdhdr;
     procedure int_to_long cmdhdr;
     procedure long_to_int cmdhdr;
  define(~all_implement|, all_implement 
    ~
       function AddWithCarryAndUpdate(
         A, B: Integer; 
         var Carry: Integer): Integer; register; inline;
       asm
         mov Result, 0
         add Result, A
         add Result, B
         add Result, Carry
         jc @@setcarry
         mov Carry, 0
         jmp @@end
       @@setcarry:
         mov Carry, 1
       @@end:
       end;
       procedure TForthMachine.LongAlloc(var L: PLong; Len: Integer);
       begin
         GetMem(L, SizeOf(Integer) * (4 + Len));
         L^.Ref := 0;
         L^.Flags := 0;
         L^.Len := 0;
         L^.Max := Len;
       end;
       procedure TForthMachine.LongIncRef(L: PLong);
       begin
         if L^.Ref > 0 then 
           Inc(L^.Ref);
       end;
       procedure TForthMachine.LongDecRef(L: PLong);
       begin
         if L^.Ref > 0 then 
           Dec(L^.Ref);
         if L^.Ref = 0 then
           FreeMem(L);
       end;
       procedure TForthMachine.WULong(L: PLong);
       begin
         LongIncRef(L);
       end;
       function TForthMachine.WOLong: PLong;
       begin
         Result := PLong(WP^);
         Dec(WP, SizeOf(PLong));
       end;
       procedure TForthMachine.long_add cmdhdr;
       var
         A, B, C: PLong;
         I, Carry: Integer;
       begin
         B := WOLong;
         A := WOLong;
         LongAlloc(C, Max(A^.Len, B^.Len) + 1);
         Carry := 0;
         for I := 0 to Min(A^.Len, B^.Len) - 1 do begin
           C^.V[I] := A^.V[I] + B^.V[I] + Carry;
           Carry := 0;
         end;
       end;
       procedure TForthMachine.long_sub cmdhdr;
       begin
       end;
       procedure TForthMachine.long_inc cmdhdr;
       begin
       end;
       procedure TForthMachine.long_dec cmdhdr;
       begin
       end;
       procedure TForthMachine.long_mul cmdhdr; 
       begin
       end;
       procedure TForthMachine.long_div cmdhdr;
       begin
       end;
       procedure TForthMachine.long_mod cmdhdr;
       begin
       end;
       procedure TForthMachine.long_divmod cmdhdr;
       begin
       end;
       procedure TForthMachine.int_to_long cmdhdr;
       begin
       end;
       procedure TForthMachine.long_to_int cmdhdr;
       begin
       end;
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
    |)
|)
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
define(~arithmetic_commands|, 
  ~
  procedure $1_plus cmdhdr;
  procedure $1_minus cmdhdr;
  procedure $1_star cmdhdr;
  procedure $1_equel cmdhdr;
  procedure $1_nequel cmdhdr;
  procedure $1_lt cmdhdr;
  procedure $1_gt cmdhdr;
  procedure $1_lte cmdhdr;
  procedure $1_gte cmdhdr;  
  procedure $1_0_equel cmdhdr;
  procedure $1_0_nequel cmdhdr;
  procedure $1_0_lt cmdhdr;
  procedure $1_0_gt cmdhdr;
  procedure $1_0_lte cmdhdr;
  procedure $1_0_gte cmdhdr;
  procedure $1_ask_dup cmdhdr;
  procedure $1_max cmdhdr;
  procedure $1_min cmdhdr;
  procedure $1_minmax cmdhdr;
  procedure $1_dot cmdhdr;
  procedure $1_dollar cmdhdr;
  procedure $1_ptr_plus_exclamation cmdhdr;
  procedure $1_conv_to_str cmdhdr;
  procedure $1_conv_from_str cmdhdr
  define(~all_implement|, all_implement 
    ~
      procedure TForthMachine.$1_plus  cmdhdr; begin $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) + $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); end;
      procedure TForthMachine.$1_minus cmdhdr; begin $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) - $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); end;
      procedure TForthMachine.$1_star  cmdhdr; begin $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) * $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); end;
      procedure TForthMachine.$1_equel cmdhdr; begin TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) = $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); end;
      procedure TForthMachine.$1_nequel cmdhdr; begin TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) <> $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); end;
      procedure TForthMachine.$1_lt cmdhdr;    begin TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) < $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); end;
      procedure TForthMachine.$1_gt cmdhdr;    begin TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) > $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); end;
      procedure TForthMachine.$1_lte cmdhdr;   begin TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) <= $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); end;
      procedure TForthMachine.$1_gte cmdhdr;   begin TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) >= $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); end;
      procedure TForthMachine.$1_0_equel cmdhdr; begin TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) = 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) end;
      procedure TForthMachine.$1_0_nequel cmdhdr; begin TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) <> 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) end;
      procedure TForthMachine.$1_0_lt cmdhdr; begin TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) < 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) end;
      procedure TForthMachine.$1_0_gt cmdhdr; begin TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) > 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) end;
      procedure TForthMachine.$1_0_lte cmdhdr; begin TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) <= 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) end;
      procedure TForthMachine.$1_0_gte cmdhdr; begin TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) >= 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) end;
      procedure TForthMachine.$1_ask_dup cmdhdr; begin if ($2(WVar(-1*SizeOf($2)))) <> 0 then begin $2(WP^) := $2(WVar(-1*SizeOf($2))); Inc(WP, SizeOf($2)); end; end;
      procedure TForthMachine.$1_max cmdhdr;
      begin
        if $2(WVar(-2*SizeOf($2))) < $2(WVar(-1*SizeOf($2))) then
          Move(WVar(-1*SizeOf($2)), WVar(-2*SizeOf($2)), SizeOf($2));
        Dec(WP, SizeOf($2));
      end;
      procedure TForthMachine.$1_min cmdhdr;
      begin
        if $2(WVar(-2*SizeOf($2))) > $2(WVar(-1*SizeOf($2))) then
          Move(WVar(-1*SizeOf($2)), WVar(-2*SizeOf($2)), SizeOf($2));
        Dec(WP, SizeOf($2));
      end;
      procedure TForthMachine.$1_minmax cmdhdr;
      begin
        if $2(WVar(-2*SizeOf($2))) > $2(WVar(-1*SizeOf($2))) then begin
          Move(WVar(-2*SizeOf($2)), WVar(-0*SizeOf($2)), SizeOf($2));
          Move(WVar(-1*SizeOf($2)), WVar(-2*SizeOf($2)), SizeOf($2));
          Move(WVar(-0*SizeOf($2)), WVar(-1*SizeOf($2)), SizeOf($2));
        end;
      end;
      procedure TForthMachine.$1_dot cmdhdr;    begin Dec(WP, SizeOf($2)); Write($2(WP^), ' '); end;
      procedure TForthMachine.$1_dollar cmdhdr; var Temp: $2; begin Read(Temp); Move(Temp, WP^, SizeOf($2)); Inc(WP, SizeOf($2)); end;
      procedure TForthMachine.$1_ptr_plus_exclamation cmdhdr; begin $2(Pointer(WVar(-SizeOf(Pointer)))^) := $2(Pointer(WVar(-SizeOf(Pointer)))^) + $2(WVar(-SizeOf(Pointer)-SizeOf($2))); Dec(WP, SizeOf(Pointer) + SizeOf($2)); end;
      procedure TForthMachine.$1_conv_to_str cmdhdr;
      var
        S: TString;
      begin
        Str($2(WVar(-SizeOf($2))), S);
        Dec(WP, SizeOf($2));
        FStringCommands.str_push(Machine, Command, S);
      end;
      procedure TForthMachine.$1_conv_from_str cmdhdr;
      var
        S: TStr;
        Code: Word;
      begin
        S := FStringCommands.str_pop(Machine, Command);
        Val(PChar(@(TStrRec(S^).Sym[0])), $2(WP^), Code);
        Inc(WP, SizeOf($2));
        FStringCommands.DelRef(S);
      end;
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     AddCommand('$1+', $1_plus);
     AddCommand('$1-', $1_minus);
     AddCommand('$1*', $1_star);
     AddCommand('$1=', $1_equel);
     AddCommand('$1<>', $1_nequel);
     AddCommand('$1<', $1_lt);
     AddCommand('$1>', $1_gt);
     AddCommand('$1<=', $1_lte);
     AddCommand('$1>=', $1_gte);
     AddCommand('genname($1, 0=)', $1_0_equel);
     AddCommand('genname($1, 0<>)', $1_0_nequel);
     AddCommand('genname($1, 0<)', $1_0_lt);
     AddCommand('genname($1, 0>)', $1_0_gt);
     AddCommand('genname($1, 0<=)', $1_0_lte);
     AddCommand('genname($1, 0>=)', $1_0_gte);
     AddCommand('genname($1, ?dup)', $1_ask_dup);
     AddCommand('genname($1, min)', $1_min);
     AddCommand('genname($1, max)', $1_max);
     AddCommand('genname($1, minmax)', $1_minmax);
     AddCommand('$1.', $1_dot);
     AddCommand('$1$', $1_dollar);
     AddCommand('$1+!', $1_ptr_plus_exclamation);
     AddCommand('$1->str', $1_conv_to_str);
     AddCommand('str->$1', $1_conv_from_str);
    |)
|)
define(~signed_arithmetic_commands|, 
  ~
  procedure $1_abs cmdhdr;
  procedure $1_neg cmdhdr
  define(~all_implement|, all_implement 
    ~procedure TForthMachine.$1_abs cmdhdr; begin $2(WVar(-SizeOf($2))) := Abs($2(WVar(-SizeOf($2)))); end;
     procedure TForthMachine.$1_neg cmdhdr; begin $2(WVar(-SizeOf($2))) := - $2(WVar(-SizeOf($2))); end;
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~AddCommand('genname($1, abs)', $1_abs);
     AddCommand('genname($1, neg)', $1_neg);
    |)
|)
define(~number_arithmetic_commands|, 
  ~
  procedure $1_push  cmdhdr;
  procedure $1_interpret_push  cmdhdr;
  procedure $1_compile_push  cmdhdr;
  procedure $1_run_push  cmdhdr;
  procedure $1_1_plus cmdhdr;
  procedure $1_1_minus cmdhdr;
  procedure $1_div cmdhdr;
  procedure $1_mod cmdhdr;
  procedure $1_divmod cmdhdr;
  procedure $1_ptr_inc cmdhdr;
  procedure $1_ptr_dec cmdhdr
  define(~all_implement|, all_implement 
    ~
     procedure TForthMachine.$1_push  cmdhdr; begin if FState = FS_COMPILE then $1_compile_push(Machine, Command) else $1_interpret_push(Machine, Command) end;
     procedure TForthMachine.$1_interpret_push  cmdhdr; begin $2(WP^) := $2(StrToInt(NextName)); Inc(WP, SizeOf($2)); end;
     procedure TForthMachine.$1_compile_push  cmdhdr; begin EWO('run@$1-push'); EW_$1(StrToInt(NextName)); end;
     procedure TForthMachine.$1_run_push  cmdhdr; begin $2(WP^) := ER_$1; Inc(WP, SizeOf($2)); end;
     procedure TForthMachine.$1_1_plus cmdhdr;  begin Inc($2(WVar(-SizeOf($2)))) end;
     procedure TForthMachine.$1_1_minus cmdhdr; begin Dec($2(WVar(-SizeOf($2)))) end;
     procedure TForthMachine.$1_div cmdhdr; begin $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) div $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); end;
     procedure TForthMachine.$1_mod cmdhdr; begin $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) mod $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); end;
     procedure TForthMachine.$1_divmod cmdhdr; begin $2(WVar(0)) := $2(WVar(-2*SizeOf($2))) mod $2(WVar(-SizeOf($2))); 
                                                     $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) div $2(WVar(-SizeOf($2)));
                                                     $2(WVar(-  SizeOf($2))) := $2(WVar(0)); 
                                               end;
     procedure TForthMachine.$1_ptr_inc cmdhdr;
     begin
       $2(Pointer(WVar(-SizeOf(Pointer)))^) := 
                         $2(Pointer(WVar(-SizeOf(Pointer)))^) + 1; 
       Dec(WP, SizeOf(Pointer));
     end;
     procedure TForthMachine.$1_ptr_dec cmdhdr;
     begin
       $2(Pointer(WVar(-SizeOf(Pointer)))^) := 
                         $2(Pointer(WVar(-SizeOf(Pointer)))^) - 1; 
       Dec(WP, SizeOf(Pointer));
     end;
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     AddCommand('$1-push', $1_push, True);
     AddCommand('run@$1-push', $1_run_push);
     AddCommand('genname($1, inc)', $1_1_plus);
     AddCommand('genname($1, dec)', $1_1_minus);
     ifelse($1, ~|, AddCommand('1+', $1_1_plus);)
     ifelse($1, ~|, AddCommand('1-', $1_1_minus);)
     AddCommand('genname($1, inc!)', $1_ptr_inc);
     AddCommand('genname($1, dec!)', $1_ptr_dec);
     ifelse($1, ~|, AddCommand('1+!', $1_ptr_inc);)
     ifelse($1, ~|, AddCommand('1-!', $1_ptr_dec);)
     AddCommand('genname($1, div)', $1_div);
     AddCommand('genname($1, mod)', $1_mod);
     AddCommand('genname($1, divmod)', $1_divmod);
    |)
|)
define(~convert_number_arithmetic_commands|, 
  ~
  procedure $1_convert_to_$3 cmdhdr
  define(~all_implement|, all_implement 
    ~
     procedure TForthMachine.$1_convert_to_$3 cmdhdr; begin $4(WVar(-SizeOf($2))) := $2(WVar(-SizeOf($2))); 
                                                            Dec(WP, SizeOf($2) - SizeOf($4)); end;
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~AddCommand('$1->$3', $1_convert_to_$3);
    |)
|)
define(~float_arithmetic_commands|, 
  ~
   procedure $1_push  cmdhdr;
   procedure $1_interpret_push  cmdhdr;
   procedure $1_compile_push  cmdhdr;
   procedure $1_run_push  cmdhdr;
   procedure $1_slash cmdhdr;
   procedure $1_cos cmdhdr;
   procedure $1_sin cmdhdr;
   procedure $1_tan cmdhdr;
   procedure $1_atan cmdhdr;
   procedure $1_atan2 cmdhdr
  define(~all_implement|, all_implement 
    ~
     procedure TForthMachine.$1_push  cmdhdr; begin if FState = FS_COMPILE then $1_compile_push(Machine, Command) else $1_interpret_push(Machine, Command) end;
     procedure TForthMachine.$1_interpret_push  cmdhdr; begin $2(WP^) := (StrToFloat(NextName)); Inc(WP, SizeOf($2)); end;
     procedure TForthMachine.$1_compile_push  cmdhdr; begin EWO('run@$1-push'); EW_$1(StrToFloat(NextName)); end;
     procedure TForthMachine.$1_run_push  cmdhdr; begin $2(WP^) := ER_$1; Inc(WP, SizeOf($2)); end;
     procedure TForthMachine.$1_slash cmdhdr; begin $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) / $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); end;
     procedure TForthMachine.$1_cos cmdhdr; begin $2(WVar(-SizeOf($2))) := Cos($2(WVar(-SizeOf($2)))); end;
     procedure TForthMachine.$1_sin cmdhdr; begin $2(WVar(-SizeOf($2))) := Sin($2(WVar(-SizeOf($2)))); end;
     procedure TForthMachine.$1_tan cmdhdr; begin $2(WVar(-SizeOf($2))) := Tan($2(WVar(-SizeOf($2)))); end;
     procedure TForthMachine.$1_atan cmdhdr; begin $2(WVar(-SizeOf($2))) := ArcTan($2(WVar(-SizeOf($2)))); end;
     procedure TForthMachine.$1_atan2 cmdhdr; begin $2(WVar(-2*SizeOf($2))) := ArcTan2($2(WVar(-2*SizeOf($2))), $2(WVar(-SizeOf($2)))); Dec(WP, SizeOf($2)) end;
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     AddCommand('$1-push', $1_push, True);
     AddCommand('run@$1-push', $1_run_push);
     AddCommand('$1/', $1_slash);
     AddCommand('genname($1,cos)', $1_cos);
     AddCommand('genname($1,sin)', $1_sin);
     AddCommand('genname($1,tan)', $1_tan);
     AddCommand('genname($1,atan)', $1_atan);
     AddCommand('genname($1,atan2)', $1_atan2);
    |)
|)
define(~system_commands|, 
  ~
  procedure EW_$1 (V: $2);
  function ER_$1: $2
  define(~all_implement|, all_implement 
    ~
     procedure TForthMachine.EW_$1; begin EWV(@V, SizeOf(V)) end;
     function TForthMachine.ER_$1; begin ERV(@Result, SizeOf(Result)) end;
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
    |)
|)
define(~push_interface|, ~procedure $1(const V: $2); overload 
  define(~all_implement|, all_implement 
    ~procedure TForthMachine.$1(const V: $2); begin $2($3^) := V; Inc($3, SizeOf(V)) end;|
  )|)
define(~pop_interface|, ~function $1: $2 
  define(~all_implement|, all_implement 
    ~function TForthMachine.$1: $2; begin Dec($3, SizeOf(Result)); Result := $2($3^); end;|)
  |)
define(~misc_commands|, 
  ~
  procedure _wp cmdhdr;
  procedure _rp cmdhdr;
  procedure _lp cmdhdr;
  procedure _r_dog cmdhdr;
  procedure _r_gt cmdhdr;
  procedure _lt_r cmdhdr;
  procedure version cmdhdr;
  procedure _state cmdhdr;
  procedure _time cmdhdr;
  procedure _local cmdhdr;
  procedure source_next_char cmdhdr;
  procedure source_next_name cmdhdr;
  procedure source_next_name_passive cmdhdr;
  procedure interpret_source_next_name_passive cmdhdr;
  procedure compile_source_next_name_passive cmdhdr;
  procedure run_source_next_name_passive cmdhdr;
  procedure ptr_nil cmdhdr;
  procedure interpret_start cmdhdr;
  procedure compile_start cmdhdr;
  procedure run_start cmdhdr;
  //procedure allot cmdhdr
  procedure opcode_to_command cmdhdr;
  procedure literal cmdhdr;
  procedure sq_ap_sq cmdhdr;
  procedure interpret_sq_ap_sq cmdhdr;
  procedure compile_sq_ap_sq cmdhdr;
  procedure run_sq_ap_sq cmdhdr;
  procedure _tick cmdhdr;
  procedure execute cmdhdr;
  procedure _does_gt cmdhdr;
  procedure _sq_does_gt_sq cmdhdr;
  procedure CallDoesGt cmdhdr;
  procedure Cells cmdhdr;
  procedure Cell_plus cmdhdr;
  define(~all_implement|, all_implement 
    ~
      procedure TForthMachine._wp cmdhdr; begin Pointer(WP^) := WP; Inc(WP, SizeOf(Pointer)); end;
      procedure TForthMachine._rp cmdhdr; begin Pointer(WP^) := RP; Inc(WP, SizeOf(Pointer)); end;
      procedure TForthMachine._lp cmdhdr; begin Pointer(WP^) := LP; Inc(WP, SizeOf(Pointer)); end;
      procedure TForthMachine._r_dog cmdhdr; begin Pointer(WP^) := Pointer(Pointer(Cardinal(RP) - SizeOf(Pointer))^); Inc(WP, SizeOf(Pointer)); end;
      procedure TForthMachine._r_gt cmdhdr; begin Dec(RP, SizeOf(Pointer)); Pointer(WP^) := Pointer(RP^); Inc(WP, SizeOf(Pointer)); end;
      procedure TForthMachine._lt_r cmdhdr; begin Dec(WP, SizeOf(Pointer)); Pointer(RP^) := Pointer(WP^); Inc(RP, SizeOf(Pointer)); end;
      procedure TForthMachine.version cmdhdr; begin TInt(WP^) := DFORTHMACHINE_VERSION; Inc(WP, SizeOf(TInt)); end;
      procedure TForthMachine._state cmdhdr; begin Pointer(WP^) := @FState; Inc(WP, SizeOf(Pointer)); end;
      procedure TForthMachine._time cmdhdr; begin Integer(WP^) := GetTimer; Inc(WP, SizeOf(TInt)); end;
      procedure TForthMachine._local cmdhdr; begin RunCommand(PForthCommand((@E[Integer(Command^.Data)])^)); end;
      procedure TForthMachine.source_next_char cmdhdr; begin WUU8(Byte(NextChar)) end;
      procedure TForthMachine.source_next_name cmdhdr; begin FStringCommands.str_push(Machine, Command, NextName) end;
      procedure TForthMachine.source_next_name_passive cmdhdr; begin if FState <> FS_INTERPRET then compile_source_next_name_passive(Machine, Command) else 
                                                                                                   interpret_source_next_name_passive(Machine, Command) end;
      procedure TForthMachine.interpret_source_next_name_passive cmdhdr; begin FStringCommands.str_push(Machine, Command, NextNamePassive) end;
      procedure TForthMachine.compile_source_next_name_passive cmdhdr; begin EWO(' str"'); EWStr(NextNamePassive); end;
      procedure TForthMachine.run_source_next_name_passive cmdhdr; begin FStringCommands.str_push(Machine, Command, @E[EC]); end;
      procedure TForthMachine.ptr_nil cmdhdr; begin WUP(nil); end;
      procedure TForthMachine.compile_start cmdhdr; begin FState := FS_COMPILE end;
      procedure TForthMachine.interpret_start cmdhdr; begin FState := FS_INTERPRET end;
      procedure TForthMachine.run_start cmdhdr; begin FState := FS_INTERPRET end;
      //procedure TForthMachine.allot cmdhdr; begin Dec(WP, SizeOf(TInt)); DA(TInt(WP)^); end;
      procedure TForthMachine.opcode_to_command cmdhdr; begin Pointer(WVar(-SizeOf(Integer))) := GetCommandByOpcode(Integer(WVar(-SizeOf(Integer)))) end;
      procedure TForthMachine.literal cmdhdr; begin EWO('run@int-push'); EWI(WOI); end;
      procedure TForthMachine.sq_ap_sq cmdhdr; begin {if FState <> FS_INTERPRET then compile_sq_ap_sq(Machine, Command) else interpret_sq_ap_sq(Machine, Command)}
                WUI(GetOpcodeByName(NextName)); Literal(Machine, Command);
                EWO('opcode->command'); end;
      procedure TForthMachine.interpret_sq_ap_sq cmdhdr; begin WUP(FindCommand(NextName)) end;
      procedure TForthMachine.compile_sq_ap_sq cmdhdr; begin EWO('run@['']'); EWO(NextName); end;
      procedure TForthMachine.run_sq_ap_sq cmdhdr; begin WUP(C[ERO]); end;
      procedure TForthMachine._tick cmdhdr; begin Pointer(WP^) := FindCommand(NextName); Inc(WP, SizeOf(Pointer)); end;
      procedure TForthMachine.execute cmdhdr; var P: PForthCommand; begin 
                                             P := WOP; P.Code(Machine, P) end;
      procedure TForthMachine._does_gt cmdhdr; begin EWO('(does>)'); EWO('exit'); end;
      procedure TForthMachine._sq_does_gt_sq cmdhdr; begin Integer(C[FLastMnemonic].Param) := Integer(C[FLastMnemonic].Data); Integer(C[FLastMnemonic].Data) := EC + 4; C[FLastMnemonic].Code := CallDoesGt; end;
      procedure TForthMachine.CallDoesGt cmdhdr; begin FControlCommands.Call(Machine, Command); Pointer(WP^) := Pointer(Command.Param); Inc(WP, SizeOf(Pointer)); end;
      procedure TForthMachine.Cells cmdhdr; begin TInt(WVar(-SizeOf(TInt))) := TInt(WVar(-SizeOf(TInt)))*SizeOf(Integer); end;
      procedure TForthMachine.Cell_plus cmdhdr; begin TInt(WVar(-SizeOf(TInt))) := TInt(WVar(-SizeOf(TInt))) + SizeOf(TInt); end;
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     AddCommand('wp', _wp);
     AddCommand('rp', _rp);
     AddCommand('lp', _lp);
     AddCommand('r@', _r_dog);
     AddCommand('r>', _r_gt);
     AddCommand('>r', _lt_r);
     AddCommand('sys-version', version);
     AddCommand('state', _state);
     AddCommand('time', _time);
     AddCommand('local', _local);
     AddCommand('source-next-char', source_next_char);
     AddCommand('source-next-name', source_next_name);
     AddCommand('source-next-name-passive', source_next_name_passive);
     AddCommand('interpret@source-next-name-passive', source_next_name_passive);
     AddCommand('compile@source-next-name-passive', source_next_name_passive);
     AddCommand('run@source-next-name-passive', source_next_name_passive);
     AddCommand('ptr-nil', ptr_nil);
     AddCommand('interpret@', interpret_start);
     AddCommand('compile@', compile_start);
     AddCommand('run@', run_start);
     //AddCommand('allot', allot);
     //AddCommand('literal', literal, True);
     AddCommand('['']', sq_ap_sq, True);
     AddCommand('opcode->command', opcode_to_command);
     //AddCommand('run@['']', run_sq_ap_sq);
     //AddCommand('compile@['']', compile_sq_ap_sq);
     //AddCommand('interpret@['']', interpret_sq_ap_sq);
     AddCommand('''', _tick);
     AddCommand('execute', execute);
     AddCommand('does>', _does_gt, True);
     AddCommand('(does>)', _sq_does_gt_sq);
     AddCommand('cells', Cells);
     AddCommand('cell+', Cell_plus);
    |)
|)
define(~file_commands|, 
  ~
  procedure file_open cmdhdr;
  procedure file_close cmdhdr;
  procedure file_w cmdhdr;
  procedure file_r cmdhdr;
  procedure file_write cmdhdr;
  procedure file_read cmdhdr;
  procedure file_write_from_w cmdhdr;
  procedure file_read_to_w cmdhdr;
  procedure file_size cmdhdr;
  define(~all_implement|, all_implement 
    ~
      type
        PdfFile = ^TdfFile;
        TdfFile = record
          Data: TData;
          Name: String;
          Mode: TInt;
        end;
      procedure TForthMachine.file_open cmdhdr; 
      var 
        F: PdfFile;
        S: TStr;
      begin 
         New(F);
         F^.Mode := WOI; 
         S := FStringCommands.str_pop(Machine, Command); 
         F^.Name := PChar(@(PStrRec(S)^.Sym[0]));
         if F^.Mode = DF_FILE_R then
           F^.Data := TData.Create(F^.Name)
         else
           F^.Data := TData.Create;
         WUP(F); 
         FStringCommands.DelRef(S);
      end;
      procedure TForthMachine.file_close cmdhdr; 
      var
        F: PdfFile;
      begin 
        F := WOP;
        if F^.Mode = DF_FILE_W then
          F^.Data.WriteToFile(F^.Name);
        F^.Data.Free;
        Dispose(F); 
      end;
      procedure TForthMachine.file_w cmdhdr; begin WUI(DF_FILE_W) end;
      procedure TForthMachine.file_r cmdhdr; begin WUI(DF_FILE_R) end;
      procedure TForthMachine.file_write cmdhdr; 
      var
        Src: Pointer;
        S: TInt;
        F: PdfFile;
      begin 
        S := WOI; 
        Src := WOP; 
        //F := WOP; 
        PdfFile(WVar(-SizeOf(PdfFile)))^.Data.WriteVar(Src, S);
      end;
      procedure TForthMachine.file_read cmdhdr;
      var
        Src: Pointer;
        S: TInt;
        F: PdfFile;
      begin 
        S := WOI; 
        Src := WOP; 
        //F := WOP; 
        //F^.Data.ReadVar(Src, S);
        PdfFile(WVar(-SizeOf(PdfFile)))^.Data.ReadVar(Src, S);
      end;
      procedure TForthMachine.file_write_from_w cmdhdr;
      begin
      end;
      procedure TForthMachine.file_read_to_w cmdhdr;
      begin
      end;
      procedure TForthMachine.file_size cmdhdr; begin WUI(PdfFile(WOP)^.Data.Size); end;
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     AddCommand('file-open', file_open);
     AddCommand('file-close', file_close);
     AddCommand('file-w', file_w);
     AddCommand('file-r', file_r);
     AddCommand('file-write', file_write);
     AddCommand('file-read', file_read);
     AddCommand('file-size', file_size);
    |)
|)

const
  BOOL_FALSE: Integer   = 0;
  BOOL_TRUE: Integer    = -1;

  CONV_STDCALL: Integer = 100;
  CONV_CDECL: Integer   = 101;

  MACHINE_MODE_READY            = $00;
  MACHINE_MODE_BREAKPOINT       = $01;
  MACHINE_MODE_WAITSOURCE       = $02;
  MACHINE_MODE_WORK             = $03;

  FS_INTERPRET                  = $00;
  FS_COMPILE                    = $01;
  FS_RUN                        = $02;

  DF_FILE_R                     = $A0;
  DF_FILE_W                     = $A1;

  EOL: String                   = #13;

type
  TForthMachine = class;

  TCallback = procedure (machine: Pointer); stdcall;
  PForthCommand = ^TForthCommand;
  TForthRuntimeProc = procedure (machine: TForthMachine; Command: PForthCommand) 
                                                                      of object;
  TForthCommandProc = procedure (machine: TForthMachine) of object;

  TCode = procedure (Machine: TForthMachine; Command: PForthCommand) of object;

  TMnemonic = TInt;
  TOpcode = TInt;
  TPtr = Pointer;
  TEmbroPtr = TInt;

  TStrRec = record
    Ref: TInt;
    Len: TInt;
    Sym: array[0..1] of TChar;
  end;
  PStrRec = ^TStrRec;
  TStr = PStrRec;

  PLong = ^TLong;
  TLong = record
    Ref: Integer; // -1 если не нужно высвобождать из памяти, иначе --- число ссылок
    Flags: Integer; // Flags and 1 > 0 если число отрицательно
    Len: Integer; // Такое число, что V[I] = 0 для всех I >= Len
    Max: Integer; // Число элементов в массиве V
    V: array[0..1] of Integer;
  end;

  TType = record
    Name: PChar;
    Size: Integer;
  end;
  PType = ^TType;

  TForthCommand = record 
          Code: TCode;
          Data: Pointer;
          Flags: Byte;
          Name: PChar; 
          Param: Pointer;
        end;

  TWordSpace = record
    C: array of PForthCommand;
    L: Integer;
    S: Integer;
  end;
{$IFNDEF FLAG_FPC}{$REGION 'TReturnStack'}{$ENDIF}
TReturnStack = class(TForthStack)
 public
  procedure ptrpush(P: Pointer);
  function ptrpop: Pointer;
  function ptrgettop: Pointer;
  procedure embropush(P: Cardinal);
  function embropop: Cardinal;
  function embrogettop: Cardinal;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TStackCommands'}{$ENDIF}
TStackCommands = class
 private
  FMachine: TForthMachine;
  FSize: Integer;
  Temp: array of Byte;
 public
  constructor Create(Machine: TForthMachine; Size: Integer);
  procedure push(P: Pointer);
  procedure _push(Machine: TForthMachine; Command: PForthCommand);
  procedure compile_push(Machine: TForthMachine);
  procedure pop(P: Pointer);
  procedure dup(Machine: TForthMachine; Command: PForthCommand);
  procedure drop(Machine: TForthMachine; Command: PForthCommand);
  procedure swap(Machine: TForthMachine; Command: PForthCommand);
  procedure over(Machine: TForthMachine; Command: PForthCommand);
  procedure lrot(Machine: TForthMachine; Command: PForthCommand);
  procedure rrot(Machine: TForthMachine; Command: PForthCommand);
  procedure lrotn(Machine: TForthMachine; Command: PForthCommand);
  procedure rrotn(Machine: TForthMachine; Command: PForthCommand);

  procedure _dog(Machine: TForthMachine; Command: PForthCommand);
  procedure _exclamation(Machine: TForthMachine; Command: PForthCommand);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TBoolCommands'}{$ENDIF}
TBoolCommands = class
 private
  FMachine: TForthMachine;
 public
  constructor Create(Machine: TForthMachine);
  procedure push(Machine: TForthMachine; Command: PForthCommand);
  procedure compile_push(Machine: TForthMachine);
  procedure _false(Machine: TForthMachine; Command: PForthCommand);
  procedure _true(Machine: TForthMachine; Command: PForthCommand);
  procedure _not(Machine: TForthMachine; Command: PForthCommand);
  procedure _or(Machine: TForthMachine; Command: PForthCommand);
  procedure _and(Machine: TForthMachine; Command: PForthCommand);
  procedure _xor(Machine: TForthMachine; Command: PForthCommand);
  procedure _dot(Machine: TForthMachine; Command: PForthCommand);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TConsoleCommands'}{$ENDIF}
TConsoleCommands = class
 private
  FMachine: TForthMachine;
 public
  constructor Create(Machine: TForthMachine);
  procedure cr(Machine: TForthMachine; Command: PForthCommand);
  procedure emit(Machine: TForthMachine; Command: PForthCommand);
  procedure space(Machine: TForthMachine; Command: PForthCommand);
  procedure spaces(Machine: TForthMachine; Command: PForthCommand);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TControlCommands'}{$ENDIF}
TControlCommands = class
 private
  FMachine: TForthMachine;
 public
  constructor Create(Machine: TForthMachine);
  procedure branch(Machine: TForthMachine; Command: PForthCommand);
  procedure _ask_branch(Machine: TForthMachine; Command: PForthCommand);
  procedure _gt_mark(Machine: TForthMachine; Command: PForthCommand);
  procedure _gt_resolve(Machine: TForthMachine; Command: PForthCommand);
  procedure _lt_mark(Machine: TForthMachine; Command: PForthCommand);
  procedure _lt_resolve(Machine: TForthMachine; Command: PForthCommand);
  procedure _exit(Machine: TForthMachine; Command: PForthCommand);
  procedure recurse(Machine: TForthMachine; Command: PForthCommand);
  procedure call(Machine: TForthMachine; Command: PForthCommand);
  procedure compile_def(Machine: TForthMachine; Command: PForthCommand);
  procedure compile_skip_to_end(Machine: TForthMachine; Command: PForthCommand);
  procedure compile_enddef(Machine: TForthMachine; Command: PForthCommand);
  procedure compile_scattered_def(Machine: TForthMachine; Command: PForthCommand);
  procedure compile_scattered_enddef(Machine: TForthMachine; Command: PForthCommand); 
  procedure scattered_dots(Machine: TForthMachine; Command: PForthCommand); 
  procedure immediate(Machine: TForthMachine; Command: PForthCommand);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TEmbroCommands'}{$ENDIF}
TEmbroCommands = class
 public
  procedure compile(Machine: TForthMachine; Command: PForthCommand);
  procedure execute(Machine: TForthMachine; Command: PForthCommand);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TDataCommands'}{$ENDIF}
TDataCommands = class
 public
  procedure _nil(Machine: TForthMachine; Command: PForthCommand);
  procedure ptr_comma(Machine: TForthMachine; Command: PForthCommand);

  procedure _create(Machine: TForthMachine; Command: PForthCommand);
  procedure putdataptr(Machine: TForthMachine; Command: PForthCommand);
  procedure here(Machine: TForthMachine; Command: PForthCommand);
  procedure allot(Machine: TForthMachine; Command: PForthCommand);

  procedure to_int(Machine: TForthMachine; Command: PForthCommand);
  procedure to_int8(Machine: TForthMachine; Command: PForthCommand);
  procedure to_int16(Machine: TForthMachine; Command: PForthCommand);
  procedure to_int32(Machine: TForthMachine; Command: PForthCommand);
  procedure to_int64(Machine: TForthMachine; Command: PForthCommand);
  procedure to_uint(Machine: TForthMachine; Command: PForthCommand);
  procedure to_uint8(Machine: TForthMachine; Command: PForthCommand);
  procedure to_uint16(Machine: TForthMachine; Command: PForthCommand);
  procedure to_uint32(Machine: TForthMachine; Command: PForthCommand);
  procedure to_uint64(Machine: TForthMachine; Command: PForthCommand);
  procedure to_ptr(Machine: TForthMachine; Command: PForthCommand);
  procedure compile_to(Machine: TForthMachine; const Name: TString; Size: Integer);
  procedure run_to(Machine: TForthMachine; Command: PForthCommand);
  procedure run_8to(Machine: TForthMachine; Command: PForthCommand);
  procedure run_16to(Machine: TForthMachine; Command: PForthCommand);
  procedure run_32to(Machine: TForthMachine; Command: PForthCommand);
  procedure run_64to(Machine: TForthMachine; Command: PForthCommand);
  procedure interpete_to(Machine: TForthMachine; const Name: TString; Size: Integer);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TTypeCommands'}{$ENDIF}
TTypeCommands = class
 public
  procedure typeof(Machine: TForthMachine; Command: PForthCommand);
  procedure type_size(Machine: TForthMachine; Command: PForthCommand);
  procedure compile_type(Machine: TForthMachine; Name: PChar);
  procedure interpete_type(Machine: TForthMachine; Name: PChar);
  procedure run_type(Machine: TForthMachine; Command: PForthCommand);
  procedure _void(Machine: TForthMachine; Command: PForthCommand);
  procedure _int(Machine: TForthMachine; Command: PForthCommand);
  procedure _int8(Machine: TForthMachine; Command: PForthCommand);
  procedure _int16(Machine: TForthMachine; Command: PForthCommand);
  procedure _int32(Machine: TForthMachine; Command: PForthCommand);
  procedure _int64(Machine: TForthMachine; Command: PForthCommand);
  procedure _uint(Machine: TForthMachine; Command: PForthCommand);
  procedure _uint8(Machine: TForthMachine; Command: PForthCommand);
  procedure _uint16(Machine: TForthMachine; Command: PForthCommand);
  procedure _uint32(Machine: TForthMachine; Command: PForthCommand);
  procedure _uint64(Machine: TForthMachine; Command: PForthCommand);
  procedure _bool(Machine: TForthMachine; Command: PForthCommand);
  procedure _str(Machine: TForthMachine; Command: PForthCommand);
  procedure _pchar(Machine: TForthMachine; Command: PForthCommand);
  procedure _ptr(Machine: TForthMachine; Command: PForthCommand);
  procedure _type(Machine: TForthMachine; Command: PForthCommand);
  procedure _single(Machine: TForthMachine; Command: PForthCommand);
  procedure _double(Machine: TForthMachine; Command: PForthCommand);
  procedure _extended(Machine: TForthMachine; Command: PForthCommand);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TAlienCommands'}{$ENDIF}
TAlienCommands = class
 private
  FLibs: array of TInt;
 public
  procedure lib_load(Machine: TForthMachine; Command: PForthCommand);
  procedure lib_unload(Machine: TForthMachine; Command: PForthCommand);
  procedure lib_fun(Machine: TForthMachine; Command: PForthCommand);
  procedure alien_fun(Machine: TForthMachine; Command: PForthCommand);
  procedure alien_endfun(Machine: TForthMachine; Command: PForthCommand);
  procedure invoke_stdcall(Machine: TForthMachine; Command: PForthCommand);
  procedure invoke_cdecl(Machine: TForthMachine; Command: PForthCommand);
  procedure _conv_stdcall(Machine: TForthMachine; Command: PForthCommand);
  procedure _conv_cdecl(Machine: TForthMachine; Command: PForthCommand);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TStringCommands'}{$ENDIF}
TStringCommands = class
 private
  FMachine: TForthMachine;
  // когда они создаются при интерпритации, нужно где-то хранить
  FPChars: array of array of TChar;

  S: TStr;
  FStrNil: TStr;
 public
  constructor Create(Machine: TForthMachine);
  procedure pchar_alloc(Machine: TForthMachine; Command: PForthCommand);
  procedure pchar_free(Machine: TForthMachine; Command: PForthCommand);
  procedure pchar_len(Machine: TForthMachine; Command: PForthCommand);
  procedure pchar_concat(Machine: TForthMachine; Command: PForthCommand);
  procedure pchar_equel(Machine: TForthMachine; Command: PForthCommand);
  procedure pchar_dq(Machine: TForthMachine; Command: PForthCommand);
  procedure compile_pchar_dq(Machine: TForthMachine; Command: PForthCommand);
  procedure run_pchar_dq(Machine: TForthMachine; Command: PForthCommand);
  procedure pchar_dot(Machine: TForthMachine; Command: PForthCommand);

  // подсчёт ссылок у строк
  procedure AddRef(S: TStr);
  procedure DelRef(S: TStr);

  // стековые команды над строками отличаются
  procedure str_push(Machine: TForthMachine; Command: PForthCommand; S: TString); overload;
  procedure str_push(Machine: TForthMachine; Command: PForthCommand; S: TStr); overload;
  function str_pop(Machine: TForthMachine; Command: PForthCommand): TStr;
  procedure str_drop(Machine: TForthMachine; Command: PForthCommand);
  procedure str_dup(Machine: TForthMachine; Command: PForthCommand);
  procedure str_over(Machine: TForthMachine; Command: PForthCommand);

  procedure str_len(Machine: TForthMachine; Command: PForthCommand);
  procedure str_dq(Machine: TForthMachine; Command: PForthCommand);
  procedure compile_str_dq(Machine: TForthMachine; Command: PForthCommand);
  procedure run_str_dq(Machine: TForthMachine; Command: PForthCommand);
  procedure str_equel(Machine: TForthMachine; Command: PForthCommand);
  procedure str_concat(Machine: TForthMachine; Command: PForthCommand);
  procedure str_nil(Machine: TForthMachine; Command: PForthCommand);
  procedure str_dot(Machine: TForthMachine; Command: PForthCommand);
  procedure str_dollar(Machine: TForthMachine; Command: PForthCommand);
  procedure Format(Machine: TForthMachine; Command: PForthCommand);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TForthMachine'}{$ENDIF}
TForthMachine = class
 private
  FUserData: Pointer;
  FStack: TForthStack;
  FReturnStack: TReturnStack;
{$IFNDEF FLAG_FPC}{$REGION 'commands'}{$ENDIF}
  FControlCommands: TControlCommands;
  FEmbroCommands: TEmbroCommands;
  FDataCommands: TDataCommands;
  FAlienCommands: TAlienCommands;
  FStackCommands: TStackCommands;
  FStackCommands8: TStackCommands;
  FStackCommands16: TStackCommands;
  FStackCommands32: TStackCommands;
  FStackCommands64: TStackCommands;
  FPtrStackCommands: TStackCommands;
  FStringCommands: TStringCommands;
  FTypeCommands: TTypeCommands;
  FIntArithmetic: TObject;
  FInt8Arithmetic: TObject;
  FInt16Arithmetic: TObject;
  FInt32Arithmetic: TObject;
  FInt64Arithmetic: TObject;
  FUIntArithmetic: TObject;
  FUInt8Arithmetic: TObject;
  FUInt16Arithmetic: TObject;
  FUInt32Arithmetic: TObject;
  FUInt64Arithmetic: TObject;
  FBoolCommands: TBoolCommands;
  FConsoleCommands: TConsoleCommands;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
  //C: array of TForthCommand;
  FData: array of Byte;
  //FHere: Integer;
  FCompilation: Boolean;
  FRunning: Boolean;
  FSource: PChar;
  FCurrentChar: Integer;
  //FPC: Cardinal;
  FCurrentName: TString;
  // FS_*
  FState: Integer;
  FSession: Boolean;
  FLastMnemonic: Integer;
  FEmbroDump: array of TString;
  FEmbro: array of Byte;
  FTypes: array of TType;
{$IFNDEF FLAG_FPC}{$REGION 'misc commands'}{$ENDIF}
  procedure CompileComment(Machine: TForthMachine; Command: PForthCommand);
  procedure CompileLineComment(Machine: TForthMachine; Command: PForthCommand);
  procedure CompileSource(Source: PChar);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
  function CompileName(W: PChar): Boolean; overload;
  function NextMnemonic: Cardinal;
  procedure Run(Index: Integer);
  procedure RunMnemonic(M: Cardinal);
  procedure RunCommand(Command: PForthCommand);
  procedure RunError(const S: TString);
  procedure RunWarring(const S: TString);
  procedure IncHere(Count: Integer);
  procedure AddType(const Name: TString; Size: Integer);
 public
{$IFNDEF FLAG_FPC}{$REGION 'machine datas'}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'E'}{$ENDIF}
 public
  E: array of Byte; // Embro
  EB: Pointer; // Embro Base (@E[0])
  EC: Integer; // Embro Counter (E[EC])
  EL: Integer; // Embro Last compiled
  ES: Integer; // Embro Size (Length(E))
  procedure EA(Size: Integer); // Embro Alloc
  function Here: Pointer; overload;
  procedure _here(Machine: TForthMachine; Command: PForthCommand); overload;
  procedure EWV(V: Pointer; Size: Integer); // Embro Write Var
  procedure EWI(V: Integer); // Embro Write Integer
  procedure EWE(V: TEmbroPtr);
  procedure EWO(V: TOpcode); overload;
  procedure EWO(V: TString); overload;
  procedure EWI8(V: TInt8);
  procedure EWI16(V: TInt16);
  procedure EWI32(V: TInt32);
  procedure EWI64(V: TInt64);
  procedure EWU(V: TUInt);
  procedure EWU8(V: TUInt8);
  procedure EWU16(V: TUInt16);
  procedure EWU32(V: TUInt32);
  procedure EWU64(V: TUInt64);
  procedure EWC(V: Char);
  procedure EWS(V: Single);
  procedure EWD(const V: Double);
  procedure EWExtended(const V: Extended);
  procedure EWPChar(V: PChar);
  procedure EWStr(V: TString);
  procedure ERV(V: Pointer; Size: Integer); // Embro Read Var
  function ERI: Integer; // Embro Read Integer
  function ERE: TEmbroPtr;
  function ERO: TOpcode;
  function ERI8: TInt8;
  function ERI16: TInt16;
  function ERI32: TInt32;
  function ERI64: TInt64;
  function ERU: TUInt;
  function ERU8: TUInt8;
  function ERU16: TUInt16;
  function ERU32: TUInt32;
  function ERU64: TUInt64;
  function ERC: Char;
  function ERS: Single;
  function ERD: Double;
  function ERExtended: Extended;
  function ERPChar: PChar;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'R'}{$ENDIF}
 public
  R: array of Byte; // Return stack
  RB: Pointer; // Return stack Base
  RP: Pointer; // Return stack Pointer
  RS: Integer; // Return stack Size
  procedure RUV(const P: Pointer; Size: Integer);
  procedure ROV(const P: Pointer; Size: Integer);
  pop_interface(ROP, Pointer, RP); // Return stack pOp Pointer
  push_interface(RUI, TInt, RP); // Return stack pUsh Integer
  push_interface(RUI8, TInt8, RP); 
  push_interface(RUI16, TInt16, RP);
  push_interface(RUI32, TInt32, RP);
  push_interface(RUI64, TInt64, RP);
  push_interface(RUU, TUInt, RP);
  push_interface(RUU8, TUInt8, RP); 
  push_interface(RUU16, TUInt16, RP);
  push_interface(RUU32, TUInt32, RP);
  push_interface(RUU64, TUInt64, RP);
  push_interface(RUP, Pointer, RP); // Return stack pUsh Pointer
  pop_interface(ROI, TInt, RP); // Return stack pOp Integer
  pop_interface(ROI8, TInt8, RP); 
  pop_interface(ROI16, TInt16, RP);
  pop_interface(ROI32, TInt32, RP);
  pop_interface(ROI64, TInt64, RP);
  pop_interface(ROU, TUInt, RP);
  pop_interface(ROU8, TUInt8, RP); 
  pop_interface(ROU16, TUInt16, RP);
  pop_interface(ROU32, TUInt32, RP);
  pop_interface(ROU64, TUInt64, RP);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'W'}{$ENDIF}
 public
  W: array of Byte; // Work stack
  WB: Pointer; // Work stack Base (@W[0])
  WP: Pointer; // Work stack Pointer
  WS: Integer; // Work stack Size
  push_interface(WUI, TInt, WP); // Work stack pUsh Integer
  push_interface(WUP, Pointer, WP); // Work stack pUsh Pointer
  pop_interface(WOI, TInt, WP); // Work stack pOp Integer
  pop_interface(WOP, Pointer, WP); // Work stack pOp Pointer
  push_interface(WUI8, TInt8, WP); 
  push_interface(WUI16, TInt16, WP);
  push_interface(WUI32, TInt32, WP);
  push_interface(WUI64, TInt64, WP);
  push_interface(WUU, TUInt, WP);
  push_interface(WUU8, TUInt8, WP); 
  push_interface(WUU16, TUInt16, WP);
  push_interface(WUU32, TUInt32, WP);
  push_interface(WUU64, TUInt64, WP);
  pop_interface(WOI8, TInt8, WP); 
  pop_interface(WOI16, TInt16, WP);
  pop_interface(WOI32, TInt32, WP);
  pop_interface(WOI64, TInt64, WP);
  pop_interface(WOU, TUInt, WP);
  pop_interface(WOU8, TUInt8, WP); 
  pop_interface(WOU16, TUInt16, WP);
  pop_interface(WOU32, TUInt32, WP);
  pop_interface(WOU64, TUInt64, WP);
  procedure WUV(const P: Pointer; Size: Integer);
  procedure WOV(const P: Pointer; Size: Integer);
  procedure WUS(const S: TString);
  function WOS: TString;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'C'}{$ENDIF}
 public
  C: array of PForthCommand; // Commands
  CB: Pointer; // Commands Base (@C[0])
  CC: Integer; // Commands Counter (C[CC] - last added command)
  CS: Integer; // Commands Size (Length(C))
  // Command REserve
  // Command FInd
  // Command EXecute
  // Command COmpile
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'C'}{$ENDIF}
 public
   Local: TWordSpace;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'D'}{$ENDIF}
 public
 {D: array of Byte; // Data
  DB: Pointer; // Data Base
  DP: Pointer; // Data Pointer (traditionaly called HERE in forth)
  DS: Integer; // Data Size
  procedure DA(Size: Integer); // Data Allot}
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'S'}{$ENDIF}
 public
  // doesn't work in run state
  S: PChar; // Source
  SC: Integer; // Source Counter
  function SE: Boolean; // Source End
  function SNC: TChar; // Source Next Char
  function SNN: TString; // Source Next Name
  procedure SSS; // Source Skip Spaces
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'L'}{$ENDIF}
 public
  L: array of Byte; // Local stack
  LB: Pointer; // Local stack Base (@W[0])
  LP: Pointer; // Local stack Pointer
  LS: Integer; // Local stack Size
  procedure LUV(const P: Pointer; Size: Integer);
  procedure LOV(const P: Pointer; Size: Integer);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'all commands'}{$ENDIF}
  dnl typed_commands(1, 1);
  dnl typed_commands(2, 2);
  dnl typed_commands(4, 4);
  dnl typed_commands(8, 8);
  typed_commands(~|, 4);
  typed_commands(ptr, 4);
  typed_commands(int, 4);
  typed_commands(int8, 1);
  typed_commands(int16, 2);
  typed_commands(int32, 4);
  typed_commands(int64, 8);
  typed_commands(uint, 4);
  typed_commands(uint8, 1);
  typed_commands(uint16, 2);
  typed_commands(uint32, 4);
  typed_commands(uint64, 8);
  typed_commands(embro, 4);
  arithmetic_commands(, TInt);
  arithmetic_commands(int, TInt);
  arithmetic_commands(int8, TInt8);
  arithmetic_commands(int16, TInt16);
  arithmetic_commands(int32, TInt32);
  arithmetic_commands(int64, TInt64);
  arithmetic_commands(uint, TUInt);
  arithmetic_commands(uint8, TUInt8);
  arithmetic_commands(uint16, TUInt16);
  arithmetic_commands(uint32, TUInt32);
  arithmetic_commands(uint64, TUInt64);
  arithmetic_commands(single, Single);
  arithmetic_commands(double, Double);
  arithmetic_commands(extended, Extended);
  signed_arithmetic_commands(, TInt);
  signed_arithmetic_commands(int, TInt);
  signed_arithmetic_commands(int8, TInt8);
  signed_arithmetic_commands(int16, TInt16);
  signed_arithmetic_commands(int32, TInt32);
  signed_arithmetic_commands(int64, TInt64);
  signed_arithmetic_commands(single, Single);
  signed_arithmetic_commands(double, Double);
  number_arithmetic_commands(, TInt);
  number_arithmetic_commands(int, TInt);
  number_arithmetic_commands(int8, TInt8);
  number_arithmetic_commands(int16, TInt16);
  number_arithmetic_commands(int32, TInt32);
  number_arithmetic_commands(int64, TInt64);
  number_arithmetic_commands(uint, TUInt);
  number_arithmetic_commands(uint8, TUInt8);
  number_arithmetic_commands(uint16, TUInt16);
  number_arithmetic_commands(uint32, TUInt32);
  number_arithmetic_commands(uint64, TUInt64);
  convert_number_arithmetic_commands(int,      TInt,     int8,     TInt8);
  convert_number_arithmetic_commands(int,      TInt,     int16,    TInt16);
  convert_number_arithmetic_commands(int,      TInt,     int32,    TInt32);
  convert_number_arithmetic_commands(int,      TInt,     int64,    TInt64);
  convert_number_arithmetic_commands(int8,     TInt8,    int,      TInt);
  convert_number_arithmetic_commands(int16,    TInt16,   int,      TInt);
  convert_number_arithmetic_commands(int32,    TInt32,   int,      TInt);
  convert_number_arithmetic_commands(int64,    TInt64,   int,      TInt);
  convert_number_arithmetic_commands(uint,     TUInt,    uint8,    TUInt8);
  convert_number_arithmetic_commands(uint,     TUInt,    uint16,   TUInt16);
  convert_number_arithmetic_commands(uint,     TUInt,    uint32,   TUInt32);
  convert_number_arithmetic_commands(uint,     TUInt,    uint64,   TUInt64);
  convert_number_arithmetic_commands(uint8,    TUInt8,   uint,     TUInt);
  convert_number_arithmetic_commands(uint16,   TUInt16,  uint,     TUInt);
  convert_number_arithmetic_commands(uint32,   TUInt32,  uint,     TUInt);
  convert_number_arithmetic_commands(uint64,   TUInt64,  uint,     TUInt);
  convert_number_arithmetic_commands(single,   Single,   double,   Double);
  convert_number_arithmetic_commands(double,   Double,   single,   Single);
  convert_number_arithmetic_commands(single,   Single,   extended, Extended);
  convert_number_arithmetic_commands(double,   Double,   extended, Extended);
  convert_number_arithmetic_commands(extended, Extended, double,   Double);
  convert_number_arithmetic_commands(extended, Extended, single,   Single);
  float_arithmetic_commands(single, Single);
  float_arithmetic_commands(double, Double);
  float_arithmetic_commands(extended, Extended);
  system_commands(, TInt);
  system_commands(int, TInt);
  system_commands(int8, TInt8);
  system_commands(int16, TInt16);
  system_commands(int32, TInt32);
  system_commands(int64, TInt64);
  system_commands(uint, TUInt);
  system_commands(uint8, TUInt8);
  system_commands(uint16, TUInt16);
  system_commands(uint32, TUInt32);
  system_commands(uint64, TUInt64);
  system_commands(single, Single);
  system_commands(double, Double);
  system_commands(extended, Extended);
  misc_commands
  exception_commands
  file_commands
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
  constructor Create;
  destructor Destroy; override;
  procedure AddCommand(Name: PChar; Code: TCode; Immediate: Boolean = False);

  procedure InterpretName(W: PChar); overload;
  procedure Interpret(const S: PChar); overload;
  procedure Evaluate(Machine: TForthMachine; Command: PForthCommand);
  procedure EvaluateFile(Machine: TForthMachine; Command: PForthCommand);
  procedure MainLoop;
  procedure InterpretStep;
  procedure CompileStep;
  procedure RunStep;
  
  // команды времени компиляции
  procedure CompileError(const S: TString);
  procedure CompileWarring(const S: TString);
  procedure LogError(const S: TString);
  function NextChar: TChar;
  function NextName: TString; overload;
  function NextName(S: PChar; var I: Integer): TString; overload;
  function NextNamePassive: TString;
  function EOS: Boolean; // end of source
  procedure WriteEmbro(P: Pointer; Size: Integer);
  procedure WriteEmbroInt(I: Integer); overload;
  procedure WriteEmbroUInt(U: Cardinal); overload;
  procedure WriteEmbroChar(C: Char); overload;
  procedure WriteEmbroByte(B: Byte); overload;
  procedure PopEmbro(P: Pointer; Size: Integer);
  procedure WriteMnemonic(M: Cardinal);
  procedure WriteMnemonicByName(const Name: TString);
  function GetOpcodeByName(const Name: TString): TMnemonic;
  function GetCommandByOpcode(Opcode: Integer): PForthCommand;
  procedure CancelMnemonic;
  function ReserveName(const Name: TString): PForthCommand;
  
  procedure ReadEmbro(P: Pointer; Size: Integer);
  function ReadMnemonic: TMnemonic;

  procedure Push(P: Pointer; Size: Integer); overload;
  procedure Push(I: TInt); overload;
  procedure PushMnemonic(M: TMnemonic); overload;
  procedure PushPtr(P: Pointer); overload;
  procedure PushEmbroPtr(EmbroPtr: TInt); overload;
  procedure Pop(P: Pointer; Size: Integer); overload;
  function Pop: Integer; overload;
  function PopMnemonic: TMnemonic;
  function PopPtr: TPtr;
  function PopEmbroPtr: TEmbroPtr;

  function GetEmbroDumpLines: Integer;
  function GetEmbroDumpLine(Index: Integer): TString;
  function FindCommand(const Name: TString): PForthCommand;

  property UserData: Pointer read FUserData write FUserData;
  property Stack: TForthStack read FStack;
  property Current: Integer;
  property State: Integer read FState write FState;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'GIntArithmetic<T>'}{$ENDIF}
type
{$IFDEF FLAG_FPC}generic{$ENDIF} GIntArithmetic<T> = class
 protected
  FMachine: TForthMachine;
 public
  constructor Create(Machine: TForthMachine);
  procedure _plus(Machine: TForthMachine; Command: PForthCommand);
  procedure _minus(Machine: TForthMachine; Command: PForthCommand);
  procedure _star(Machine: TForthMachine; Command: PForthCommand);
  procedure _equel(Machine: TForthMachine; Command: PForthCommand);
  procedure _lt(Machine: TForthMachine; Command: PForthCommand);
  procedure _gt(Machine: TForthMachine; Command: PForthCommand);
  procedure _div(Machine: TForthMachine; Command: PForthCommand);
  procedure _mod(Machine: TForthMachine; Command: PForthCommand);
  procedure _dot(Machine: TForthMachine; Command: PForthCommand); virtual;
  procedure _abs(Machine: TForthMachine; Command: PForthCommand); virtual;
  procedure neg(Machine: TForthMachine; Command: PForthCommand); virtual;
  procedure _comma(Machine: TForthMachine; Command: PForthCommand); virtual;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'specialized arithmetic'}{$ENDIF}
SIntArithmetic = {$IFDEF FLAG_FPC}specialize{$ENDIF} GIntArithmetic<TInt>;
SInt8Arithmetic = {$IFDEF FLAG_FPC}specialize{$ENDIF} GIntArithmetic<TInt8>;
SInt16Arithmetic = {$IFDEF FLAG_FPC}specialize{$ENDIF} GIntArithmetic<TInt16>;
SInt32Arithmetic = {$IFDEF FLAG_FPC}specialize{$ENDIF} GIntArithmetic<TInt32>;
SInt64Arithmetic = {$IFDEF FLAG_FPC}specialize{$ENDIF} GIntArithmetic<TInt64>;
SUIntArithmetic = {$IFDEF FLAG_FPC}specialize{$ENDIF} GIntArithmetic<TUInt>;
SUInt8Arithmetic = {$IFDEF FLAG_FPC}specialize{$ENDIF} GIntArithmetic<TUInt8>;
SUInt16Arithmetic = {$IFDEF FLAG_FPC}specialize{$ENDIF} GIntArithmetic<TUInt16>;
SUInt32Arithmetic = {$IFDEF FLAG_FPC}specialize{$ENDIF} GIntArithmetic<TUInt32>;
SUInt64Arithmetic = {$IFDEF FLAG_FPC}specialize{$ENDIF} GIntArithmetic<TUInt64>;

TIntArithmetic = class(SIntArithmetic)
 public
  procedure _dot(Machine: TForthMachine; Command: PForthCommand); override;
  procedure _abs(Machine: TForthMachine; Command: PForthCommand); override;
  procedure neg(Machine: TForthMachine; Command: PForthCommand); override;
  procedure _comma(Machine: TForthMachine; Command: PForthCommand); override;
end;

TInt8Arithmetic = class(SInt8Arithmetic)
 public
  procedure _dot(Machine: TForthMachine; Command: PForthCommand); override;
  procedure _abs(Machine: TForthMachine; Command: PForthCommand); override;
  procedure neg(Machine: TForthMachine; Command: PForthCommand); override;
  procedure ToInt(Machine: TForthMachine; Command: PForthCommand);
  procedure FromInt(Machine: TForthMachine; Command: PForthCommand);
  procedure _comma(Machine: TForthMachine; Command: PForthCommand); override;
end;

TInt16Arithmetic = class(SInt16Arithmetic)
 public
  procedure _dot(Machine: TForthMachine; Command: PForthCommand); override;
  procedure _abs(Machine: TForthMachine; Command: PForthCommand); override;
  procedure neg(Machine: TForthMachine; Command: PForthCommand); override;
  procedure ToInt(Machine: TForthMachine; Command: PForthCommand);
  procedure FromInt(Machine: TForthMachine; Command: PForthCommand);
  procedure _comma(Machine: TForthMachine; Command: PForthCommand); override;
end;

TInt32Arithmetic = class(SInt32Arithmetic)
 public
  procedure _dot(Machine: TForthMachine; Command: PForthCommand); override;
  procedure _abs(Machine: TForthMachine; Command: PForthCommand); override;
  procedure neg(Machine: TForthMachine; Command: PForthCommand); override;
  procedure ToInt(Machine: TForthMachine; Command: PForthCommand);
  procedure FromInt(Machine: TForthMachine; Command: PForthCommand);
  procedure _comma(Machine: TForthMachine; Command: PForthCommand); override;
end;

TInt64Arithmetic = class(SInt64Arithmetic)
 public
  procedure _dot(Machine: TForthMachine; Command: PForthCommand); override;
  procedure _abs(Machine: TForthMachine; Command: PForthCommand); override;
  procedure neg(Machine: TForthMachine; Command: PForthCommand); override;
  procedure ToInt(Machine: TForthMachine; Command: PForthCommand);
  procedure FromInt(Machine: TForthMachine; Command: PForthCommand);
  procedure _comma(Machine: TForthMachine; Command: PForthCommand); override;
end;

TUIntArithmetic = class(SUIntArithmetic)
 public
  procedure _dot(Machine: TForthMachine; Command: PForthCommand); override;
  procedure ToInt(Machine: TForthMachine; Command: PForthCommand);
  procedure FromInt(Machine: TForthMachine; Command: PForthCommand);
  procedure _comma(Machine: TForthMachine; Command: PForthCommand); override;
end;

TUInt8Arithmetic = class(SUInt8Arithmetic)
 public
  procedure _dot(Machine: TForthMachine; Command: PForthCommand); override;
  procedure ToInt(Machine: TForthMachine; Command: PForthCommand);
  procedure FromInt(Machine: TForthMachine; Command: PForthCommand);
  procedure _comma(Machine: TForthMachine; Command: PForthCommand); override;
end;

TUInt16Arithmetic = class(SUInt16Arithmetic)
 public
  procedure _dot(Machine: TForthMachine; Command: PForthCommand); override;
  procedure ToInt(Machine: TForthMachine; Command: PForthCommand);
  procedure FromInt(Machine: TForthMachine; Command: PForthCommand);
  procedure _comma(Machine: TForthMachine; Command: PForthCommand); override;
end;

TUInt32Arithmetic = class(SUInt32Arithmetic)
 public
  procedure _dot(Machine: TForthMachine; Command: PForthCommand); override;
  procedure ToInt(Machine: TForthMachine; Command: PForthCommand);
  procedure FromInt(Machine: TForthMachine; Command: PForthCommand);
  procedure _comma(Machine: TForthMachine; Command: PForthCommand); override;
end;

TUInt64Arithmetic = class(SUInt64Arithmetic)
 public
  procedure _dot(Machine: TForthMachine; Command: PForthCommand); override;
  procedure ToInt(Machine: TForthMachine; Command: PForthCommand);
  procedure FromInt(Machine: TForthMachine; Command: PForthCommand);
  procedure _comma(Machine: TForthMachine; Command: PForthCommand); override;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}

function IsImmediate(Command: PForthCommand): Boolean;
procedure SetImmediate(Command: PForthCommand; I: Boolean);
function CopyStrToPChar(const S: TString): PChar;

procedure WordListClear(var WL: TWordSpace);
function WordListInsert(var WL: TWordSpace; Command: PForthCommand): Integer;
function WordListFind(var WL: TWordSpace; S: TString; var Opcode: TOpcode): Boolean;

implementation

function IsImmediate(Command: PForthCommand): Boolean;
begin
  Result := (Command^.Flags and 1) > 0;
end;

procedure SetImmediate(Command: PForthCommand; I: Boolean);
begin
  Command^.Flags := Command^.Flags or Ord(I);
end;

function CopyStrToPChar(const S: TString): PChar;
begin
  Result := StrAlloc(Length(S) + 1);
  StrCopy(Result, PChar(S));
end;

procedure WordListClear(var WL: TWordSpace);
begin
  SetLength(WL.C, 0);
  WL.L := 0;
  WL.S := 0;
end;

function WordListInsert(var WL: TWordSpace; Command: PForthCommand): Integer;
begin
  SetLength(WL.C, Length(WL.C) + 1);
  WL.C[High(WL.C)] := Command;
  WL.L := Length(WL.C);
  Result := High(WL.C);
end;

function WordListFind(var WL: TWordSpace; S: TString; var Opcode: TOpcode): Boolean;
var
  I: Integer;
begin
  for I := WL.L - 1 downto 0 do
    if TString(WL.C[I]) = S then begin
      Result := True;
      Opcode := I;
      Exit;
    end;
  Result := False;
end;

{$IFNDEF FLAG_FPC}{$REGION 'TReturnStack'}{$ENDIF}
procedure TReturnStack.ptrpush(P: Pointer);
begin
  Push(@P, SizeOf(P));
end;

function TReturnStack.ptrpop: Pointer;
begin
  Pop(@Result, SizeOf(Result));
end;

function TReturnStack.ptrgettop: Pointer;
begin
  Dup(SizeOf(Pointer));
  Result := ptrpop;
end;

procedure TReturnStack.embropush(P: Cardinal);
begin
  Push(@P, SizeOf(P));
end;

function TReturnStack.embropop: Cardinal;
begin
  Pop(@Result, SizeOf(Result));
end;

function TReturnStack.embrogettop: Cardinal;
begin
  Dup(SizeOf(Cardinal));
  Result := embropop;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TStackCommands'}{$ENDIF}
constructor TStackCommands.Create(Machine: TForthMachine; Size: Integer);
begin
  FMachine := Machine;
  FSize := Size;
  SetLength(Temp, FSize);
end;

procedure TStackCommands.push(P: Pointer);
begin
  FMachine.Push(P, FSize);
end;

procedure TStackCommands._push;
var
  Temp: array of Byte;
begin
  //SetLength(Temp, FSize);
  //FMachine.ReadEmbro(@Temp[0], FSize);
  //FMachine.Stack.pushn(@Temp[0], FSize);
end;

procedure TStackCommands.compile_push;
var
  Name: TString;
  I: Integer;
begin
  Name := FMachine.NextName;
  I := StrToIntDef(Name, -3535);
  if I = -3535 then
    FMachine.CompileError('need number, but ' + Name + ' found')
  else
    FMachine.WriteEmbroInt(I);
end;

procedure TStackCommands.pop(P: Pointer);
begin
  //FMachine.Stack.pop(P, FSize);
end;

procedure TStackCommands.dup;
begin
  //FMachine.Stack.dupn(FSize);
end;

procedure TStackCommands.drop;
begin
  //FMachine.Stack.dropn(FSize);
end;

procedure TStackCommands.swap;
begin
  //FMachine.Stack.swap(FSize);
end;

procedure TStackCommands.over;
begin
  //FMachine.Stack.overn(FSize);
end;

procedure TStackCommands.lrot;
begin
  //FMachine.Stack.lrot(FSize);
end;

procedure TStackCommands.rrot;
begin
  //FMachine.Stack.rrot(FSize);
end;

procedure TStackCommands.lrotn;
begin
  //FMachine.Stack.lrotn(FSize);
end;

procedure TStackCommands.rrotn;
begin
  //FMachine.Stack.rrotn(FSize);
end;

procedure TStackCommands._dog(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  FMachine.FPtrStackCommands.Pop(@P);
  Push(P);
end;

procedure TStackCommands._exclamation(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  FMachine.FPtrStackCommands.Pop(@P);
  Pop(@Temp[0]);
  Move(Temp[0], P^, FSize);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TBoolCommands'}{$ENDIF}
constructor TBoolCommands.Create(Machine: TForthMachine);
begin
  FMachine := Machine;
end;

procedure TBoolCommands.push;
var
  B: TInt;
begin
  FMachine.ReadEmbro(@B, SizeOf(B));
  FMachine.WUI(B);
end;

procedure TBoolCommands.compile_push;
var
  Name: TString;
begin
  Name := Machine.NextName;
  if Name = 'true' then
    Machine.WriteEmbroInt(BOOL_TRUE)
  else if Name = 'false' then
    Machine.WriteEmbroInt(BOOL_FALSE)
  else
    Machine.CompileError('need bool constant, but "' + Name + '" found');
end;

procedure TBoolCommands._false;
begin
  FMachine.WUI(BOOL_FALSE);
end;

procedure TBoolCommands._true;
begin
  FMachine.WUI(BOOL_TRUE);
end;

procedure TBoolCommands._not;
//var
//  a: TInt;
begin
  {FMachine.WUI(a);
  if a = BOOL_FALSE then
    a := BOOL_TRUE
  else
    a := BOOL_FALSE;
  FMachine.WUI(a);}
  FMachine.WUI(not FMachine.WOI);
end;

procedure TBoolCommands._or;
var
  a, b: TInt;
begin
  {FMachine.WUI(a);
  FMachine.WUI(b);
  if (a = BOOL_FALSE) and (b = BOOL_FALSE) then
    a := BOOL_FALSE
  else
    a := BOOL_TRUE;
  FMachine.WUI(a);}
  FMachine.WUI(FMachine.WOI or FMachine.WOI);
end;

procedure TBoolCommands._and;
//var
//  a, b: TInt;
begin
  {a := FMachine.WOI;
  b := FMachine.WOI;
  if (a = BOOL_FALSE) or (b = BOOL_FALSE) then
    a := BOOL_FALSE
  else
    a := BOOL_TRUE;
  FMachine.WUI(a);}
  FMachine.WUI(FMachine.WOI and FMachine.WOI);
end;

procedure TBoolCommands._xor;
//var
//  a, b: TInt;
begin
  {a := FMachine.WOI;
  b := FMachine.WOI;
  if (a = BOOL_FALSE) xor (b = BOOL_FALSE) then
    a := BOOL_TRUE
  else
    a := BOOL_FALSE;
  FMachine.WUI(a);}
  FMachine.WUI(FMachine.WOI xor FMachine.WOI);
end;

procedure TBoolCommands._dot;
var
  a: TInt;
begin
  a := FMachine.WOI;
  if a = 0 then
    Write('FALSE ')
  else
    Write('TRUE ')
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TConsoleCommands'}{$ENDIF}
constructor TConsoleCommands.Create(Machine: TForthMachine);
begin
  FMachine := Machine;
end;

procedure TConsoleCommands.cr;
begin
  Writeln;
end;

procedure TConsoleCommands.emit;
var
  I: Integer;
begin
  //FMachine.Stack.Pop(@I, SizeOf(I));
  Write(TChar(I));
end;

procedure TConsoleCommands.space;
begin
  Write(' ');
end;

procedure TConsoleCommands.spaces;
var
  I: TInt;
begin
  I := FMachine.WOI;
  while I > 0 do begin
    SPACE(Machine, Command);
    Dec(I);
  end;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TControlCommands'}{$ENDIF}
constructor TControlCommands.Create(Machine: TForthMachine);
begin
  FMachine := Machine;
end;

procedure TControlCommands.branch;
begin
  FMachine.EC := FMachine.ERU;
end;

procedure TControlCommands._ask_branch;
var
  B: TInt;
  Temp: Cardinal;
begin
  B := FMachine.WOI;
  Temp := FMachine.ERU;
  if B = BOOL_FALSE then
    FMachine.EC := Temp;
end;

procedure TControlCommands._gt_mark;
var
  Temp: Cardinal;
begin
  Temp := Machine.EL;
  FMachine.WUU(Temp);
  FMachine.EWU(Temp);
end;

procedure TControlCommands._gt_resolve;
var
  Temp: Cardinal;
  PC: Cardinal;
begin
  Temp := FMachine.WOU;
  PC := Machine.EL;
  Move(PC, Pointer(@Machine.E[Temp])^, SizeOf(PC));
end;

procedure TControlCommands._lt_mark;
var
  Temp: Cardinal;
begin
  Temp := Machine.EL;
  FMachine.WUU(Temp);
end;

procedure TControlCommands._lt_resolve;
var
  Temp: Cardinal;
  PC: Cardinal;
begin
  Temp := FMachine.WOU;
  FMachine.EWU(Temp);
end;

procedure TControlCommands._exit;
begin
  //Log('EXIT');
  if TUInt(FMachine.RB) >= TUInt(FMachine.RP) then begin
    //FMachine.EC := Length(FMachine.FEmbro)
    Machine.RB := Machine.ROP;
    Machine.FState := Machine.ROI;
  end else
    FMachine.EC := FMachine.ROI;
end;

procedure TControlCommands.recurse(Machine: TForthMachine; Command: PForthCommand);
begin
  Machine.EWO(Machine.FLastMnemonic);
end;

procedure TControlCommands.call(Machine: TForthMachine; Command: PForthCommand);
begin
  // Writeln('INSIDE CALL "' + Command^.Name + '"');
  //Writeln('called function ' + Command^.Name);
  if Machine.FState = FS_RUN then
    Machine.RUI(Machine.EC)
  else begin
    Machine.RUI(Machine.FState);
    Machine.RUP(Machine.RB);
    Machine.RB := Machine.RP;
  end;
  Machine.EC := Integer(Command^.Data);
  Machine.FState := FS_RUN;
end;

procedure TControlCommands.compile_def(Machine: TForthMachine; Command: PForthCommand);
var
  Name: TString;
  NewCommand: PForthCommand;
  PName: PChar;
begin
  {Machine.CancelMnemonic;
  Machine.WriteMnemonicByName('branch');
  Machine.WriteMnemonicByName('>mark');
  _gt_mark(Machine, Command);}
  //Writeln('INSIDE compile_def');
  Name := Machine.NextName;
  PName := CopyStrToPChar(Name);
  NewCommand := Machine.ReserveName('');
  NewCommand^.Code := call;
  Integer(NewCommand^.Data) := FMachine.EL;
  Machine.FState := FS_COMPILE;
  Machine.WUI(Machine.FLastMnemonic);
  Machine.WUP(PName);
  Machine.WUI(101);
  //Writeln('RESERVER NAME ' + NewCommand^.Name);
end;

procedure TControlCommands.compile_skip_to_end(Machine: TForthMachine; Command: PForthCommand);
begin
  if Integer(Machine.WP^) <> 101 then begin
    Machine.LogError('Нельзя использовать skip-to; внутри конструкций (на вершине стека не colon-id)');
    Exit;
  end;
  Machine.FControlCommands._gt_mark(Machine, nil);
  Machine.WUI(201);
end;

procedure TControlCommands.compile_enddef(Machine: TForthMachine; Command: PForthCommand);
var
  S: TString;
  Index: TInt;
  P: PChar;
  ID: Integer;
begin
  //S := Machine.FStringCommands.str_pop(Machine, Command);
  //Machine.C[Machine.WOI]^.Name := PChar(TString(PChar(@TStrRec(S^).Sym[0])));
  //Machine.FStringCommands.DelRef(S);
  ID := Machine.WOI;
  if ID = 201 then begin
    Machine.FControlCommands._gt_resolve(Machine, nil);
  end;
  P := Machine.WOP;
  Index := Machine.WOI;
  Machine.C[Index]^.Name := P;
  Machine.EWO('exit');
  Machine.FState := FS_INTERPRET;
  //Writeln('LAST COMMAND ', High(Machine.C), ' ' + Machine.C[High(Machine.C)].Name);
end;

procedure TControlCommands.compile_scattered_def(Machine: TForthMachine; Command: PForthCommand);
var
  Name: TString;
  C: PForthCommand;
begin
  Machine.FState := FS_COMPILE;
  Name := Machine.NextName;
  C := Machine.FindCommand(Name);
  if C = nil then begin
    Machine.LogError('Command not found: ' + Name);
    Exit;
  end;
  Machine.WUU(Cardinal((@Machine.E[Cardinal(C^.Param)])^));
  Cardinal((@Machine.E[Cardinal(C^.Param)])^) := FMachine.EL;
  Machine.WUP(C);
end;

procedure TControlCommands.compile_scattered_enddef(Machine: TForthMachine; Command: PForthCommand);
var
  C: PForthCommand;
  P: Cardinal;
begin
  C := Machine.WOP;
  P := Cardinal(C^.Param);
  Machine.EWO('branch');
  Cardinal(C^.Param) := Machine.EL;
  Machine.EWU(Machine.WOU);
  Machine.FState := FS_INTERPRET;
end;

procedure TControlCommands.scattered_dots(Machine: TForthMachine; Command: PForthCommand); 
begin
  Machine.EWO('branch');
  Cardinal(Machine.C[Machine.FLastMnemonic]^.Param) := Machine.EL;
  Machine.EWU(Machine.EL + SizeOf(TUInt));
end;

procedure TControlCommands.immediate(Machine: TForthMachine; Command: PForthCommand);
begin
  SetImmediate(Machine.C[Machine.FLastMnemonic], True);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TEmbroCommands'}{$ENDIF}
procedure TEmbroCommands.compile(Machine: TForthMachine; Command: PForthCommand);
var
  U: TUInt;
begin
  if Machine.State = FS_COMPILE then begin
    Machine.EWO('compile');
    Machine.EWO(Machine.NextName);
  end else begin
    Machine.EWO(Machine.C[Machine.ERU].Name);
  end;
end;

procedure TEmbroCommands.execute(Machine: TForthMachine; Command: PForthCommand);
begin
  Machine.InterpretName(PChar(Machine.NextName));
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TDataCommands'}{$ENDIF}
procedure TDataCommands._create(Machine: TForthMachine; Command: PForthCommand);
var
  Name: TString;
  NewCommand: PForthCommand;
begin
  Name := Machine.NextName;
  NewCommand := Machine.ReserveName(Name);
  NewCommand^.Code := putdataptr;
  NewCommand^.Data := Machine.Here;
end;

procedure TDataCommands.putdataptr(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  P := Command^.Data;
  Machine.WUP(P);
end;

procedure TDataCommands.here(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  // FIXME: P не постоянен
  P := Machine.Here;
  Machine.FPtrStackCommands.Push(@P);
end;

procedure TDataCommands.allot(Machine: TForthMachine; Command: PForthCommand);
var
  I: Integer;
begin
  I := Machine.WOI;
  Machine.IncHere(I);
end;

procedure TDataCommands.to_int(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.State = FS_COMPILE then
    compile_to(Machine, Machine.NextName, SizeOf(TInt))
  else
    interpete_to(Machine, Machine.NextName, SizeOf(TInt));
end;

procedure TDataCommands.to_int8(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.State = FS_COMPILE then
    compile_to(Machine, Machine.NextName, SizeOf(TInt8))
  else
    interpete_to(Machine, Machine.NextName, SizeOf(TInt8));
end;

procedure TDataCommands.to_int16(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.State = FS_COMPILE then
    compile_to(Machine, Machine.NextName, SizeOf(TInt16))
  else
    interpete_to(Machine, Machine.NextName, SizeOf(TInt16));
end;

procedure TDataCommands.to_int32(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.State = FS_COMPILE then
    compile_to(Machine, Machine.NextName, SizeOf(TInt32))
  else
    interpete_to(Machine, Machine.NextName, SizeOf(TInt32));
end;

procedure TDataCommands.to_int64(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.State = FS_COMPILE then
    compile_to(Machine, Machine.NextName, SizeOf(TInt64))
  else
    interpete_to(Machine, Machine.NextName, SizeOf(TInt64));
end;

procedure TDataCommands.to_uint(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.State = FS_COMPILE then
    compile_to(Machine, Machine.NextName, SizeOf(TUInt))
  else
    interpete_to(Machine, Machine.NextName, SizeOf(TUInt));
end;

procedure TDataCommands.to_uint8(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.State = FS_COMPILE then
    compile_to(Machine, Machine.NextName, SizeOf(TUInt8))
  else
    interpete_to(Machine, Machine.NextName, SizeOf(TUInt8));
end;

procedure TDataCommands.to_uint16(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.State = FS_COMPILE then
    compile_to(Machine, Machine.NextName, SizeOf(TUInt16))
  else
    interpete_to(Machine, Machine.NextName, SizeOf(TUInt16));
end;

procedure TDataCommands.to_uint32(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.State = FS_COMPILE then
    compile_to(Machine, Machine.NextName, SizeOf(TUInt32))
  else
    interpete_to(Machine, Machine.NextName, SizeOf(TUInt32));
end;

procedure TDataCommands.to_uint64(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.State = FS_COMPILE then
    compile_to(Machine, Machine.NextName, SizeOf(TUint64))
  else
    interpete_to(Machine, Machine.NextName, SizeOf(TUint64));
end;

procedure TDataCommands.to_ptr(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.State = FS_COMPILE then
    compile_to(Machine, Machine.NextName, SizeOf(Pointer))
  else
    interpete_to(Machine, Machine.NextName, SizeOf(Pointer));
end;

procedure TDataCommands.compile_to;
begin
  case Size of
    1: Machine.WriteMnemonicByName(' 8to');
    2: Machine.WriteMnemonicByName(' 16to');
    4: Machine.WriteMnemonicByName(' 32to');
    8: Machine.WriteMnemonicByName(' 64to');
  else
    Machine.WriteMnemonicByName(' to');
    Machine.WriteEmbroByte(Size);
  end;
  Machine.WriteMnemonicByName(Name);
end;

procedure TDataCommands.run_to(Machine: TForthMachine; Command: PForthCommand);
var
  Size: Byte;
  M: TMnemonic;
  Temp: array[0..255] of Byte;
begin
  Machine.ReadEmbro(@Size, SizeOf(Size));
  M := Machine.ReadMnemonic;
  Machine.Pop(@Temp[0], Size);
  Move(Temp[0], Machine.C[M].Data^, Size);
end;

procedure TDataCommands.run_8to(Machine: TForthMachine; Command: PForthCommand);
var
  Temp: TUint8;
begin
  Machine.Pop(@Temp, SizeOf(Temp));
  Move(Temp, Machine.C[Machine.ReadMnemonic].Data^, SizeOf(Temp));
end;

procedure TDataCommands.run_16to(Machine: TForthMachine; Command: PForthCommand);
var
  Temp: TUint16;
begin
  Machine.Pop(@Temp, SizeOf(Temp));
  Move(Temp, Machine.C[Machine.ReadMnemonic].Data^, SizeOf(Temp));
end;

procedure TDataCommands.run_32to(Machine: TForthMachine; Command: PForthCommand);
var
  Temp: TUint32;
begin
  Machine.Pop(@Temp, SizeOf(Temp));
  Move(Temp, Machine.C[Machine.ReadMnemonic].Data^, SizeOf(Temp));
end;

procedure TDataCommands.run_64to(Machine: TForthMachine; Command: PForthCommand);
var
  Temp: TUint64;
begin
  Machine.Pop(@Temp, SizeOf(Temp));
  Move(Temp, Machine.C[Machine.ReadMnemonic].Data^, SizeOf(Temp));
end;

procedure TDataCommands.interpete_to;
var
  C: PForthCommand;
  Temp: array of Byte;
begin
  C := Machine.FindCommand(Name);
  if C = nil then begin
    Machine.LogError('cannot find command ' + Name);
    Exit;
  end;
  SetLength(Temp, Size);
  // FIXME
  //Machine.(@Temp[0], Size);
  Move(Temp[0], C^.Data^, Size);
end;

procedure TDataCommands._nil(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  P := nil;
  Machine.WUP(nil);
end;

procedure TDataCommands.ptr_comma(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  Machine.FPtrStackCommands.Pop(@P);
  Move(P, Machine.Here^, SizeOf(Pointer));
  Machine.IncHere(SizeOf(Pointer)); 
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TTypeCommands'}{$ENDIF}
procedure TTypeCommands.typeof(machine: tforthmachine; command: pforthcommand);
var
  Name: TString;
  I: Integer;
  P: PType;
begin
  if Machine.State = FS_COMPILE then
    compile_type(Machine, PChar(Machine.NextName))
  else begin
    Name := Machine.NextName;
    for I := 0 to High(Machine.FTypes) do
      if TString(Machine.FTypes[I].Name) = Name then begin
        P := @Machine.FTypes[I];
        Machine.FPtrStackCommands.Push(@P);
        Exit;
      end;
    Machine.LogError('cannot find type "' + Name + '"');
  end;
end;

procedure TTypeCommands.type_size(Machine: TForthMachine; Command: PForthCommand);
var
  P: PType;
begin
  P := Machine.WOP;
  Machine.WUI(P^.Size);
end;

procedure TTypeCommands.compile_type(Machine: TForthMachine; Name: PChar);
var
  I: Integer;
  P: PType;
begin
  for I := 0 to High(Machine.FTypes) do
    if TString(Machine.FTypes[I].Name) = TString(Name) then begin
      Machine.EWO(' typeof');
      Machine.EWI(I);
      Exit;
    end;
  Machine.LogError('cannot find type "' + Name + '"');
end;

procedure TTypeCommands.interpete_type(Machine: TForthMachine; Name: PChar);
var
  I: Integer;
  P: PType;
begin
  for I := 0 to High(Machine.FTypes) do
    if TString(Machine.FTypes[I].Name) = TString(Name) then begin
      Machine.WUP(@Machine.FTypes[I]);
      Exit;
    end;
  Machine.LogError('cannot find type "' + Name + '"');
end;

procedure TTypeCommands.run_type;
var
  I: TInt;
  P: PType;
begin
  I := Machine.ERI;
  P := @Machine.FTypes[I];
  Machine.WUP(P);
end;

procedure TTypeCommands._void(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'void')
  else
    interpete_type(Machine, 'void');
end;

procedure TTypeCommands._int(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'int')
  else
    interpete_type(Machine, 'int');
end;

procedure TTypeCommands._int8(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'int8')
  else
    interpete_type(Machine, 'int8');
end;

procedure TTypeCommands._int16(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'int16')
  else
    interpete_type(Machine, 'int16');
end;

procedure TTypeCommands._int32(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'int32')
  else
    interpete_type(Machine, 'int32');
end;

procedure TTypeCommands._int64(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'int64')
  else
    interpete_type(Machine, 'int64');
end;

procedure TTypeCommands._uint(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'uint')
  else
    interpete_type(Machine, 'uint');
end;

procedure TTypeCommands._uint8(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'uint8')
  else
    interpete_type(Machine, 'uint8');
end;

procedure TTypeCommands._uint16(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'uint16')
  else
    interpete_type(Machine, 'uint16');
end;

procedure TTypeCommands._uint32(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'uint32')
  else
    interpete_type(Machine, 'uint32');
end;

procedure TTypeCommands._uint64(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'uint64')
  else
    interpete_type(Machine, 'uint64');
end;

procedure TTypeCommands._bool(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'bool')
  else
    interpete_type(Machine, 'bool');
end;

procedure TTypeCommands._str(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'str')
  else
    interpete_type(Machine, 'str');
end;

procedure TTypeCommands._pchar(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'pchar')
  else
    interpete_type(Machine, 'pchar');
end;

procedure TTypeCommands._ptr(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'ptr')
  else
    interpete_type(Machine, 'ptr');
end;

procedure TTypeCommands._type(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'type')
  else
    interpete_type(Machine, 'type');
end;

procedure TTypeCommands._single(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'single')
  else
    interpete_type(Machine, 'single');
end;

procedure TTypeCommands._double(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'double')
  else
    interpete_type(Machine, 'double');
end;

procedure TTypeCommands._extended(Machine: TForthMachine; Command: PForthCommand);
begin
  if Machine.FState = FS_COMPILE then
    compile_type(Machine, 'extended')
  else
    interpete_type(Machine, 'extended');
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TAlienCommands'}{$ENDIF}
procedure TAlienCommands.lib_load(Machine: TForthMachine; Command: PForthCommand);
var
  P: PChar;
  L: TLib;
  B: TInt;
begin
  Machine.FPtrStackCommands.Pop(@P);
  L := TLib.Create(P);
  Machine.FPtrStackCommands.Push(@L);
  B := BOOL_TRUE * Ord(L.Ready) + BOOL_FALSE * Ord(not L.Ready);
  Machine.WUI(B);
end;

procedure TAlienCommands.lib_unload(Machine: TForthMachine; Command: PForthCommand);
var
  L: TLib;
begin
  Machine.FPtrStackCommands.Pop(@L);
  L.Free;
end;

procedure TAlienCommands.lib_fun(Machine: TForthMachine; Command: PForthCommand);
var
  L: TLib;
  P: PChar;
begin
  Machine.FPtrStackCommands.Pop(@P);
  Machine.FPtrStackCommands.Pop(@L);
  P := L.GetProcAddress(P);
  Machine.FPtrStackCommands.Push(@L);
  Machine.FPtrStackCommands.Push(@P);
end;

procedure TAlienCommands.alien_fun(Machine: TForthMachine; Command: PForthCommand);
var
  Name: TString;
  C: PForthCommand;
  T: PType;
begin
  if Machine.State = FS_COMPILE then begin
    Machine.LogError(Command^.Name + ' command cannot work in compile mode');
    Exit;
  end;
  Name := Machine.NextName;
  New(C);
  C^.Name := StrAlloc(Length(Name) + 1);
  StrCopy(C^.Name, PChar(Name));
  Log('Pushed command ' + C^.Name);
  Machine.WUP(C);
  T := @Machine.FTypes[0];
  Machine.WUP(T);
end;

procedure Test2(A, B: Integer); stdcall;
begin
  Log('Test ' + IntToStr(A - B));
end;

function Test3(A, B: Integer): Integer; stdcall;
begin
  Log('Test ' + IntToStr(A - B));
  Result := A - B;
end;

function Test(A, B: TInt64): TInt64; stdcall;
begin
  Log('Test ' + IntToStr(A - B));
  Result := A - B;
end;

procedure TAlienCommands.alien_endfun(Machine: TForthMachine; Command: PForthCommand);
var
  Conv: Integer;
  ReturnType: PType;
  T: PType;
  Types: array of PType;
  C, C2: PForthCommand;
  P: Pointer;
  B: Byte;
  I: Integer;
  S: TInt8;
begin
  if Machine.State = FS_COMPILE then begin
    Machine.LogError(Command^.Name + ' command cannot work in compile mode');
    Exit;
  end;
  Conv := Machine.WOI;
  ReturnType := Machine.WOP;
  T := Machine.WOP;
  SetLength(Types, 0);
  while T <> @Machine.FTypes[0] do begin
    Log(IntToStr(Length(Types)) + ': ' + T^.Name);
    SetLength(Types, Length(Types) + 1);
    Types[High(Types)] := T;
    T := Machine.WOP;
  end;
  C2 := Machine.WOP;
  Log('Poped command ' + C2^.Name);
  C := Machine.ReserveName(TString(C2^.Name));
  StrDispose(C2^.Name);
  Dispose(C2);
  if Conv = CONV_STDCALL then 
        begin
          C^.Code := invoke_stdcall;
          C^.Data := Machine.Here;
          P := @Test;
          Move(P, Machine.Here^, SizeOf(P));
          Machine.IncHere(SizeOf(P));
          B := ReturnType^.Size;
          if B <= 8 then begin
            S := B;
            if S > 4 then
              S := 4;
            Move(S, Machine.Here^, SizeOf(S));
            Machine.IncHere(SizeOf(S));
            B := B - S;
            S := B;
            if S > 4 then
              S := 4;
            Move(S, Machine.Here^, SizeOf(S));
            Machine.IncHere(SizeOf(S));
            S := 0;
            Move(S, Machine.Here^, SizeOf(S));
            Machine.IncHere(SizeOf(S));
          end else begin
            S := 0;
            Move(S, Machine.Here^, SizeOf(S));
            Machine.IncHere(SizeOf(S));
            S := 0;
            Move(S, Machine.Here^, SizeOf(S));
            Machine.IncHere(SizeOf(S));
            S := B;
            Move(S, Machine.Here^, SizeOf(S));
            Machine.IncHere(SizeOf(S));
          end;
          for I := 0 to High(Types) do begin
            B := Types[I]^.Size;
            while B > 0 do begin
              S := B mod 4;
              if S = 0 then
                S := 4;
              B := B - S;
              S := -S;
              Move(S, Machine.Here^, SizeOf(S));
              Machine.IncHere(SizeOf(S));
            end;
          end;
          B := 0;
          Move(B, Machine.Here^, SizeOf(B));
          Machine.IncHere(SizeOf(B));
        end
  else if Conv = CONV_CDECL then 
        begin
          C^.Code := invoke_cdecl;
          C^.Data := Machine.Here;
          P := nil;
          Move(P, Machine.Here^, SizeOf(P));
        end
  else begin
    Machine.LogError(C^.Name + ' unknown code convension');
    Exit;
  end;
  Log('Created command ' + C^.Name);
end;

procedure TAlienCommands.invoke_stdcall(Machine: TForthMachine; Command: PForthCommand);
var
  Fun: Pointer;
  Stack: Pointer;
  Data: Pointer;
begin
  Data := Command^.Data;
  Fun := Pointer(Command^.Data^);
  Stack := Machine.WP;
  asm
    mov ebx, Stack
    mov ecx, Data
    add ecx, 7 // пропускаем Fun и return-size
    jmp @startcycle
    @cycle:
      add ebx, eax
      push DWORD [ebx] // переносим очередной параметр на стек
      inc ecx
    @startcycle:
      movsx eax, BYTE [ecx] // получаем знаковое значение текущего байта
      cmp eax, 0
      jnz @cycle // если 0, то выходим из цикла
    @endcycle:
      mov Stack, ebx
      call [Fun] // вызываем функцию
      mov ebx, Stack
      mov ecx, Fun + 4
      mov DWORD [ebx], eax
      add ebx, BYTE [ecx]
      inc ecx
      mov DWORD [ebx], edx
      add ebx, BYTE [ecx]
      inc ecx
      mov esi, eax
      mov edi, ebx
      movzx ecx, BYTE [ecx]
      rep MOVSw
      add ebx, ecx
    @endofcall:
      mov Stack, ebx // запоминаем положение стека
  end;
  Log('SUB: ' + IntToStr(TUInt(Machine.WP) - TUInt(Stack)));
  Machine.WP := Stack;
end;

procedure TAlienCommands.invoke_cdecl(Machine: TForthMachine; Command: PForthCommand);
begin
end;

procedure TAlienCommands._conv_stdcall(Machine: TForthMachine; Command: PForthCommand);
begin
  Machine.WUI(CONV_STDCALL);
end;

procedure TAlienCommands._conv_cdecl(Machine: TForthMachine; Command: PForthCommand);
begin
  Machine.WUI(CONV_CDECL);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TStringCommands'}{$ENDIF}
constructor TStringCommands.Create(Machine: TForthMachine);
begin
  FMachine := Machine;
  GetMem(FStrNil, 2*SizeOf(TInt) + 1);
  PStrRec(FStrNil)^.Ref := 1;
  PStrRec(FStrNil)^.Len := 0;
  PStrRec(FStrNil)^.Sym := #0;
end;

procedure TStringCommands.pchar_alloc(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
  Size: Integer;
begin
  Size := Machine.WOI;
  GetMem(P, Size + 1);
  Machine.WUP(P);
end;

procedure TStringCommands.pchar_free(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  P := Machine.WOP;
  FreeMem(P);
end;

procedure TStringCommands.pchar_len(Machine: TForthMachine; Command: PForthCommand);
var
  P: PByte;
  L: Integer;
begin
  P := Machine.WOP;
  L := strlen(PChar(P));
  Machine.WUI(L);
end;

procedure TStringCommands.pchar_concat(Machine: TForthMachine; Command: PForthCommand);
var
  S1, S2, D: PChar;
begin
  S2 := Machine.WOP;
  S1 := Machine.WOP;
  D := StrAlloc(StrLen(S1) + StrLen(S2) + 1);
  Move(S1^, D^, StrLen(S1));
  Move(S2^, (@(PArrayOfByte(D)^[StrLen(S1)]))^, StrLen(S2));
  D[StrLen(S1) + StrLen(S2)] := #0;
  Machine.WUP(D);
end;

procedure TStringCommands.pchar_equel(Machine: TForthMachine; Command: PForthCommand);
var
  S1, S2: PChar;
begin
  S1 := Machine.WOP;
  S2 := Machine.WOP;
  if StrComp(S1, S2) = 0 then
    Machine.WUI(BOOL_TRUE)
  else
    Machine.WUI(BOOL_FALSE)
end;

procedure TStringCommands.pchar_dq(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
  C: TChar;
begin
  if Machine.FState = FS_COMPILE then begin
    compile_pchar_dq(Machine, Command);
  end else begin
    SetLength(FPChars, Length(FPChars) + 1);
    SetLength(FPChars[High(FPChars)], 0); 
    C := Machine.NextChar;
    while C <> '"' do begin
      SetLength(FPChars[High(FPChars)], Length(FPChars[High(FPChars)]) + 1); 
      FPChars[High(FPChars)][High(FPChars[High(FPChars)])] := C; 
      C := Machine.NextChar;
    end; 
    SetLength(FPChars[High(FPChars)], Length(FPChars[High(FPChars)]) + 1); 
    FPChars[High(FPChars)][High(FPChars[High(FPChars)])] := #0; 
    Machine.WUP(FPChars[High(FPChars)]);
  end;
end;

procedure TStringCommands.compile_pchar_dq(Machine: TForthMachine; Command: PForthCommand);
var
  C: TChar;
begin
  Machine.EWO(' pchar"');
  C := Machine.NextChar;
  while C <> '"' do begin
    Machine.EWC(C);
    C := Machine.NextChar;
  end;
  C := #0;
  Machine.EWC(C);
end;

procedure TStringCommands.run_pchar_dq(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  P := @Machine.E[Machine.EC];
  Machine.WUP(P);
  while Machine.E[Machine.EC] <> 0 do
    Inc(Machine.EC);
  Inc(Machine.EC);
end;

procedure TStringCommands.pchar_dot(Machine: TForthMachine; Command: PForthCommand);
var
  S: PChar;
begin
  S := Machine.WOP;
  Write(S);
end;

procedure TStringCommands.AddRef(S: TStr);
begin
  Inc(PStrRec(S)^.Ref);
end;

procedure TStringCommands.DelRef(S: TStr);
begin
  Dec(PStrRec(S)^.Ref);
  if PStrRec(S)^.Ref < 1 then begin
    FreeMem(S);
  end;
end;

procedure TStringCommands.str_push(Machine: TForthMachine; Command: PForthCommand; S: TString);
var
  FS: TStr;
begin
  GetMem(FS, SizeOf(Integer)*2 + Length(S) + 1);
  PStrRec(FS)^.Len := Length(S);
  PStrRec(FS)^.Ref := 0;
  Move(S[1], PStrRec(FS)^.Sym[0], Length(S));
  PStrRec(FS)^.Sym[Length(S)] := #0;
  str_push(Machine, Command, FS);
end;

procedure TStringCommands.str_push(Machine: TForthMachine; Command: PForthCommand; S: TStr);
begin
  AddRef(S);
  Machine.WUP(S);
end;

function TStringCommands.str_pop(Machine: TForthMachine; Command: PForthCommand): TStr;
begin
  Result := Machine.WOP;
end;

procedure TStringCommands.str_drop(Machine: TForthMachine; Command: PForthCommand);
begin
  DelRef(str_pop(Machine, Command));
end;

procedure TStringCommands.str_dup(Machine: TForthMachine; Command: PForthCommand);
var
  S: TStr;
begin
  S := str_pop(Machine, Command);
  str_push(Machine, Command, S);
  str_push(Machine, Command, S);
  DelRef(S);
end;

procedure TStringCommands.str_over(Machine: TForthMachine; Command: PForthCommand);
var
  A, B: TStr;
begin
  B := str_pop(Machine, Command);
  A := str_pop(Machine, Command);
  str_push(Machine, Command, A);
  str_push(Machine, Command, B);
  str_push(Machine, Command, A);
  DelRef(A);
  DelRef(B);
end;


procedure TStringCommands.str_len(Machine: TForthMachine; Command: PForthCommand);
begin
  S := Machine.WOP;
  Machine.WUI(PStrRec(S)^.Len);
  DelRef(S);
end;

procedure TStringCommands.str_dq(Machine: TForthMachine; Command: PForthCommand);
var
  C: TChar;
  Temp: array of Char;
begin
  if Machine.FState = FS_COMPILE then begin
    compile_str_dq(Machine, Command);
  end else begin
    SetLength(Temp, 0); 
    C := Machine.NextChar;
    while C <> '"' do begin
      SetLength(Temp, Length(Temp) + 1); 
      Temp[High(Temp)] := C; 
      C := Machine.NextChar;
    end; 
    GetMem(S, 2*SizeOf(TInt) + Length(Temp) + 1);
    PStrRec(S)^.Len := Length(Temp);
    PStrRec(S)^.Ref := 0;
    Move(Temp[0], PStrRec(S)^.Sym[0], Length(Temp));
    PStrRec(S)^.Sym[Length(Temp)] := #0;
    str_push(Machine, Command, S);
  end;
end;

procedure TStringCommands.compile_str_dq(Machine: TForthMachine; Command: PForthCommand);
var
  C: TChar;
  E: Cardinal;
  L: Integer;
begin
  Machine.EWO(' str"');
  Machine.EWI(1);
  E := Machine.EL;
  Machine.EWI(0);
  C := Machine.NextChar;
  L := 0;
  while C <> '"' do begin
    Machine.EWC(C);
    C := Machine.NextChar;
    Inc(L);
  end;
  Machine.EWC(#0);
  Move(L, Machine.E[E], SizeOf(TInt));
end;

procedure TStringCommands.run_str_dq(Machine: TForthMachine; Command: PForthCommand);
var
  S: TStr;
begin
  S := @Machine.E[Machine.EC];
  str_push(Machine, Command, S);
  Inc(Machine.EC, 2*SizeOf(TInt) + PStrRec(S)^.Len + 1);
end;

procedure TStringCommands.str_equel(Machine: TForthMachine; Command: PForthCommand);
var
  A, B: TStr;
  I: Integer;
begin
  B := str_pop(Machine, Command);
  A := str_pop(Machine, Command);
  if PStrRec(A)^.Len <> PStrRec(B)^.Len then
    Machine.WUI(BOOL_FALSE)
  else begin
    for I := 0 to PStrRec(A)^.Len - 1 do
      if PStrRec(A)^.Sym[I] <> PStrRec(B)^.Sym[I] then begin
        Machine.WUI(BOOL_FALSE);
        DelRef(A);
        DelRef(B);
        Exit;
      end;
    Machine.WUI(BOOL_TRUE);
  end;
  DelRef(A);
  DelRef(B);
end;

procedure TStringCommands.str_concat(Machine: TForthMachine; Command: PForthCommand);
var
  A, B: TStr;
begin
  B := str_pop(Machine, Command);
  A := str_pop(Machine, Command);
  GetMem(S, 2*SizeOf(TInt) + PStrRec(A)^.Len + PStrRec(B)^.Len + 1);
  PStrRec(S)^.Ref := 0;
  PStrRec(S)^.Len := PStrRec(A)^.Len + PStrRec(B)^.Len;
  Move(PStrRec(A)^.Sym[0], PStrRec(S)^.Sym[0], PStrRec(A)^.Len);
  Move(PStrRec(B)^.Sym[0], PStrRec(S)^.Sym[PStrRec(A)^.Len], PStrRec(B)^.Len);
  PStrRec(S)^.Sym[PStrRec(S)^.Len] := #0;
  DelRef(A);
  DelRef(B);
  str_push(Machine, Command, S);
end;

procedure TStringCommands.str_nil(Machine: TForthMachine; Command: PForthCommand);
begin
  str_push(Machine, Command, @FStrNil);
end;

procedure TStringCommands.str_dot(Machine: TForthMachine; Command: PForthCommand);
var
  I: Integer;
begin
  S := str_pop(Machine, Command);
  for I := 0 to PStrRec(S)^.Len - 1 do
    Write(PStrRec(S)^.Sym[I]);
  DelRef(S);
end;

procedure TStringCommands.str_dollar(Machine: TForthMachine; Command: PForthCommand);
var
  P: TStr;
  S: TString;
begin
  Read(S); 
  GetMem(P, 2*SizeOf(Integer) + Length(S) + 1);
  PStrRec(P)^.Ref := 0;
  PStrRec(P)^.Len := Length(S);
  Move(S[1], PStrRec(P)^.Sym[0], Length(S));
  PStrRec(P)^.Sym[Length(S)] := #0;
  str_push(Machine, Command, P);
end;

procedure TStringCommands.Format(Machine: TForthMachine; Command: PForthCommand);
var
  P: PChar;
  I, J: Integer;
  Sub: array of string;
  STemp: TStr;
begin
  S := str_pop(Machine, Command);
  I := S^.Len;
  while I > 0 do begin
    Dec(I);
    SetLength(Sub, Length(Sub) + 1);
    if TChar(S^.Sym[I]) = '%' then begin
      if TChar(S^.Sym[I+1]) = '%' then begin
        Sub[High(Sub)] := '%';
      end else if TChar(S^.Sym[I+1]) = 's' then begin
        STemp := str_pop(Machine, Command);
        DelRef(STemp);
      end;
    end else begin
      J := I;
      while (J >= 0) and (TChar(S^.Sym[I+1]) <> '%') do
        Dec(J);
      SetLength(Sub[High(Sub)], I - J);
      I := J;
    end;
  end;
  DelRef(S);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TForthMachine'}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'folded'}{$ENDIF}
procedure TForthMachine.AddCommand(Name: PChar; Code: TCode; Immediate: Boolean = False);
begin
  SetLength(C, Length(C) + 1);
  New(C[High(C)]);
  C[High(C)].Name := StrAlloc(StrLen(Name)+1);
  StrCopy(C[High(C)].Name, Name);
  C[High(C)].Code := Code;
  SetImmediate(C[High(C)], Immediate);
end;

procedure TForthMachine.CompileSource(Source: PChar);
var
  I: Integer;
begin
  FSource := Source;
  FCompilation := True;
  FState := FS_COMPILE;
  FCurrentChar := 0;
  while (not EOS) and FCompilation do begin
    FCurrentName := NextName;
    if FCurrentName = '' then
      Break;
    WriteMnemonicByName(FCurrentName);
    CompileName(@FCurrentName[1]);
  end;
  //for I := 0 to High(FEmbro) do
  //  Write(IntToHex(FEmbro[I], 2), ' ');
  //Writeln;
  FCompilation := False;
end;

procedure TForthMachine.CompileComment(Machine: TForthMachine; Command: PForthCommand);
begin
  {( это для m4}
  while Machine.NextChar <> ')' do
    if Machine.EOS then begin
      {( это для m4 }CompileError('need ")", but end of source found');
      Break;
    end;
end;

procedure TForthMachine.CompileLineComment(Machine: TForthMachine; Command: PForthCommand);
begin
  while Machine.NextChar <> #13 do
    if Machine.EOS then
      Break;
end;

function TForthMachine.NextMnemonic: Cardinal;
begin
  Result := Cardinal((@FEmbro[EC])^);
  Inc(EC, SizeOf(Cardinal));
end;

procedure TForthMachine.Run(Index: Integer);
var
  M: Cardinal;
  SavedState: Integer;
begin
  {FRunning := True;
  //FState := False;
  EC := Index;
  while FRunning and (EC < Length(FEmbro)) do begin
    M := NextMnemonic;
    if (M > High(C)) then begin
      RunError('unknown mnemonic ' + IntToStr(M));
      Break;
    end;
    if FState then  
      CompileName(C[M].Name)
    else
      RunMnemonic(M);
  end;
  FRunning := False;}
  SavedState := FState;
  FState := FS_RUN;
  while FReturnStack.GetSize > 0 do begin
    M := NextMnemonic;
    if M > High(C) then begin
      RunError('unknown mnemonic ' + IntToStr(M));
      Break;
    end;
    RunMnemonic(M);
  end;
  FState := SavedState;
end;

procedure TForthMachine.RunMnemonic(M: Cardinal);
begin
  //Writeln('RUN MNEMONIC "' + C[M].Name + '" ' + IntToStr(M) + ' EC:' + IntToStr(EC));
  C[M].Code(Self, C[M]);
end;

procedure TForthMachine.RunCommand(Command: PForthCommand);
begin
  Command^.Code(Self, Command);
end;

procedure TForthMachine.RunError(const S: TString);
begin
  Error(' Runtime: ' + S);
  FRunning := False;
end;

procedure TForthMachine.RunWarring(const S: TString);
begin
  Warrning('Runtime warring: ' + S);
end;

procedure TForthMachine.IncHere(Count: Integer);
begin
  //Inc(Here, Count);
  EA(Count);
  //if Length(FData) - FHere < 1024 then
  //  SetLength(FData, Length(FData) + 1024);
end;

procedure TForthMachine.AddType(const Name: TString; Size: Integer);
var
  Command: PForthCommand;
begin
  SetLength(FTypes, Length(FTypes) + 1);
  FTypes[High(FTypes)].Name := PChar(Name);
  FTypes[High(FTypes)].Size := Size;

  Command := ReserveName(Name);
  SetImmediate(Command, True);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'E'}{$ENDIF}
procedure TForthMachine.EA(Size: Integer); // Embro Alloc
begin
  Inc(EL, Size);
end;

function TForthMachine.Here: Pointer;
begin
  Result := @E[EL];
end;

procedure TForthMachine._here(Machine: TForthMachine; Command: PForthCommand);
begin
  Pointer(WP^) := @E[EL];
  Inc(WP, SizeOf(Pointer));
end;

procedure TForthMachine.EWV(V: Pointer; Size: Integer); // Embro Write Data
begin
  Move(V^, (@E[EL])^, Size);
  Inc(EL, Size);
end;

procedure TForthMachine.EWI(V: Integer);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' ' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWE(V: TEmbroPtr);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' embro:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWO(V: TOpcode);
begin
  EWV(@V, SizeOf(V));

  SetLength(FEmbroDump, Length(FEmbroDump) + 1);
  FEmbroDump[High(FEmbroDump)] := C[V].Name + ' ';
  //Writeln('WRITE OPCODE: ' + IntToStr(V));
end;

procedure TForthMachine.EWO(V: TString);
var
  I: TOpcode;
begin
  for I := High(C) downto 0 do
    if TString(C[I].Name) = V then begin
      EWO(I);
      Exit;
    end;
  FSession := False;
  LogError('command "' + V + '" not found');
end;

procedure TForthMachine.EWI8(V: TInt8);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' int8:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWI16(V: TInt16);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' int16:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWI32(V: TInt32);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' int32:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWI64(V: TInt64);
begin
  EWV(@V, SizeOf(V));
  
  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' int64:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWU(V: TUInt);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' u' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWU8(V: TUInt8);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' uint8:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWU16(V: TUInt16);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' uint16:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWU32(V: TUInt32);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' uint32:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWU64(V: TUInt64);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' uint64:' + IntToStr(V) + ' ';
end;

procedure TForthMachine.EWC(V: Char);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + V;
end;

procedure TForthMachine.EWS(V: Single);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' s' + FloatToStr(V) + ' ';
end;

procedure TForthMachine.EWD(const V: Double);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' d' + FloatToStr(V) + ' ';
end;

procedure TForthMachine.EWExtended(const V: Extended);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' e' + FloatToStr(V) + ' ';
end;

procedure TForthMachine.EWPChar(V: PChar);
begin
  // TODO
end;

function CreateStr(const S: TString): TStr;
begin
  GetMem(Result, SizeOf(Integer)*2 + Length(S) + 1);
  PStrRec(Result)^.Ref := 0;
  PStrRec(Result)^.Len := Length(S);
  Move(S[1], PStrRec(Result)^.Sym[0], Length(S));
  PStrRec(Result)^.Sym[LengtH(S)] := #0;
end;

procedure TForthMachine.EWStr(V: TString);
var
  S: TStr;
begin
  S := CreateStr(V);
  PStrRec(S)^.Ref := 1;
  EWV(S, SizeOf(Integer)*2 + PStrRec(S)^.Len + 1);

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' "' + V + '" ';
end;

procedure TForthMachine.ERV(V: Pointer; Size: Integer);
begin
  Move((@E[EC])^, V^, Size);
  Inc(EC, Size);
end;

function TForthMachine.ERI: Integer;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERE: TEmbroPtr;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERO: TOpcode;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERI8: TInt8;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERI16: TInt16;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERI32: TInt32;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERI64: TInt64;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERU: TUInt;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERU8: TUInt8;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERU16: TUInt16;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERU32: TUInt32;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERU64: TUInt64;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERC: Char;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERS: Single;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERD: Double;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERExtended: Extended;
begin
  ERV(@Result, SizeOf(Result));
end;

function TForthMachine.ERPChar: PChar;
begin
  // TODO
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'D'}{$ENDIF}
{procedure TForthMachine.DA(Size: Integer);
begin
  Inc(Here, Size);
end;}
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'S'}{$ENDIF}
function TForthMachine.SE: Boolean;
begin
  Result := S[SC] = #0;
end;

function TForthMachine.SNC: TChar;
begin
  Result := S[SC];
  if not SE then
    Inc(SC);
end;

function TForthMachine.SNN: TString;
var
  C: TChar;
begin
  Result := '';
  repeat
    C := SNC;
  until (not (C in [#0..#32])) or SE;
  repeat
    Result := Result + C;
    if SE then
      Exit;
    C := SNC;
  until (C in [#0..#32]) or SE;
  if not (C in [#0..#32]) then
    Result := Result + C;
end;

procedure TForthMachine.SSS;
begin
  while (not SE) and (S[SC] in [#1..#32]) do
    SNC;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'R'}{$ENDIF}
procedure TForthMachine.RUV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(P^, RP^, Size);
  Inc(RP, Size);
end;

procedure TForthMachine.ROV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(RP^, P^, Size);
  Dec(RP, Size);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'W'}{$ENDIF}
procedure TForthMachine.WUV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(P^, WP^, Size);
  Inc(WP, Size);
end;

procedure TForthMachine.WOV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(WP^, P^, Size);
  Dec(WP, Size);
end;

procedure TForthMachine.WUS(const S: TString);
begin
  FStringCommands.str_push(Self, nil, S);
end;

function TForthMachine.WOS: TString;
var
  S: PStrRec;
begin
  S := FStringCommands.str_pop(Self, nil);
  Result := TString(PChar(@S^.Sym[0]));
  FStringCommands.DelRef(S);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'L'}{$ENDIF}
procedure TForthMachine.LUV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(P^, LP^, Size);
  Inc(LP, Size);
end;

procedure TForthMachine.LOV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(LP^, P^, Size);
  Dec(LP, Size);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}

constructor TForthMachine.Create;
var
{$IFNDEF FLAG_FPC}{$REGION 'blocks of commands'}{$ENDIF}
  IntArithmetic:    TIntArithmetic;
  Int8Arithmetic:   TInt8Arithmetic;
  Int16Arithmetic:  TInt16Arithmetic;
  Int32Arithmetic:  TInt32Arithmetic;
  Int64Arithmetic:  TInt64Arithmetic;
  UIntArithmetic:   TUIntArithmetic;
  UInt8Arithmetic:  TUInt8Arithmetic;
  UInt16Arithmetic: TUInt16Arithmetic;
  UInt32Arithmetic: TUInt32Arithmetic;
  UInt64Arithmetic: TUInt64Arithmetic;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
begin
  SetLength(E, 1024 * 1024);
  EB := @E[0];
  EC := 0;
  EL := 0;
  ES := Length(E);
  SetLength(R,   16 * 1024);
  RB := @R[0];
  RP := RB;
  RS := Length(R);
  SetLength(W,   16 * 1024);
  WB := @W[0];
  WP := WB;
  WS := Length(W);
  SetLength(C,   0);
  CB := @C[0];
  CC := 0;
  CS := Length(C);
  WordListClear(Local);
  {SetLength(D, 1024 * 1024);
  DB := @D[0];
  Here := DB;
  DS := Length(D);}
  SetLength(L, 1024 * 1024);
  LB := @L[0];
  LP := LB;
  LS := Length(L);
  S  := nil;
  SC := 0;
  FUserData := nil;
  FState := FS_INTERPRET;
  FStack := TForthStack.Create;
  FReturnStack := TReturnStack.Create;
  SetLength(FData, 2048);
  //FHere := 0;
  SetLength(FTypes, 0);
  all_create;
  AddType('', 0);
  AddType('void', 0);
  AddType('int', SizeOf(TInt));
  AddType('int8', SizeOf(TInt8));
  AddType('int16', SizeOf(TInt16));
  AddType('int32', SizeOf(TInt32));
  AddType('int64', SizeOf(TInt64));
  AddType('uint', SizeOf(TUInt));
  AddType('uint8', SizeOf(TUInt8));
  AddType('uint16', SizeOf(TUInt16));
  AddType('uint32', SizeOf(TUInt32));
  AddType('uint64', SizeOf(TUInt64));
  AddType('bool', SizeOf(TInt));
  AddType('ptr', SizeOf(Pointer));
  AddType('pchar', SizeOf(PChar));
  AddType('str', SizeOf(TStr));
  AddType('type', SizeOf(PType));
  AddType('single', SizeOf(PType));
  AddType('double', SizeOf(PType));
  AddType('extended', SizeOf(PType));

  FControlCommands := TControlCommands.Create(Self);
  FEmbroCommands := TEmbroCommands.Create;
  FDataCommands := TDataCommands.Create;
  FAlienCommands := TAlienCommands.Create;
  FStackCommands   := TStackCommands.Create(Self, SizeOf(TInt));
  FStackCommands8  := TStackCommands.Create(Self, 1);
  FStackCommands16 := TStackCommands.Create(Self, 2);
  FStackCommands32 := TStackCommands.Create(Self, 4);
  FStackCommands64 := TStackCommands.Create(Self, 8);
  FPtrStackCommands := FStackCommands32;
  IntArithmetic := TIntArithmetic.Create(Self);
  Int8Arithmetic := TInt8Arithmetic.Create(Self);
  Int16Arithmetic := TInt16Arithmetic.Create(Self);
  Int32Arithmetic := TInt32Arithmetic.Create(Self);
  Int64Arithmetic := TInt64Arithmetic.Create(Self);
  UIntArithmetic := TUIntArithmetic.Create(Self);
  UInt8Arithmetic := TUInt8Arithmetic.Create(Self);
  UInt16Arithmetic := TUInt16Arithmetic.Create(Self);
  UInt32Arithmetic := TUInt32Arithmetic.Create(Self);
  UInt64Arithmetic := TUInt64Arithmetic.Create(Self);
  FStringCommands := TStringCommands.Create(Self);

  // it must have zero opcode
  AddCommand('exit', FControlCommands._exit);

  AddCommand('(', CompileComment, True); {) для m4}
  AddCommand('//', CompileLineComment, True);
(*
{$IFNDEF FLAG_FPC}{$REGION 'stack commands'}{$ENDIF}
  AddCommand('int-push', FStackCommands._push, True);
  AddCommand('int-drop', FStackCommands.drop);
  AddCommand('int-dup',  FStackCommands.dup);
  AddCommand('int-swap', FStackCommands.swap);
  AddCommand('int-over', FStackCommands.over);
  AddCommand('int-rot',  FStackCommands.lrot);
  AddCommand('int-lrot', FStackCommands.lrot);
  AddCommand('int-rrot', FStackCommands.rrot);
  AddCommand('int-lrotn', FStackCommands.lrotn);
  AddCommand('int-rrotn', FStackCommands.rrotn);
  AddCommand('uint-drop', FStackCommands.drop);
  AddCommand('uint-dup',  FStackCommands.dup);
  AddCommand('uint-swap', FStackCommands.swap);
  AddCommand('uint-over', FStackCommands.over);
  AddCommand('uint-rot',  FStackCommands.lrot);
  AddCommand('uint-lrot', FStackCommands.lrot);
  AddCommand('uint-rrot', FStackCommands.rrot);
  AddCommand('uint-lrotn', FStackCommands.lrotn);
  AddCommand('uint-rrotn', FStackCommands.rrotn);
  AddCommand('bool-drop', FStackCommands.drop);
  AddCommand('bool-dup',  FStackCommands.dup);
  AddCommand('bool-swap', FStackCommands.swap);
  AddCommand('bool-over', FStackCommands.over);
  AddCommand('bool-rot',  FStackCommands.lrot);
  AddCommand('bool-lrot', FStackCommands.lrot);
  AddCommand('bool-rrot', FStackCommands.rrot);
  ommands.lrotn);
  AddCommand('bool-rrotn', FStackCommands.rrotn);
  AddCommand('drop', FStackCommands.drop);
  AddCommand('dup',  FStackCommands.dup);
  AddCommand('swap', FStackCommands.swap);
  AddCommand('over', FStackCommands.over);
  AddCommand('rot',  FStackCommands.lrot);
  AddCommand('lrot', FStackCommands.lrot);
  AddCommand('rrot', FStackCommands.rrot);
  AddCommand('lrotn', FStackCommands.lrotn);
  AddCommand('rrotn', FStackCommands.rrotn);
  AddCommand('int8-drop', FStackCommands8.drop);
  AddCommand('int8-dup',  FStackCommands8.dup);
  AddCommand('int8-swap', FStackCommands8.swap);
  AddCommand('int8-over', FStackCommands8.over);
  AddCommand('int8-rot',  FStackCommands8.lrot);
  AddCommand('int8-lrot', FStackCommands8.lrot);
  AddCommand('int8-lrotn', FStackCommands8.lrotn);
  AddCommand('int8-rrotn', FStackCommands8.rrotn);
  AddCommand('int16-drop', FStackCommands16.drop);
  AddCommand('int16-dup',  FStackCommands16.dup);
  AddCommand('int16-swap', FStackCommands16.swap);
  AddCommand('int16-over', FStackCommands16.over);
  AddCommand('int16-rot',  FStackCommands16.lrot);
  AddCommand('int16-lrot', FStackCommands16.lrot);
  AddCommand('int16-lrotn', FStackCommands16.lrotn);
  AddCommand('int16-rrotn', FStackCommands16.rrotn);
  AddCommand('int32-drop', FStackCommands32.drop);
  AddCommand('int32-dup',  FStackCommands32.dup);
  AddCommand('int32-swap', FStackCommands32.swap);
  AddCommand('int32-over', FStackCommands32.over);
  AddCommand('int32-rot',  FStackCommands32.lrot);
  AddCommand('int32-lrot', FStackCommands32.lrot);
  AddCommand('int32-lrotn', FStackCommands32.lrotn);
  AddCommand('int32-rrotn', FStackCommands32.rrotn);
  AddCommand('int64-drop', FStackCommands64.drop);
  AddCommand('int64-dup',  FStackCommands64.dup);
  AddCommand('int64-swap', FStackCommands64.swap);
  AddCommand('int64-over', FStackCommands64.over);
  AddCommand('int64-rot',  FStackCommands64.lrot);
  AddCommand('int64-lrot', FStackCommands64.lrot);
  AddCommand('int64-lrotn', FStackCommands64.lrotn);
  AddCommand('int64-rrotn', FStackCommands64.rrotn);
  AddCommand('uint8-drop', FStackCommands8.drop);
  AddCommand('uint8-dup',  FStackCommands8.dup);
  AddCommand('uint8-swap', FStackCommands8.swap);
  AddCommand('uint8-over', FStackCommands8.over);
  AddCommand('uint8-rot',  FStackCommands8.lrot);
  AddCommand('uint8-lrot', FStackCommands8.lrot);
  AddCommand('int8-lrotn', FStackCommands8.lrotn);
  AddCommand('int8-rrotn', FStackCommands8.rrotn);
  AddCommand('uint16-drop', FStackCommands16.drop);
  AddCommand('uint16-dup',  FStackCommands16.dup);
  AddCommand('uint16-swap', FStackCommands16.swap);
  AddCommand('uint16-over', FStackCommands16.over);
  AddCommand('uint16-rot',  FStackCommands16.lrot);
  AddCommand('uint16-lrot', FStackCommands16.lrot);
  AddCommand('int16-lrotn', FStackCommands16.lrotn);
  AddCommand('int16-rrotn', FStackCommands16.rrotn);
  AddCommand('uint32-drop', FStackCommands32.drop);
  AddCommand('uint32-dup',  FStackCommands32.dup);
  AddCommand('uint32-swap', FStackCommands32.swap);
  AddCommand('uint32-over', FStackCommands32.over);
  AddCommand('uint32-rot',  FStackCommands32.lrot);
  AddCommand('uint32-lrot', FStackCommands32.lrot);
  AddCommand('int32-lrotn', FStackCommands32.lrotn);
  AddCommand('int32-rrotn', FStackCommands32.rrotn);
  AddCommand('uint64-drop', FStackCommands64.drop);
  AddCommand('uint64-dup',  FStackCommands64.dup);
  AddCommand('uint64-swap', FStackCommands64.swap);
  AddCommand('uint64-over', FStackCommands64.over);
  AddCommand('uint64-rot',  FStackCommands64.lrot);
  AddCommand('uint64-lrot', FStackCommands64.lrot);
  AddCommand('int64-lrotn', FStackCommands64.lrotn);
  AddCommand('int64-rrotn', FStackCommands64.rrotn);
  AddCommand('ptr-drop', FPtrStackCommands.drop);
  AddCommand('ptr-dup',  FPtrStackCommands.dup);
  AddCommand('ptr-swap', FPtrStackCommands.swap);
  AddCommand('ptr-over', FPtrStackCommands.over);
  AddCommand('ptr-rot',  FPtrStackCommands.lrot);
  AddCommand('ptr-lrot', FPtrStackCommands.lrot);
  AddCommand('ptr-rrot', FPtrStackCommands.rrot);
  AddCommand('ptr-lrotn', FPtrStackCommands.lrotn);
  AddCommand('ptr-rrotn', FPtrStackCommands.rrotn);
  AddCommand('pchar-drop', FPtrStackCommands.drop);
  AddCommand('pchar-dup',  FPtrStackCommands.dup);
  AddCommand('pchar-swap', FPtrStackCommands.swap);
  AddCommand('pchar-over', FPtrStackCommands.over);
  AddCommand('pchar-rot',  FPtrStackCommands.lrot);
  AddCommand('pchar-lrot', FPtrStackCommands.lrot);
  AddCommand('pchar-rrot', FPtrStackCommands.rrot);
  AddCommand('pchar-lrotn', FPtrStackCommands.lrotn);
  AddCommand('pchar-rrotn', FPtrStackCommands.rrotn);
  AddCommand('type-drop', FPtrStackCommands.drop);
  AddCommand('type-dup',  FPtrStackCommands.dup);
  AddCommand('type-swap', FPtrStackCommands.swap);
  AddCommand('type-over', FPtrStackCommands.over);
  AddCommand('type-rot',  FPtrStackCommands.lrot);
  AddCommand('type-lrot', FPtrStackCommands.lrot);
  AddCommand('type-rrot', FPtrStackCommands.rrot);
  AddCommand('type-lrotn', FPtrStackCommands.lrotn);
  AddCommand('type-rrotn', FPtrStackCommands.rrotn);
  AddCommand('embro-drop', FStackCommands.drop);
  AddCommand('embro-dup',  FStackCommands.dup);
  AddCommand('embro-swap', FStackCommands.swap);
  AddCommand('embro-over', FStackCommands.over);
  AddCommand('embro-rot',  FStackCommands.lrot);
  AddCommand('embro-lrot', FStackCommands.lrot);
  AddCommand('embro-rrot', FStackCommands.rrot);
  AddCommand('embro-lrotn', FStackCommands.lrotn);
  AddCommand('embro-rrotn', FStackCommands.rrotn);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
*)
{$IFNDEF FLAG_FPC}{$REGION 'control commands'}{$ENDIF}
  AddCommand(':', FControlCommands.compile_def);
  AddCommand(';', FControlCommands.compile_enddef, True);
  AddCommand('skip-to;', FControlCommands.compile_enddef, True);
  AddCommand('...', FControlCommands.scattered_dots, True);
  AddCommand('..:', FControlCommands.compile_scattered_def);
  AddCommand(';..', FControlCommands.compile_scattered_enddef, True);
  AddCommand('branch', FControlCommands.branch);
  AddCommand('?branch', FControlCommands._ask_branch);
  AddCommand('>mark', FControlCommands._gt_mark);
  AddCommand('>resolve', FControlCommands._gt_resolve);
  AddCommand('<mark', FControlCommands._lt_mark);
  AddCommand('<resolve', FControlCommands._lt_resolve);
  AddCommand('recurse', FControlCommands.recurse, True);
  AddCommand('immediate', FControlCommands.immediate);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'embro commands'}{$ENDIF}
  AddCommand('compile', FEmbroCommands.compile, True);
  //AddCommand('execute', FEmbroCommands.execute, True);
  AddCommand('evaluate', Evaluate);
  ~AddCommand('evaluate-file', EvaluateFile);|
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'data commands'}{$ENDIF}
  AddCommand('nil', FDataCommands._nil);
  AddCommand('ptr,', FDataCommands.ptr_comma);

  {AddCommand('bool@', FStackCommands._dog);
  AddCommand('int@', FStackCommands._dog);
  AddCommand('int8@', FStackCommands8._dog);
  AddCommand('int16@', FStackCommands16._dog);
  AddCommand('int32@', FStackCommands32._dog);
  AddCommand('int64@', FStackCommands64._dog);
  AddCommand('uint@', FStackCommands._dog);
  AddCommand('uint8@', FStackCommands8._dog);
  AddCommand('uint16@', FStackCommands16._dog);
  AddCommand('uint32@', FStackCommands32._dog);
  AddCommand('uint64@', FStackCommands64._dog);
  AddCommand('ptr@', FPtrStackCommands._dog);
  AddCommand('bool!', FStackCommands._exclamation);
  AddCommand('int!', FStackCommands._exclamation);
  AddCommand('int8!', FStackCommands8._exclamation);
  AddCommand('int16!', FStackCommands16._exclamation);
  AddCommand('int32!', FStackCommands32._exclamation);
  AddCommand('int64!', FStackCommands64._exclamation);
  AddCommand('uint!', FStackCommands._exclamation);
  AddCommand('uint8!', FStackCommands8._exclamation);
  AddCommand('uint16!', FStackCommands16._exclamation);
  AddCommand('uint32!', FStackCommands32._exclamation);
  AddCommand('uint64!', FStackCommands64._exclamation);
  AddCommand('ptr!', FPtrStackCommands._exclamation);

  AddCommand('int-to', FDataCommands.to_int, True);
  AddCommand('int8-to', FDataCommands.to_int8, True);
  AddCommand('int16-to', FDataCommands.to_int16, True);
  AddCommand('int32-to', FDataCommands.to_int32, True);
  AddCommand('int64-to', FDataCommands.to_int64, True);
  AddCommand('uint-to', FDataCommands.to_uint, True);
  AddCommand('uint8-to', FDataCommands.to_uint8, True);
  AddCommand('uint16-to', FDataCommands.to_uint16, True);
  AddCommand('uint32-to', FDataCommands.to_uint32, True);
  AddCommand('uint64-to', FDataCommands.to_uint64, True);
  AddCommand('ptr-to', FDataCommands.to_ptr, True);
  AddCommand('pchar-to', FDataCommands.to_ptr, True);
  AddCommand(' to', FDataCommands.run_to);
  AddCommand(' 8to', FDataCommands.run_8to);
  AddCommand(' 16to', FDataCommands.run_16to);
  AddCommand(' 32to', FDataCommands.run_32to);
  AddCommand(' 64to', FDataCommands.run_64to);}

  AddCommand('create', FDataCommands._create);
  AddCommand('here', _here);
  AddCommand('allot', FDataCommands.allot);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
(*
{$IFNDEF FLAG_FPC}{$REGION 'arithmetic'}{$ENDIF}
  AddCommand('int+', IntArithmetic._plus);
  AddCommand('int-', IntArithmetic._minus);
  AddCommand('int*', IntArithmetic._star);
  AddCommand('int=', IntArithmetic._equel);
  AddCommand('int<', IntArithmetic._lt);
  AddCommand('int>', IntArithmetic._gt);
  AddCommand('int-div', IntArithmetic._div);
  AddCommand('int-mod', IntArithmetic._mod);
  AddCommand('int.', IntArithmetic._dot);
  AddCommand('int-abs', IntArithmetic._abs);
  AddCommand('int-neg', IntArithmetic.neg);
  AddCommand('int,', IntArithmetic._comma);
  AddCommand('+', IntArithmetic._plus);
  AddCommand('-', IntArithmetic._minus);
  AddCommand('*', IntArithmetic._star);
  AddCommand('=', IntArithmetic._equel);
  AddCommand('<', IntArithmetic._lt);
  AddCommand('>', IntArithmetic._gt);
  AddCommand('div', IntArithmetic._div);
  AddCommand('mod', IntArithmetic._mod);
  AddCommand('.', IntArithmetic._dot);
  AddCommand('abs', IntArithmetic._abs);
  AddCommand('neg', IntArithmetic.neg);
  AddCommand(',', IntArithmetic._comma);
  AddCommand('int8+', Int8Arithmetic._plus);
  AddCommand('int8-', Int8Arithmetic._minus);
  AddCommand('int8*', Int8Arithmetic._star);
  AddCommand('int8=', Int8Arithmetic._equel);
  AddCommand('int8<', Int8Arithmetic._lt);
  AddCommand('int8>', Int8Arithmetic._gt);
  AddCommand('int8-div', Int8Arithmetic._div);
  AddCommand('int8-mod', Int8Arithmetic._mod);
  AddCommand('int8.', Int8Arithmetic._dot);
  AddCommand('int8-abs', Int8Arithmetic._abs);
  AddCommand('int8-neg', Int8Arithmetic.neg);
  AddCommand('int8,', Int8Arithmetic._comma);
  AddCommand('int16+', Int16Arithmetic._plus);
  AddCommand('int16-', Int16Arithmetic._minus);
  AddCommand('int16*', Int16Arithmetic._star);
  AddCommand('int16=', Int16Arithmetic._equel);
  AddCommand('int16<', Int16Arithmetic._lt);
  AddCommand('int16>', Int16Arithmetic._gt);
  AddCommand('int16-div', Int16Arithmetic._div);
  AddCommand('int16-mod', Int16Arithmetic._mod);
  AddCommand('int16.', Int16Arithmetic._dot);
  AddCommand('int16-abs', Int16Arithmetic._abs);
  AddCommand('int16-neg', Int16Arithmetic.neg);
  AddCommand('int16,', Int16Arithmetic._comma);
  AddCommand('int32+', Int32Arithmetic._plus);
  AddCommand('int32-', Int32Arithmetic._minus);
  AddCommand('int32*', Int32Arithmetic._star);
  AddCommand('int32=', Int32Arithmetic._equel);
  AddCommand('int32<', Int32Arithmetic._lt);
  AddCommand('int32>', Int32Arithmetic._gt);
  AddCommand('int32-div', Int32Arithmetic._div);
  AddCommand('int32-mod', Int32Arithmetic._mod);
  AddCommand('int32.', Int32Arithmetic._dot);
  AddCommand('int32-abs', Int32Arithmetic._abs);
  AddCommand('int32-neg', Int32Arithmetic.neg);
  AddCommand('int32,', Int32Arithmetic._comma);
  AddCommand('int64+', Int64Arithmetic._plus);
  AddCommand('int64-', Int64Arithmetic._minus);
  AddCommand('int64*', Int64Arithmetic._star);
  AddCommand('int64=', Int64Arithmetic._equel);
  AddCommand('int64<', Int64Arithmetic._lt);
  AddCommand('int64>', Int64Arithmetic._gt);
  AddCommand('int64-div', Int64Arithmetic._div);
  AddCommand('int64-mod', Int64Arithmetic._mod);
  AddCommand('int64.', Int64Arithmetic._dot);
  AddCommand('int64-abs', Int64Arithmetic._abs);
  AddCommand('int64-neg', Int64Arithmetic.neg);
  AddCommand('int64,', Int64Arithmetic._comma);
  AddCommand('uint+', UintArithmetic._plus);
  AddCommand('uint-', UintArithmetic._minus);
  AddCommand('uint*', UintArithmetic._star);
  AddCommand('uint-div', UintArithmetic._div);
  AddCommand('uint-mod', UintArithmetic._mod);
  AddCommand('uint.', UIntArithmetic._dot);
  AddCommand('uint,', UIntArithmetic._comma);
  AddCommand('uint8+', Uint8Arithmetic._plus);
  AddCommand('uint8-', Uint8Arithmetic._minus);
  AddCommand('uint8*', Uint8Arithmetic._star);
  AddCommand('uint8=', UInt8Arithmetic._equel);
  AddCommand('uint8<', UInt8Arithmetic._lt);
  AddCommand('uint8>', UInt8Arithmetic._gt);
  AddCommand('uint8-div', Uint8Arithmetic._div);
  AddCommand('uint8-mod', Uint8Arithmetic._mod);
  AddCommand('uint8.', UInt8Arithmetic._dot);
  AddCommand('uint8,', UInt8Arithmetic._comma);
  AddCommand('uint16+', Uint16Arithmetic._plus);
  AddCommand('uint16-', Uint16Arithmetic._minus);
  AddCommand('uint16*', Uint16Arithmetic._star);
  AddCommand('uint16=', UInt16Arithmetic._equel);
  AddCommand('uint16<', UInt16Arithmetic._lt);
  AddCommand('uint16>', UInt16Arithmetic._gt);
  AddCommand('uint16-div', Uint16Arithmetic._div);
  AddCommand('uint16-mod', Uint16Arithmetic._mod);
  AddCommand('uint16.', UInt16Arithmetic._dot);
  AddCommand('uint16,', UInt16Arithmetic._comma);
  AddCommand('uint32+', Uint32Arithmetic._plus);
  AddCommand('uint32-', Uint32Arithmetic._minus);
  AddCommand('uint32*', Uint32Arithmetic._star);
  AddCommand('uint32=', UInt32Arithmetic._equel);
  AddCommand('uint32<', UInt32Arithmetic._lt);
  AddCommand('uint32>', UInt32Arithmetic._gt);
  AddCommand('uint32.', UInt32Arithmetic._dot);
  AddCommand('uint32-div', Uint32Arithmetic._div);
  AddCommand('uint32-mod', Uint32Arithmetic._mod);
  AddCommand('uint32,', UInt32Arithmetic._comma);
  AddCommand('uint64+', Uint64Arithmetic._plus);
  AddCommand('uint64-', Uint64Arithmetic._minus);
  AddCommand('uint64*', Uint64Arithmetic._star);
  AddCommand('uint64=', UInt64Arithmetic._equel);
  AddCommand('uint64<', UInt64Arithmetic._lt);
  AddCommand('uint64>', UInt64Arithmetic._gt);
  AddCommand('uint64-div', Uint64Arithmetic._div);
  AddCommand('uint64-mod', Uint64Arithmetic._mod);
  AddCommand('uint64.', UInt64Arithmetic._dot);
  AddCommand('uint64,', UInt64Arithmetic._comma);

  AddCommand('int8->int', Int8Arithmetic.ToInt);
  AddCommand('int->int8', Int8Arithmetic.FromInt);
  AddCommand('int16->int', Int16Arithmetic.ToInt);
  AddCommand('int->int16', Int16Arithmetic.FromInt);
  AddCommand('int32->int', Int32Arithmetic.ToInt);
  AddCommand('int->int32', Int32Arithmetic.FromInt);
  AddCommand('int64->int', Int64Arithmetic.ToInt);
  AddCommand('int->int64', Int64Arithmetic.FromInt);
  AddCommand('uint8->uint', UInt8Arithmetic.ToInt);
  AddCommand('uint->uint8', UInt8Arithmetic.FromInt);
  AddCommand('uint16->uint', UInt16Arithmetic.ToInt);
  AddCommand('uint->uint16', UInt16Arithmetic.FromInt);
  AddCommand('uint32->uint', UInt32Arithmetic.ToInt);
  AddCommand('uint->uint32', UInt32Arithmetic.FromInt);
  AddCommand('uint64->uint', UInt64Arithmetic.ToInt);
  AddCommand('uint->uint64', UInt64Arithmetic.FromInt);

  FIntArithmetic := IntArithmetic;
  FInt8Arithmetic := Int8Arithmetic;
  FInt16Arithmetic := Int16Arithmetic;
  FInt32Arithmetic := Int32Arithmetic;
  FInt64Arithmetic := Int64Arithmetic;
  FUIntArithmetic := UIntArithmetic;
  FUInt8Arithmetic := UInt8Arithmetic;
  FUInt16Arithmetic := UInt16Arithmetic;
  FUInt32Arithmetic := UInt32Arithmetic;
  FUInt64Arithmetic := UInt64Arithmetic;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
*)
{$IFNDEF FLAG_FPC}{$REGION 'bool'}{$ENDIF}
  FBoolCommands := TBoolCommands.Create(Self);
  AddCommand('bool-push', FBoolCommands.push, True);
  AddCommand('bool-false', FBoolCommands._false);
  AddCommand('bool-true', FBoolCommands._true);
  AddCommand('bool-not', FBoolCommands._not);
  AddCommand('bool-or', FBoolCommands._or);
  AddCommand('bool-and', FBoolCommands._and);
  AddCommand('bool-xor', FBoolCommands._xor);
  AddCommand('bool.', FBoolCommands._dot);
  AddCommand('false', FBoolCommands._false);
  AddCommand('true', FBoolCommands._true);
  AddCommand('not', FBoolCommands._not);
  AddCommand('or', FBoolCommands._or);
  AddCommand('and', FBoolCommands._and);
  AddCommand('xor', FBoolCommands._xor);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'type commands'}{$ENDIF}
  AddCommand('typeof', FTypeCommands.typeof, True);
  AddCommand(' typeof', FTypeCommands.run_type);
  AddCommand('type-size', FTypeCommands.type_size);
  AddCommand('t_void', FTypeCommands._void, True);
  AddCommand('t_int', FTypeCommands._int, True);
  AddCommand('t_int8', FTypeCommands._int8, True);
  AddCommand('t_int16', FTypeCommands._int16, True);
  AddCommand('t_int32', FTypeCommands._int32, True);
  AddCommand('t_int64', FTypeCommands._int64, True);
  AddCommand('t_uint', FTypeCommands._uint, True);
  AddCommand('t_uint8', FTypeCommands._uint8, True);
  AddCommand('t_uint16', FTypeCommands._uint16, True);
  AddCommand('t_uint32', FTypeCommands._uint32, True);
  AddCommand('t_uint64', FTypeCommands._uint64, True);
  AddCommand('t_bool', FTypeCommands._bool, True);
  AddCommand('t_str', FTypeCommands._str, True);
  AddCommand('t_pchar', FTypeCommands._pchar, True);
  AddCommand('t_ptr', FTypeCommands._ptr, True);
  AddCommand('t_type', FTypeCommands._type, True);
  AddCommand('t_single', FTypeCommands._single, True);
  AddCommand('t_double', FTypeCommands._double, True);
  AddCommand('t_extended', FTypeCommands._extended, True);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'alien commands'}{$ENDIF}
  AddCommand('lib-load', FAlienCommands.lib_load);
  AddCommand('lib-unload', FAlienCommands.lib_unload);
  AddCommand('lib-fun', FAlienCommands.lib_fun);
  AddCommand('alien-fun', FAlienCommands.alien_fun);
  AddCommand('alien-endfun', FAlienCommands.alien_endfun);
  AddCommand('conv-stdcall', FAlienCommands._conv_stdcall);
  AddCommand('conv-cdecl', FAlienCommands._conv_cdecl);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'string commands'}{$ENDIF}
  AddCommand('pchar"', FStringCommands.pchar_dq, True);
  AddCommand(' pchar"', FStringCommands.run_pchar_dq);
  AddCommand('pchar.', FStringCommands.pchar_dot);
  AddCommand('pchar-alloc', FStringCommands.pchar_alloc);
  AddCommand('pchar-free', FStringCommands.pchar_free);
  AddCommand('pchar-len', FStringCommands.pchar_len);
  AddCommand('pchar-concat', FStringCommands.pchar_concat);
  AddCommand('pchar=', FStringCommands.pchar_equel);

  AddCommand('str"', FStringCommands.str_dq, True);
  AddCommand(' str"', FStringCommands.run_str_dq);
  AddCommand('str.', FStringCommands.str_dot);
  AddCommand('str$', FStringCommands.str_dollar);
  AddCommand('str-len', FStringCommands.str_len);
  AddCommand('str=', FStringCommands.str_equel);
  AddCommand('str-nil', FStringCommands.str_nil);
  AddCommand('str-concat', FStringCommands.str_concat);
  AddCommand('str-drop', FStringCommands.str_drop);
  AddCommand('str-dup', FStringCommands.str_dup);
  AddCommand('str-swap', FPtrStackCommands.swap);
  AddCommand('str-over', FStringCommands.str_over);
  AddCommand('str-rot', FPtrStackCommands.lrot);
  AddCommand('str-lrot', FPtrStackCommands.lrot);
  AddCommand('str-rrot', FPtrStackCommands.rrot);
  AddCommand('str-lrotn', FPtrStackCommands.lrotn);
  AddCommand('str-rrotn', FPtrStackCommands.rrotn);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'console commands'}{$ENDIF}
  FConsoleCommands := TConsoleCommands.Create(Self);
  AddCommand('cr', FConsoleCommands.cr);
  AddCommand('emit', FConsoleCommands.emit);
  AddCommand('space', FConsoleCommands.space);
  AddCommand('spaces', FConsoleCommands.spaces);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
  regist_all_commands;
  Interpret(': if compile ?branch >mark ; immediate');
  Interpret(': else compile branch >mark embro-swap >resolve ; immediate');
  Interpret(': then >resolve ; immediate');
  Interpret(': begin <mark ; immediate');
  Interpret(': while compile ?branch >mark embro-swap ; immediate');
  Interpret(': repeat compile branch <resolve >resolve ; immediate');
  Interpret(': until compile ?branch <resolve ; immediate');
  Interpret(': [ 0 state ! ; immediate');
  Interpret(': ] 1 state ! ; immediate');
  //Writeln('Commands count: ', Length(C));
end;

destructor TForthMachine.Destroy; 
begin
  all_free;
  FAlienCommands.Free;
  FStringCommands.Free;
  FDataCommands.Free;
  FEmbroCommands.Free;
  FControlCommands.Free;
  FStackCommands.Free;
  FStackCommands8.Free;
  FStackCommands16.Free;
  FStackCommands32.Free;
  FStackCommands64.Free;
  FIntArithmetic.Free;
  FInt8Arithmetic.Free;
  FInt16Arithmetic.Free;
  FInt32Arithmetic.Free;
  FInt64Arithmetic.Free;
  FUIntArithmetic.Free;
  FUInt8Arithmetic.Free;
  FUInt16Arithmetic.Free;
  FUInt32Arithmetic.Free;
  FUInt64Arithmetic.Free;
  FBoolCommands.Free;
  FReturnStack.Free;
  FStack.Free;
end;

procedure TForthMachine.InterpretName(W: PChar);
var
  I: Integer;
begin
  for I := High(C) downto 0 do
    if StrComp(C[I].Name, W) = 0 then begin
      //Writeln('START ' + W);
      C[I].Code(Self, C[I]);
      // Writeln('DONE ' + W);
      Exit;
    end;
  I := StrToIntDef(W, -3535);
  if I = -3535 then
    Error(' Unknown command: ' + W)
  else
    WUI(I);
end;

function TForthMachine.CompileName(W: PChar): Boolean;
var
  I: Integer;
begin
  for I := High(C) downto 0 do
    if StrComp(C[I].Name, W) = 0 then begin
      if IsImmediate(C[I]) then
        C[I].Code(Self, C[I])
      else
        EWO(I);
      Exit;
    end;
  I := StrToIntDef(W, -3535);
  if I = -3535 then
    Error('Unknown command: ' + W)
  else begin
    EWO('run@int-push');
    EWI(I);
  end;
end;

procedure TForthMachine.Interpret(const S: PChar);
begin
  {FSource := S;
  FCurrentChar := 0;
  while not EOS do begin
    FCurrentName := NextName;
    if FState = FS_COMPILE then
      CompileName(PChar(FCurrentName))
    else
      InterpretName(PChar(FCurrentName));
  end;}
  RUI(FState);
  RUI(Ord(FSession) * BOOL_TRUE);
  RUI(EC);
  RUP(Self.S);
  RUI(SC);
  RUP(RB);
  if S = nil then
    Exit;
  Self.S := S;
  //Self.SB := S;
  Self.SC := 0;
  FState := FS_INTERPRET;
  FSession := True;
  MainLoop;
  RB := ROP;
  SC := ROI;
  Self.S  := ROP;
  EC := ROI;
  FSession := ROI <> BOOL_FALSE;
  FState := ROI;
end;

procedure TForthMachine.Evaluate(Machine: TForthMachine; Command: PForthCommand);
var
  S: TStr;
begin
  S := Machine.FStringCommands.str_pop(Machine, Command);
  Interpret(PChar(@(PStrRec(S)^.Sym[0])));
  Machine.FStringCommands.DelRef(S);
end;

procedure TForthMachine.EvaluateFile(Machine: TForthMachine; Command: PForthCommand);
var
  //F: File of Byte;
  F: TextFile;
  S: TStr;
  //B: array of Byte;
  B: TString;
  T: TString;
begin
  S := MAchine.FStringCommands.str_pop(Machine, Command);
  (*Assign(F, PChar(@(PStrRec(S)^.Sym[0])));
  {$I-}
  Reset(F);
  {$I+}
  if IOResult <> 0 then begin
    LogError('cannot open file "' + PChar(@(PStrRec(S)^.Sym[0])) + '"');
    Exit;
  end;
  SetLength(B, FileSize(F) + 1);
  B[FileSize(F)] := 0;
  BlockRead(F, B[0], FileSize(F)); 
  Close(F);*)
  Assign(F, PChar(@(PStrRec(S)^.Sym[0])));
  {$I-}
  Reset(F);
  {$I+}
  if IOResult <> 0 then begin
    LogError('cannot open file "' + PChar(@(PStrRec(S)^.Sym[0])) + '"');
    Exit;
  end;
  B := '';
  while not EOF(F) do begin
    Readln(F, T);
    B := B + T + EOL;
  end;
  Close(F);
  Machine.Interpret(PChar(B));
  Machine.FStringCommands.DelRef(S);
end;

procedure TForthMachine.MainLoop;
begin
  while FSession do
    case FState of
      FS_INTERPRET: InterpretStep;
      FS_COMPILE:   CompileStep;
      FS_RUN:       RunStep;
    end;
end;

procedure TForthMachine.InterpretStep;
begin
  SSS;
  if SE then
    FSession := False
  else
    InterpretName(PChar(SNN));
end;

procedure TForthMachine.CompileStep;
begin
  SSS;
  if SE then
    FSession := False
  else
    CompileName(PChar(SNN));
end;

procedure TForthMachine.RunStep;
begin
  //Writeln('RUN STEP');
  RunMnemonic(ERO);
end;

procedure TForthMachine.CompileError(const S: TString);
begin
  Error(' Compilation: "' + S + '"');
  FCompilation := False;
end;

procedure TForthMachine.CompileWarring(const S: TString);
begin
  Warrning(' Compilation: "' + S + '"');
end;

procedure TForthMachine.LogError(const S: TString);
begin
  if FState = FS_COMPILE then
    CompileError(S)
  else
    RunError(S);
end;

function TForthMachine.NextChar: TChar;
begin
  Result := SNC;
  {if EOS then
    Result := #0
  else begin
    Result := FSource[FCurrentChar];
    Inc(FCurrentChar);
  end;}
end;

function TForthMachine.NextName: TString;
var
  C: TChar;
begin
  Result := SNN;
  {Result := '';
  repeat
    C := NextChar;
  until (not (C in [#0..#32])) or EOS;
  repeat
    Result := Result + C;
    if EOS then
      Exit;
    C := NextChar;
  until (C in [#0..#32]) or EOS;
  if not (C in [#0..#32]) then
    Result := Result + C;}
end;

function TForthMachine.NextName(S: PChar; var I: Integer): TString;
var
  C: TChar;
begin
  Result := '';
  repeat
    C := S[I];
    if C <> #0 then
      Inc(I);
  until (not (C in [#0..#32])) or (C = #0);
  repeat
    Result := Result + C;
    if S[I] = #0 then
      Exit;
    C := S[I];
    if C <> #0 then
      Inc(I);
  until (C in [#0..#32]) or (C = #0);
  if not (C in [#0..#32]) then
    Result := Result + C;
end;

function TForthMachine.NextNamePassive: TString;
var
  Temp: Integer;
begin
  Temp := SC;
  Result := NextName(S, Temp);
end;

function TForthMachine.EOS: Boolean; // end of source
begin
  Result := SE;
  //Result := FSource[FCurrentChar] = #0;
end;

procedure TForthMachine.WriteEmbro(P: Pointer; Size: Integer);
begin
  SetLength(FEmbro, Length(FEmbro) + Size);
  Move(P^, FEmbro[Length(FEmbro) - Size], Size);
end;

procedure TForthMachine.WriteEmbroInt(I: Integer);
begin
  WriteEmbro(@I, SizeOf(I));
  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' ' + IntToStr(I) + ' ';
end;

procedure TForthMachine.WriteEmbroUInt(U: Cardinal);
begin
  WriteEmbro(@U, SizeOf(U));
  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' u' + IntToStr(U) + ' ';
end;

procedure TForthMachine.WriteEmbroChar(C: Char);
begin
  WriteEmbro(@C, SizeOf(C));
  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + '''' + IntToHex(Ord(C), 2);
end;

procedure TForthMachine.WriteEmbroByte(B: Byte);
begin
  WriteEmbro(@B, SizeOf(B));
  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + 'b' + IntToHex(Ord(B), 2);
end;

procedure TForthMachine.PopEmbro(P: Pointer; Size: Integer);
begin
  Move(FEmbro[Length(FEmbro) - Size], P^, Size);
  SetLength(FEmbro, Length(FEmbro) - Size);
end;

procedure TForthMachine.WriteMnemonic(M: Cardinal);
begin
  WriteEmbro(@M, SizeOf(M));
  SetLength(FEmbroDump, Length(FEmbroDump) + 1);
  FEmbroDump[High(FEmbroDump)] := C[M].Name + ' ';
end;

procedure TForthMachine.WriteMnemonicByName(const Name: TString);
var
  I: Integer;
begin
  //Writeln('Write mnemonic by name ' + Name);
  for I := High(C) downto 0 do
    if TString(C[I].Name) = Name then begin
      WriteMnemonic(I);
      Exit;
    end;
  I := StrToIntDef(Name, -3535);
  if I = -3535 then
    CompileError('Unknown name "' + Name + '"')
  else begin
    WriteMnemonicByName('int-push');
    WriteEmbroInt(I);
  end;
end;

function TForthMachine.GetOpcodeByName(const Name: TString): TMnemonic;
var
  I: Integer;
begin
  for I := High(C) downto 0 do
    if TString(C[I].Name) = Name then begin
      Writeln(I);
      Result := I;
      Exit;
    end;
  Result := 0;
end;

function TForthMachine.GetCommandByOpcode(Opcode: Integer): PForthCommand;
begin
  Writeln(Opcode);
  Result := C[Opcode];
end;

procedure TForthMachine.CancelMnemonic;
begin
  SetLength(FEmbro, Length(FEmbro) - SizeOf(Cardinal));
end;

function TForthMachine.ReserveName(const Name: TString): PForthCommand;
var
  I: Integer;
begin
  FLastMnemonic := -1;
  {{for I := 0 to High(C) do
    if TString(C[I].Name) = Name then begin
      Result := C[I];
      FLastMnemonic := I;
      Break;
    end;}
  if FLastMnemonic = -1 then begin
    SetLength(C, Length(C) + 1);
    New(C[High(C)]);
    C[High(C)].Name := StrAlloc(Length(Name)+1);
    StrCopy(C[High(C)].Name, PChar(Name));
  end;
  SetImmediate(C[High(C)], False);
  C[High(C)].Code := FControlCommands.call;
  //C[High(C)].Proc := nil;
  //C[High(C)].Compile.Proc := nil;
  //C[High(C)].Callback := nil;
  //C[High(C)].Runtime.Proc := FControlCommands.call;
  FLastMnemonic := High(C);
  Result := C[High(C)];
end;

procedure TForthMachine.ReadEmbro(P: Pointer; Size: Integer);
begin
  Move(FEmbro[EC], P^, Size);
  Inc(EC, Size);
end;

function TForthMachine.ReadMnemonic: TMnemonic;
begin
  ReadEmbro(@Result, SizeOf(TMnemonic));
end;

procedure TForthMachine.Push(P: Pointer; Size: Integer);
begin
  if FState = FS_COMPILE then
    WriteEmbro(P, Size)
  else
    FStack.Push(P, Size);
end;

procedure TForthMachine.Push(I: TInt);
begin
  Push(@I, SizeOf(I));
end;

procedure TForthMachine.PushMnemonic(M: TMnemonic);
begin
  Push(@M, SizeOf(M));
end;

procedure TForthMachine.PushPtr(P: Pointer);
begin
  Push(@P, SizeOf(P));
end;

procedure TForthMachine.PushEmbroPtr(EmbroPtr: TInt);
begin
  Push(@EmbroPtr, SizeOf(EmbroPtr));
end;

procedure TForthMachine.Pop(P: Pointer; Size: Integer);
begin
  if FState = FS_COMPILE then
    PopEmbro(P, Size)
  else
    FStack.Pop(P, Size);
end;

function TForthMachine.Pop: Integer; 
begin
  Pop(@Result, SizeOf(Result));
end;

function TForthMachine.PopMnemonic: TMnemonic;
begin
  Pop(@Result, SizeOf(Result));
end;

function TForthMachine.PopPtr: TPtr;
begin
  Pop(@Result, SizeOf(Result));
end;

function TForthMachine.PopEmbroPtr: TEmbroPtr;
begin
  Pop(@Result, SizeOf(Result));
end;

function TForthMachine.GetEmbroDumpLines: Integer;
begin
  Result := Length(FEmbroDump);
end;

function TForthMachine.GetEmbroDumpLine;
begin
  Result := FEmbroDump[Index];
end;

function TForthMachine.FindCommand(const Name: TString): PForthCommand;
var
  I: Integer;
begin
  for I := High(C) downto 0 do
    if TString(C[I].Name) = Name then begin
      //Writeln('Found command ', C[I].Name);
      Result := C[I];
      Exit;
    end;
  Result := nil;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TIntArithmetic'}{$ENDIF}
constructor GIntArithmetic{$IFNDEF FLAG_FPC}<T>{$ENDIF}.Create(Machine: TForthMachine);
begin
  FMachine := Machine
end;

procedure GIntArithmetic{$IFNDEF FLAG_FPC}<T>{$ENDIF}._plus;
var
  a, b: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  FMachine.Stack.pop(@b, SizeOf(b));
  a := a + b;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure GIntArithmetic{$IFNDEF FLAG_FPC}<T>{$ENDIF}._minus;
var
  a, b: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  FMachine.Stack.pop(@b, SizeOf(b));
  a := a - b;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure GIntArithmetic{$IFNDEF FLAG_FPC}<T>{$ENDIF}._star;
var
  a, b: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  FMachine.Stack.pop(@b, SizeOf(b));
  a := a * b;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure GIntArithmetic{$IFNDEF FLAG_FPC}<T>{$ENDIF}._equel;
var
  a, b: T;
begin
  FMachine.Stack.pop(@b, SizeOf(b));
  FMachine.Stack.pop(@a, SizeOf(a));
  a := - Ord(a = b);
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure GIntArithmetic{$IFNDEF FLAG_FPC}<T>{$ENDIF}._lt;
var
  a, b: T;
begin
  FMachine.Stack.pop(@b, SizeOf(b));
  FMachine.Stack.pop(@a, SizeOf(a));
  a := - Ord(a < b);
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure GIntArithmetic{$IFNDEF FLAG_FPC}<T>{$ENDIF}._gt;
var
  a, b: T;
begin
  FMachine.Stack.pop(@b, SizeOf(b));
  FMachine.Stack.pop(@a, SizeOf(a));
  a := - Ord(a > b);
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure GIntArithmetic{$IFNDEF FLAG_FPC}<T>{$ENDIF}._div;
var
  a, b: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  FMachine.Stack.pop(@b, SizeOf(b));
  a := a div b;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure GIntArithmetic{$IFNDEF FLAG_FPC}<T>{$ENDIF}._mod;
var
  a, b: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  FMachine.Stack.pop(@b, SizeOf(b));
  a := a mod b;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure GIntArithmetic{$IFNDEF FLAG_FPC}<T>{$ENDIF}._dot;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  //Write(a, ' ');
end;

procedure GIntArithmetic{$IFNDEF FLAG_FPC}<T>{$ENDIF}._abs;
//var
  //a: T;
begin
  //FMachine.Stack.pop(@a, SizeOf(a));
  //a := System.Abs(a);
  //FMachine.Stack.push(@a, SizeOf(a));
end;

procedure GIntArithmetic{$IFNDEF FLAG_FPC}<T>{$ENDIF}.neg;
//var
  //a: T;
begin
  //FMachine.Stack.pop(@a, SizeOf(a));
  //a := - a;
  //FMachine.Stack.push(@a, SizeOf(a));
end;

procedure GIntArithmetic{$IFNDEF FLAG_FPC}<T>{$ENDIF}._comma;
begin
  Machine.LogError('unknown arithmetic comma command');
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'int arithmetics'}{$ENDIF}
procedure TIntArithmetic._dot;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Write(a, ' ');
end;

procedure TIntArithmetic._abs;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  a := System.Abs(a);
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TIntArithmetic.neg; 
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  a := - a;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TIntArithmetic._comma;
var
  a: T;
begin
  Machine.Stack.pop(@a, SizeOf(a));
  Move(a, Machine.Here^, SizeOf(T));
  Machine.IncHere(SizeOf(T));
end;

procedure TInt8Arithmetic._dot;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Write(a, ' ');
end;

procedure TInt8Arithmetic._abs;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  a := System.Abs(a);
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TInt8Arithmetic.neg; 
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  a := - a;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TInt8Arithmetic.ToInt;
var
  a: T;
  i: TInt;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  i := a;
  FMachine.Stack.push(@i, SizeOf(i));
end;

procedure TInt8Arithmetic.FromInt;
var
  a: T;
  i: TInt;
begin
  FMachine.Stack.pop(@i, SizeOf(i));
  a := i;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TInt8Arithmetic._comma;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Move(a, Machine.Here^, SizeOf(T));
  Machine.IncHere(SizeOf(T));
end;

procedure TInt16Arithmetic._dot;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Write(a, ' ');
end;

procedure TInt16Arithmetic._abs;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  a := System.Abs(a);
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TInt16Arithmetic.neg; 
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  a := - a;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TInt16Arithmetic.ToInt;
var
  a: T;
  i: TInt;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  i := a;
  FMachine.Stack.push(@i, SizeOf(i));
end;

procedure TInt16Arithmetic.FromInt;
var
  a: T;
  i: TInt;
begin
  FMachine.Stack.pop(@i, SizeOf(i));
  a := i;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TInt16Arithmetic._comma;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Move(a, Machine.Here^, SizeOf(T));
  Machine.IncHere(SizeOf(T));
end;

procedure TInt32Arithmetic._dot;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Write(a, ' ');
end;

procedure TInt32Arithmetic._abs;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  a := System.Abs(a);
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TInt32Arithmetic.neg; 
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  a := - a;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TInt32Arithmetic.ToInt;
var
  a: T;
  i: TInt;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  i := a;
  FMachine.Stack.push(@i, SizeOf(i));
end;

procedure TInt32Arithmetic.FromInt;
var
  a: T;
  i: TInt;
begin
  FMachine.Stack.pop(@i, SizeOf(i));
  a := i;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TInt32Arithmetic._comma;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Move(a, Machine.Here^, SizeOf(T));
  Machine.IncHere(SizeOf(T));
end;

procedure TInt64Arithmetic._dot;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Write(a, ' ');
end;

procedure TInt64Arithmetic._abs;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  a := System.Abs(a);
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TInt64Arithmetic.neg; 
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  a := - a;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TInt64Arithmetic.ToInt;
var
  a: T;
  i: TInt;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  i := a;
  FMachine.Stack.push(@i, SizeOf(i));
end;

procedure TInt64Arithmetic.FromInt;
var
  a: T;
  i: TInt;
begin
  FMachine.Stack.pop(@i, SizeOf(i));
  a := i;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TInt64Arithmetic._comma;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Move(a, Machine.Here^, SizeOf(T));
  Machine.IncHere(SizeOf(T));
end;

procedure TUIntArithmetic._dot;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Write(a, ' ');
end;

procedure TUIntArithmetic.ToInt;
var
  a: T;
  i: TUint;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  i := a;
  FMachine.Stack.push(@i, SizeOf(i));
end;

procedure TUIntArithmetic.FromInt;
var
  a: T;
  i: TUInt;
begin
  FMachine.Stack.pop(@i, SizeOf(i));
  a := i;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TUIntArithmetic._comma;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Move(a, Machine.Here^, SizeOf(T));
  Machine.IncHere(SizeOf(T));
end;

procedure TUInt8Arithmetic._dot;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Write(a, ' ');
end;

procedure TUInt8Arithmetic.ToInt;
var
  a: T;
  i: TUint;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  i := a;
  FMachine.Stack.push(@i, SizeOf(i));
end;

procedure TUInt8Arithmetic.FromInt;
var
  a: T;
  i: TUInt;
begin
  FMachine.Stack.pop(@i, SizeOf(i));
  a := i;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TUInt8Arithmetic._comma;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Move(a, Machine.Here^, SizeOf(T));
  Machine.IncHere(SizeOf(T));
end;

procedure TUInt16Arithmetic._dot;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Write(a, ' ');
end;

procedure TUInt16Arithmetic.ToInt;
var
  a: T;
  i: TUint;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  i := a;
  FMachine.Stack.push(@i, SizeOf(i));
end;

procedure TUInt16Arithmetic.FromInt;
var
  a: T;
  i: TUInt;
begin
  FMachine.Stack.pop(@i, SizeOf(i));
  a := i;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TUInt16Arithmetic._comma;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Move(a, Machine.Here^, SizeOf(T));
  Machine.IncHere(SizeOf(T));
end;

procedure TUInt32Arithmetic._dot;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Write(a, ' ');
end;

procedure TUInt32Arithmetic.ToInt;
var
  a: T;
  i: TUint;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  i := a;
  FMachine.Stack.push(@i, SizeOf(i));
end;

procedure TUInt32Arithmetic.FromInt;
var
  a: T;
  i: TUInt;
begin
  FMachine.Stack.pop(@i, SizeOf(i));
  a := i;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TUInt32Arithmetic._comma;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Move(a, Machine.Here^, SizeOf(T));
  Machine.IncHere(SizeOf(T));
end;

procedure TUInt64Arithmetic._dot;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Write(a, ' ');
end;

procedure TUInt64Arithmetic.ToInt;
var
  a: T;
  i: TUint;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  i := a;
  FMachine.Stack.push(@i, SizeOf(i));
end;

procedure TUInt64Arithmetic.FromInt;
var
  a: T;
  i: TUInt;
begin
  FMachine.Stack.pop(@i, SizeOf(i));
  a := i;
  FMachine.Stack.push(@a, SizeOf(a));
end;

procedure TUInt64Arithmetic._comma;
var
  a: T;
begin
  FMachine.Stack.pop(@a, SizeOf(a));
  Move(a, Machine.Here^, SizeOf(T));
  Machine.IncHere(SizeOf(T));
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}

// ( Вся соль :)
all_implement

end.

{
var
  testptr,param:pointer;
  mm:TMemoryStream;
  i,paramsize:integer;
begin
  testptr:=@test;
  mm:=TMemoryStream.Create;
// в обратном порядке кидаю параметры в память
  i:=20;
  mm.Write(i,sizeof(i));
  i:=10;
  mm.Write(i,sizeof(i));
// здесь надо кидать по 4 байта - или указатель, или значение.
  mm.Position:=0;
  paramsize:=mm.Size;
  param:=mm.Memory;
  asm
    mov eax,0
    mov ecx,0
    lab:
    mov ebx,[Param+ecx]
    // получаю значение под указателем
    // если этого не сделать, то положим указатель на память вместо значения.
    mov ebx,[ebx]
    // в стек
    push ebx
    add ecx,4
    cmp ecx,ParamSize
    jne lab
    // сам вызов
    call [testptr]
  end;
    mov eax, work
    mov ecx, param
    cycle:
      mov ebx, BYTE [ecx] // получаем значение текущего байта
      jz endcycle // если 0, то выходим из цикла
      push [eax] // переносим очередной параметр на стек
      sub eax, ebx // сдвигаем указатели
      inc ecx
      jmp cycle // повторяем операцию
    endcycle:
      inc ecx
      call [ecx] // вызываем функцию
      add ecx, 4
      pop [eax] // переносим результат на рабочий стек форта
      add eax, BYTE [ecx]
      mov work, eax // сменяем положение стека
end;




Чистить стек можно с помощью любого регистра pop-ами, а можно сделать проще - просто сохранить esp где ни будь и восстановить. Вобще то любую переменную больше 4 байт обычно передают по адресу, так как она уже является массивом и считывать ее придется уже побайтово, тоесть инкрементируя адрес. Но я правда не уверен насчет языков высокого уровня, что там из себя представляют переменные. Я бы делал для надежности так :
int a;
LEA eax,a
mov ebx,[eax]
ну это конечно утрировано, но зато надежно.

mov ebx,[Param+ecx]
mov ebx,[ebx]

Вот в эту шаманскую песенку я не вкурил. [Param+ecx] это уже ваша переменная со смещением, двойное слово. Или там в param список адресов? 





В param - адрес на память, где находятся параметры.
param:=mm.Memory;

сначала ecx=0, с каждым проходом цикла он увеличивается на 4
add ecx,4

и так пока ecx не станет равным ParamSize - общей сумме размеров параметров.

а что такое
LEA eax,a
mov ebx,[eax]
? для типа extended не работает - он передается как 2 dword и один word.
Например, для (-5.5):
push $0000c001
push $b0000000
push $00
из CPU-debug. 

}
))))))))))))))))))))))))))))))))))))))))))))))))
_out
