_file(
unit DForthMachine;

interface

{$DEFINE FLAG_X86}
{$DEFINE FLAG_IA32}
define(~_X86|)
define(~_IA32|)

ifdef(_IA32,,define(~N_IA32|))
ifdef(_X86,,define(~N_X86|))

uses
  {$I units.inc},

  Math,
  strings,
  DAlien,
  DVocabulary,
  DForthStack;

const
  DFORTHMACHINE_VERSION = 11;

dnl define(~_comma|, ~~,||)
define(~all_implement|, ~|)
define(~regist_all_commands|, ~|)
define(~all_create|, ~|)
define(~all_free|, ~|)
define(~cmdhdr|, ~(Machine: TForthMachine; Command: PForthCommand)|)
define(~WVar|, ~(Pointer(TUInt(Machine.WP) + ($1))^)|)
define(~LVar|, ~(Pointer(TUInt(LB) + ($1))^)|)
define(~WInc|, ~Inc(WP, $1)|)
define(~WDec|, ~Dec(TUInt(WP), $1)|)
define(~PSize|, ~(SizeOf(Pointer))|)
define(~CELL|, ~(SizeOf(Pointer))|)
define(~BInc|, ~Inc(BWP, CELL)|)
define(~BDec|, ~Dec(TUInt(BWP), CELL)|)
define(~BVar|, ~TBlock(Pointer(TUInt(Machine.BWP) + ($1)*CELL)^)|)
define(~binc|, ~ if $1 <> nil then begin
                   if PInteger($1)^ <> -1 then Inc(PInteger($1)^); 
                 end|)
define(~bdec|, ~ if $1 <> nil then begin
                   if PInteger($1)^ > 1 then Dec(PInteger($1)^)
                   else if PInteger($1)^ = 1 then FreeMem(Pointer($1)); 
                 end|)
define(~genname|, ~ifelse($1, ~|, $2, len($1), ~1|, $2, $1-$2)|)
define(~body|, ~begin with Machine^ do begin $1 end; end;|)
{$IFNDEF FLAG_FPC}{$REGION 'typed_commands'}{$ENDIF}
define(~typed_commands|, 
  ~
    procedure drop_$1 cmdhdr;
    procedure dup_$1 cmdhdr;
    procedure nip_$1 cmdhdr;
    procedure swap_$1 cmdhdr;
    procedure over_$1 cmdhdr;
    procedure tuck_$1 cmdhdr;
    procedure lrot_$1 cmdhdr;
    procedure rrot_$1 cmdhdr;
    procedure lrotn_$1 cmdhdr;
    procedure rrotn_$1 cmdhdr;
    procedure pick_$1 cmdhdr;
    procedure _comma_$1 cmdhdr;
    procedure _dog_$1 cmdhdr;
    procedure _exclamation_$1 cmdhdr;
    procedure ptr_plus_$1 cmdhdr;
    procedure _to_$1 cmdhdr;
    procedure _compile_to_$1 cmdhdr;
    procedure _run_to_$1 cmdhdr;
    procedure _interpret_to_$1 cmdhdr;
    procedure _value_$1 cmdhdr;
    procedure _variable_$1 cmdhdr;
    procedure RunValue_$1 cmdhdr;
    procedure literal_$1 cmdhdr;
    procedure run_literal_$1 cmdhdr
  define(~all_implement|, all_implement 
    ~
     ifdef(~_IA32|,
       ~
         procedure drop_$1 cmdhdr;
         idle(asm
           sub [eax], 4
         end;)
         {procedure dup_$1 cmdhdr;
         idle(asm
           mov ecx, [eax]
           mov edx, [ecx-4]
           mov [ecx], edx
           add [eax], 4
         end;)}
         procedure dup_$1 cmdhdr; body(Move(WVar(-$2), WVar(0), $2); WInc($2); )
         procedure nip_$1 cmdhdr;
         idle(asm
           mov ecx, [eax]
           lea ecx, [ecx-4]
           mov edx, [ecx]
           mov [ecx-4], edx
           mov [eax], ecx
         end;)
         procedure swap_$1 cmdhdr;
         idle(asm
           mov ecx, [eax]
           mov edx, [ecx-4]
           xchg [ecx-8], edx
           mov [ecx-4], edx
         end;)
         procedure over_$1 cmdhdr;
         idle(asm
           mov ecx, [eax]
           mov edx, [ecx-8]
           mov [ecx], edx
           add [eax], 4
         end;)
         procedure tuck_$1 cmdhdr;
         idle(asm // ab-bab  @wp=eax 
           mov ecx, [eax]       // ecx := wp 
           add [eax], 4         // @wp++
           mov edx, [ecx-4]     // edx := b
           mov [ecx], edx       // top := b
           mov eax, [ecx-8]     // eax := a
           mov [ecx-4], eax     // top[1] := a
           mov [ecx-8], edx     // top[2] := b
         end;)
       |,
       procedure drop_$1 cmdhdr; body(Dec(WP, $2))
       procedure dup_$1 cmdhdr; body(Move(WVar(-$2), WVar(0), $2); WInc($2))
       procedure nip_$1 cmdhdr; body(Move(WVar(-1*$2), WVar(-2*$2), $2); Dec(WP, $2))
       procedure swap_$1 cmdhdr; body(Move(WVar(-$2), WP^, $2); Move(WVar(-2*$2), WVar(-$2), $2); Move(WP^, WVar(-2*$2), $2);)
       procedure over_$1 cmdhdr; body(Move(WVar(-2*$2), WVar(0), $2); Inc(WP, $2))
       procedure tuck_$1 cmdhdr; body(Move(WVar(-2*$2), WVar(-1*$2), 2*$2); Move(WVar(0), WVar(-2*$2), $2); WInc($2);body)
     )
     procedure lrot_$1 cmdhdr; 
     body(
       Move(WVar(-1*$2), WP^, $2);
       Move(WVar(-3*$2), WVar(-1*$2), $2);
       Move(WVar(-2*$2), WVar(-3*$2), $2);
       Move(WP^, WVar(-2*$2), $2);
     )
     procedure rrot_$1 cmdhdr;
     body( 
       Move(WVar(-1*$2), WP^, $2);
       Move(WVar(-2*$2), WVar(-1*$2), $2);
       Move(WVar(-3*$2), WVar(-2*$2), $2);
       Move(WP^, WVar(-3*$2), $2);
     )
     procedure lrotn_$1 cmdhdr; 
     var
       N: Integer;
     body( 
       Dec(WP, SizeOf(TInt));
       N := TInt(WP^);
       Move(WVar(-$2*N), WVar(0), $2);
       while N > 0 do begin
         Move(WVar(-$2*(N-1)), WVar(-$2*N), $2);
         Dec(N);
       end;
       //Move(WVar(0), WVar(-$2), $2);
     )
     procedure rrotn_$1 cmdhdr;
     var
       I: Integer;
       N: Integer;
     body(
       Dec(WP, SizeOf(TInt));
       N := TInt(WP^);
       //Move(WVar(-$2), WVar(0), $2);
       for I := 0 to N - 1 do
         Move(WVar(-$2*(I+1)), WVar(-$2*I), $2);
       Move(WVar(0), WVar(-N*$2), $2);
     )
     procedure pick_$1 cmdhdr; 
     body( 
       Move(WVar(-SizeOf(TInt) -$2*TInt(WVar(-SizeOf(TInt)))), 
            WVar(-SizeOf(TInt)),
            $2);
       WInc($2 - SizeOf(TInt));
     )
     procedure _comma_$1 cmdhdr; body( Dec(WP, $2); ifelse(~|,$1,
                                                            EWI(Integer(WP^)),
                                                            EWV(WP, $2); ) )
     procedure _dog_$1 cmdhdr; body( Move(Pointer(WVar(-PSize))^, WVar(-PSize), $2); Inc(WP, $2 - PSize) )
     procedure _exclamation_$1 cmdhdr; body( Move(WVar(-PSize-$2), Pointer(WVar(-PSize))^, $2); Dec(WP, PSize + $2) )
     procedure ptr_plus_$1 cmdhdr; body( PtrInt(WVar(-SizeOf(Pointer))) := PtrInt(WVar(-SizeOf(Pointer))) + $2; )
     procedure _to_$1 cmdhdr; body( if State <> FS_INTERPRET then _compile_to_$1(Machine, Command) else _interpret_to_$1(Machine, Command); )
     procedure _compile_to_$1 cmdhdr; body( BuiltinEWO('run@genname($1, ~to|)'); EWO(NextName); )
     procedure _run_to_$1 cmdhdr; var O: TOpcode; body( O := ERO; Move(WVar(-$2), C[O].Data^, $2); Dec(WP, $2); )
     procedure _interpret_to_$1 cmdhdr; var N: TString; Comm: PForthCommand; body( N := NextName; Comm := FindCommand(N);
               if Comm = nil then begin LogError('unkown name after genname($1, ~to|): ' + N); FSession := False; Exit; end; 
               Move(WVar(-$2), Comm.Data^, $2); Dec(WP, $2);
             )
     procedure _value_$1 cmdhdr; body( with ReserveName(SNN)^ do begin Data := Here; Code := RunValue_$1; Move(WVar(-$2), Here^, $2); Dec(WP, $2); EA($2); Flags := Flags and not 1; end; )
     procedure _variable_$1 cmdhdr; body( with ReserveName(SNN)^ do begin Data := Here; Code := PutDataPtr; {Dec(WP, $2); Move(WP^, Here^, $2);} EA($2); end; )
     procedure RunValue_$1 cmdhdr; body( Move(Command.Data^, WP^, $2); Inc(WP, $2); )
    procedure literal_$1 cmdhdr; body( BuiltinEWO('genname($1, (literal))'); Dec(WP, $2); 
                                       ifelse(~|,$1,
                                              EWI(Integer(WP^)), 
                                              EWV(WP, $2);) )
    procedure run_literal_$1 cmdhdr; body( ERV(WP, $2); Inc(WP, $2); )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     AddCommand('genname($1, drop)', drop_$1);
     AddCommand('genname($1, dup)', dup_$1);
     AddCommand('genname($1, nip)', nip_$1);
     AddCommand('genname($1, swap)', swap_$1);
     AddCommand('genname($1, over)', over_$1);
     AddCommand('genname($1, tuck)', tuck_$1);
     AddCommand('genname($1, lrot)', lrot_$1);
     AddCommand('genname($1, rrot)', rrot_$1);
     AddCommand('genname($1, lrotn)', lrotn_$1);
     AddCommand('genname($1, rrotn)', rrotn_$1);
     AddCommand('genname($1, pick)', pick_$1);
     AddCommand('$1,', _comma_$1);
     AddCommand('$1@', _dog_$1);
     AddCommand('$1!', _exclamation_$1);
     AddCommand('ptr+$1', ptr_plus_$1);
     AddCommand('genname($1, to)', _to_$1, True);
     AddCommand('compile@genname($1, to)', _compile_to_$1);
     AddCommand('run@genname($1, to)', _run_to_$1);
     AddCommand('interpret@genname($1, to)', _interpret_to_$1);
     AddCommand('genname($1, value)', _value_$1);
     AddCommand('genname($1, constant)', _value_$1);
     AddCommand('genname($1, variable)', _variable_$1);
     AddCommand('genname($1, literal)', literal_$1, True);
     AddCommand('genname($1, (literal))', run_literal_$1);
    |)
|)
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'data_commands'}{$ENDIF}
define(~data_commands|, 
  ~
  procedure $1_to cmdhdr;
  procedure interprete_$1_to cmdhdr;
  procedure compile_$1_to cmdhdr;
  procedure run_$1_to cmdhdr
  define(~all_implement|, all_implement 
    ~
     procedure $1_to cmdhdr; body( if Machine.State = FS_COMPILE then compile_$1_to(Machine, Command) else interpete_$1_to(Machine, Command) )
     procedure interprete_$1_to cmdhdr; body(  )
     procedure compile_$1_to cmdhdr; body(  )
     procedure run_$1_to cmdhdr; body(  )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
    |)
|)
define(~exception_commands|, 
  ~
  procedure _sys_exceptions_execute cmdhdr;
  procedure _sys_exceptions_pop cmdhdr;
  procedure _throw cmdhdr;
  define(~all_create|, all_create
    ExceptionsS := 1024;
    SetLength(Exceptions, ExceptionsS);
    ExceptionsB := @Exceptions[0];
    ExceptionsP := @Exceptions[0]
  )
  define(~all_implement|, all_implement 
    ~
     procedure _sys_exceptions_execute cmdhdr;
     body( 
       Integer(ExceptionsP^) := 0;
       Inc(ExceptionsP, SizeOf(Integer));
       Integer(ExceptionsP^) := EC;
       Inc(ExceptionsP, SizeOf(Integer));
       Pointer(ExceptionsP^) := WP;
       Inc(ExceptionsP, SizeOf(Pointer));
       Pointer(ExceptionsP^) := RP;
       Inc(ExceptionsP, SizeOf(Pointer));
       execute(Machine, Command);
     )
     procedure _sys_exceptions_pop cmdhdr;
     body(
       Dec(ExceptionsP, 2*SizeOf(Integer) + 2*SizeOf(Pointer));
       WUI(Integer(ExceptionsP^));
     )
     procedure _throw cmdhdr; 
     body( 
       Integer((@PArrayOfByte(ExceptionsP)^[-2*SizeOf(Pointer)-2*SizeOf(Integer)])^) := WOI;
       EC := Integer((@PArrayOfByte(ExceptionsP)^[-2*SizeOf(Pointer)-SizeOf(Integer)])^);
       RP := Pointer((@PArrayOfByte(ExceptionsP)^[-1*SizeOf(Pointer)])^);
       WP := Pointer((@PArrayOfByte(ExceptionsP)^[-2*SizeOf(Pointer)])^);
     )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
      AddCommand('sys-exceptions-execute', _sys_exceptions_execute);
      AddCommand('sys-exceptions-pop', _sys_exceptions_pop);
      AddCommand('throw', _throw);
    |)
|)
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'arithmetic_commands'}{$ENDIF}
define(~arithmetic_commands|, 
  ~
  procedure $1_plus cmdhdr;
  procedure $1_minus cmdhdr;
  procedure $1_star cmdhdr;
  procedure $1_equel cmdhdr;
  procedure $1_nequel cmdhdr;
  procedure $1_lt cmdhdr;
  procedure $1_gt cmdhdr;
  procedure $1_lte cmdhdr;
  procedure $1_gte cmdhdr;  
  procedure $1_0_equel cmdhdr;
  procedure $1_0_nequel cmdhdr;
  procedure $1_0_lt cmdhdr;
  procedure $1_0_gt cmdhdr;
  procedure $1_0_lte cmdhdr;
  procedure $1_0_gte cmdhdr;
  procedure $1_ask_dup cmdhdr;
  procedure $1_0_exit cmdhdr;
  procedure $1_if_exit cmdhdr;
  procedure $1_max cmdhdr;
  procedure $1_min cmdhdr;
  procedure $1_minmax cmdhdr;
  procedure $1_dot cmdhdr;
  procedure $1_dollar cmdhdr;
  procedure $1_ptr_plus_exclamation cmdhdr;
  procedure $1_conv_to_str cmdhdr;
  procedure $1_conv_from_str cmdhdr
  define(~all_implement|, all_implement 
    ~
      procedure $1_plus  cmdhdr; body( $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) + $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); )
      procedure $1_minus cmdhdr; body( $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) - $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); )
      procedure $1_star  cmdhdr; body( $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) * $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); )
      procedure $1_equel cmdhdr; body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) = $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_nequel cmdhdr; body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) <> $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_lt cmdhdr;    body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) < $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_gt cmdhdr;    body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) > $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_lte cmdhdr;   body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) <= $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_gte cmdhdr;   body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) >= $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_0_equel cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) = 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_0_nequel cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) <> 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_0_lt cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) < 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_0_gt cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) > 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_0_lte cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) <= 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_0_gte cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) >= 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_ask_dup cmdhdr; body( if ($2(WVar(-1*SizeOf($2)))) <> 0 then begin $2(WP^) := $2(WVar(-1*SizeOf($2))); Inc(WP, SizeOf($2)); end; )
      procedure $1_0_exit cmdhdr; body( if $2(WVar(-SizeOf($2))) = 0 then begin Dec(WP, SizeOf($2)); _exit(Machine, Command); end )
      procedure $1_if_exit cmdhdr; body( if $2(WVar(-SizeOf($2))) <> 0 then begin Dec(WP, SizeOf($2)); _exit(Machine, Command); end )
      procedure $1_max cmdhdr;
      body(
        if $2(WVar(-2*SizeOf($2))) < $2(WVar(-1*SizeOf($2))) then
          Move(WVar(-1*SizeOf($2)), WVar(-2*SizeOf($2)), SizeOf($2));
        Dec(WP, SizeOf($2));
      )
      procedure $1_min cmdhdr;
      body(
        if $2(WVar(-2*SizeOf($2))) > $2(WVar(-1*SizeOf($2))) then
          Move(WVar(-1*SizeOf($2)), WVar(-2*SizeOf($2)), SizeOf($2));
        Dec(WP, SizeOf($2));
      )
      procedure $1_minmax cmdhdr;
      body(
        if $2(WVar(-2*SizeOf($2))) > $2(WVar(-1*SizeOf($2))) then begin
          Move(WVar(-2*SizeOf($2)), WVar(-0*SizeOf($2)), SizeOf($2));
          Move(WVar(-1*SizeOf($2)), WVar(-2*SizeOf($2)), SizeOf($2));
          Move(WVar(-0*SizeOf($2)), WVar(-1*SizeOf($2)), SizeOf($2));
        end;
      )
      procedure $1_dot cmdhdr;    body( Dec(WP, SizeOf($2)); Write($2(WP^), ' '); )
      procedure $1_dollar cmdhdr; var Temp: $2; body( Read(Temp); Move(Temp, WP^, SizeOf($2)); Inc(WP, SizeOf($2)); )
      procedure $1_ptr_plus_exclamation cmdhdr; body( $2(Pointer(WVar(-SizeOf(Pointer)))^) := $2(Pointer(WVar(-SizeOf(Pointer)))^) + $2(WVar(-SizeOf(Pointer)-SizeOf($2))); Dec(WP, SizeOf(Pointer) + SizeOf($2)); )
      procedure $1_conv_to_str cmdhdr;
      var
        B: TString;
      body(
        Str($2(WVar(-SizeOf($2))), B);
        Dec(WP, SizeOf($2));
        str_push(Machine, B);
      )
      procedure $1_conv_from_str cmdhdr;
      var
        B: TStr;
        Res: Word;
      body(
        B := str_pop(Machine);
        Val(PChar(@(TStrRec(B^).Sym[0])), $2(WP^), Res);
        Inc(WP, SizeOf($2));
        DelRef(B);
      )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     AddCommand('$1+', $1_plus);
     AddCommand('$1-', $1_minus);
     AddCommand('$1*', $1_star);
     AddCommand('$1=', $1_equel);
     AddCommand('$1<>', $1_nequel);
     AddCommand('$1<', $1_lt);
     AddCommand('$1>', $1_gt);
     AddCommand('$1<=', $1_lte);
     AddCommand('$1>=', $1_gte);
     AddCommand('genname($1, 0=)', $1_0_equel);
     AddCommand('genname($1, 0<>)', $1_0_nequel);
     AddCommand('genname($1, 0<)', $1_0_lt);
     AddCommand('genname($1, 0>)', $1_0_gt);
     AddCommand('genname($1, 0<=)', $1_0_lte);
     AddCommand('genname($1, 0>=)', $1_0_gte);
     AddCommand('genname($1, ?dup)', $1_ask_dup);
     addcommand('genname($1, 0;)', $1_0_exit);
     addcommand('genname($1, if;)', $1_if_exit);
     AddCommand('genname($1, min)', $1_min);
     AddCommand('genname($1, max)', $1_max);
     AddCommand('genname($1, minmax)', $1_minmax);
     AddCommand('$1.', $1_dot);
     AddCommand('$1$', $1_dollar);
     AddCommand('$1+!', $1_ptr_plus_exclamation);
     AddCommand('$1->str', $1_conv_to_str);
     AddCommand('str->$1', $1_conv_from_str);
    |)
|)
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'signed_arithmetic_commands'}{$ENDIF}
define(~signed_arithmetic_commands|, 
  ~
  procedure $1_abs cmdhdr;
  procedure $1_neg cmdhdr
  define(~all_implement|, all_implement 
    ~procedure $1_abs cmdhdr; body( $2(WVar(-SizeOf($2))) := Abs($2(WVar(-SizeOf($2)))); )
     procedure $1_neg cmdhdr; body( $2(WVar(-SizeOf($2))) := - $2(WVar(-SizeOf($2))); )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~AddCommand('genname($1, abs)', $1_abs);
     AddCommand('genname($1, neg)', $1_neg);
    |)
|)
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'number_arithmetic_commands'}{$ENDIF}
define(~number_arithmetic_commands|, 
  ~
  procedure $1_push  cmdhdr;
  procedure $1_interpret_push  cmdhdr;
  procedure $1_compile_push  cmdhdr;
  procedure $1_run_push  cmdhdr;
  procedure $1_1_plus cmdhdr;
  procedure $1_1_minus cmdhdr;
  procedure $1_div cmdhdr;
  procedure $1_mod cmdhdr;
  procedure $1_divmod cmdhdr;
  procedure $1_shl cmdhdr;
  procedure $1_shr cmdhdr;
  procedure $1_power cmdhdr;
  procedure $1_ptr_inc cmdhdr;
  procedure $1_ptr_dec cmdhdr
  define(~all_implement|, all_implement 
    ~
     procedure $1_push  cmdhdr; body( if State = FS_COMPILE then $1_compile_push(Machine, Command) else $1_interpret_push(Machine, Command) )
     procedure $1_interpret_push  cmdhdr; body( $2(WP^) := $2(StrToInt(NextName)); Inc(WP, SizeOf($2)); )
     procedure $1_compile_push  cmdhdr; body( BuiltinEWO('run@$1-push'); EW_$1(StrToInt(NextName)); )
     procedure $1_run_push  cmdhdr; body( $2(WP^) := ER_$1; Inc(WP, SizeOf($2)); )
     procedure $1_1_plus cmdhdr;  body( Inc($2(WVar(-SizeOf($2)))) )
     procedure $1_1_minus cmdhdr; body( Dec($2(WVar(-SizeOf($2)))) )
     procedure $1_div cmdhdr; body( $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) div $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); )
     procedure $1_mod cmdhdr; body( $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) mod $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); )
     procedure $1_divmod cmdhdr; body( $2(WVar(0)) := $2(WVar(-2*SizeOf($2))) mod $2(WVar(-SizeOf($2))); 
                                                     $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) div $2(WVar(-SizeOf($2)));
                                                     $2(WVar(-  SizeOf($2))) := $2(WVar(0)); 
                                               )
     procedure $1_shl cmdhdr; body( Dec(WP, SizeOf($2));
                    $2(WVar(-SizeOf($2))) := $2(WVar(-SizeOf($2))) shl $2(WVar(0)) )
     procedure $1_shr cmdhdr; body( Dec(WP, SizeOf($2));
                    $2(WVar(-SizeOf($2))) := $2(WVar(-SizeOf($2))) shr $2(WVar(0)) )
     procedure $1_power cmdhdr; 
     idle(var 
       Power, Base, Value: Cardinal;) 
     body(
       Power := WOI;
       Base := WOI;
       Value := 1;
       while Power > 0 do begin
         if (Power mod 2) > 0 then
           Value := Value * Base;
         Base := Base * Base;
         Power := Power div 2;
       end;
       WUI(Value);
     )
     procedure $1_ptr_inc cmdhdr;
     body(
       $2(Pointer(WVar(-SizeOf(Pointer)))^) := 
                         $2(Pointer(WVar(-SizeOf(Pointer)))^) + 1; 
       Dec(WP, SizeOf(Pointer));
     )
     procedure $1_ptr_dec cmdhdr;
     body(
       $2(Pointer(WVar(-SizeOf(Pointer)))^) := 
                         $2(Pointer(WVar(-SizeOf(Pointer)))^) - 1; 
       Dec(WP, SizeOf(Pointer));
     )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     AddCommand('$1-push', $1_push, True);
     AddCommand('run@$1-push', $1_run_push);
     AddCommand('genname($1, inc)', $1_1_plus);
     AddCommand('genname($1, dec)', $1_1_minus);
     ifelse($1, ~|, AddCommand('1+', $1_1_plus);)
     ifelse($1, ~|, AddCommand('1-', $1_1_minus);)
     AddCommand('genname($1, inc!)', $1_ptr_inc);
     AddCommand('genname($1, dec!)', $1_ptr_dec);
     ifelse($1, ~|, AddCommand('1+!', $1_ptr_inc);)
     ifelse($1, ~|, AddCommand('1-!', $1_ptr_dec);)
     AddCommand('genname($1, div)', $1_div);
     AddCommand('genname($1, mod)', $1_mod);
     AddCommand('genname($1, divmod)', $1_divmod);
     AddCommand('genname($1, shl)', $1_shl);
     AddCommand('genname($1, shr)', $1_shr);
     AddCommand('genname($1, **)', $1_power);
    |)
|)
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'convert_number_arithmetic_commands'}{$ENDIF}
define(~convert_number_arithmetic_commands|, 
  ~
  procedure $1_convert_to_$3 cmdhdr
  define(~all_implement|, all_implement 
    ~
     procedure $1_convert_to_$3 cmdhdr; body( $4(WVar(-SizeOf($2))) := $2(WVar(-SizeOf($2))); 
                                                            Dec(WP, SizeOf($2) - SizeOf($4)); )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~AddCommand('$1->$3', $1_convert_to_$3);
    |)
|)
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'sysar_commands'}{$ENDIF}
define(~sysar_commands|, 
  ~
  function ConvertStrTo$1(const B: TString; var X: $2): Integer
  define(~all_implement|, all_implement 
    ~
       function OForthMachine.ConvertStrTo$1(const B: TString; var X: $2): Integer;
       var
         D: Byte;
             function GetDigit(C: TChar; var D: Byte): Boolean;
             begin
               Result := True;
               case C of
                 '0'..'9': D := Ord(C) - Ord('0');
                 'a'..'f': D := Ord(C) - Ord('a') + 10;
                 'A'..'F': D := Ord(C) - Ord('F') + 10;
               else
                 Result := False;
               end;
             end;
       begin
         X := 0;
         Result := Ord(Length(B) <> 0);
         if Result = 0 then
           Exit; 
         if B[1] = 'h' then begin
           Inc(Result);
           while Result <= Length(B) do begin
             if not GetDigit(B[Result], D) then
               Exit;
             X := (X shl 4) or D;
             Inc(Result);
           end;
           Result := 0;
         end else
           Val(B, X, Result);
       end;
    |
  )
|)
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'system_commands'}{$ENDIF}
define(~system_commands|, 
  ~
  procedure EW_$1 (V: $2);
  function ER_$1: $2
  define(~all_implement|, all_implement 
    ~
      procedure OForthMachine.EW_$1; begin EWV(@V, SizeOf(V)) end;
      function OForthMachine.ER_$1; begin ERV(@Result, SizeOf(Result)) end;
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
    |)
|)
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'stack utils'}{$ENDIF}
define(~push_interface|, ~procedure $1(const V: $2); overload 
  define(~all_implement|, all_implement 
     procedure OForthMachine.$1(const V: $2); begin $2($3^) := V; Inc($3, SizeOf(V)) end;
  )|)
define(~pop_interface|, ~function $1: $2 
  define(~all_implement|, all_implement 
    ~function OForthMachine.$1: $2; begin Dec($3, SizeOf(Result)); Result := $2($3^); end;
    |)|)
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}

const
  BOOL_FALSE: Integer   = 0;
  BOOL_TRUE: Integer    = -1;

  CONV_STDCALL: Integer = 100;
  CONV_CDECL: Integer   = 101;

  MACHINE_MODE_READY            = $00;
  MACHINE_MODE_BREAKPOINT       = $01;
  MACHINE_MODE_WAITSOURCE       = $02;
  MACHINE_MODE_WORK             = $03;

  FS_INTERPRET                  = $00;
  FS_COMPILE                    = not $00;
  // FS_RUN                        = $02;

  DF_FILE_R                     = $A0;
  DF_FILE_W                     = $A1;

  EOL: String                   = #13;

type
  TForthMachine = ^OForthMachine;

  PForthCommand = ^TForthCommand;

  // Machine размещается в EAX
  // Command размещается в EDX
  TCode = procedure (Machine: TForthMachine; Command: PForthCommand); register;

  TForthCommand = record 
          Code: TCode;
          Data: Pointer;
          Flags: Byte;
          Name: PAnsiChar; 
          Param: Pointer;
        end;

  TCallback = procedure (machine: Pointer); stdcall;
  TForthRuntimeProc = procedure (machine: TForthMachine; Command: PForthCommand) 
                                                                      of object;
  TForthCommandProc = procedure (machine: TForthMachine) of object;

  TMnemonic = TInt;
  TOpcode = TInt;
  TPtr = Pointer;
  TEmbroPtr = TInt;

  TRecBlock = packed record
    Ref: TInt;
  end;
  TBlock = ^TRecBlock;

  TStrRec = packed record
    Ref: TInt;
    Len: TInt;
    Width: TInt;
    Sym: array[0..1] of Byte;
  end;
  PStrRec = ^TStrRec;
  TStr = PStrRec;

  PLong = ^TLong;
  TLong = record
    Ref: Integer; // -1 если не нужно высвобождать из памяти, иначе --- число ссылок
    Flags: Integer; // Flags and 1 > 0 если число отрицательно
    Len: Integer; // Такое число, что V[I] = 0 для всех I >= Len
    Max: Integer; // Число элементов в массиве V
    V: array[0..1] of Integer;
  end;

  TType = record
    Name: PChar;
    Size: Integer;
  end;
  PType = ^TType;

  TEmbroItemInfo = packed record
    Typ: TUInt8;
    Size: TUInt16;
    Reserver: TUInt8;
  end;
{$IFNDEF FLAG_FPC}{$REGION 'OForthMachine'}{$ENDIF}
OForthMachine = object
{$IFNDEF FLAG_FPC}{$REGION 'machine datas'}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'W'}{$ENDIF}
  WP: Pointer; // Work stack Pointer
  W: array of Byte; // Work stack
  WB: Pointer; // Work stack Base (@W[0])
  WS: Integer; // Work stack Size
  BW: array of Pointer; // Counter Work stack
  BWB: Pointer;
  BWP: Pointer;
  BWS: Integer;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'E'}{$ENDIF}
  E: array of Byte; // Embro
  EB: Pointer; // Embro Base (@E[0])
  EC: Integer; // Embro Counter (E[EC])
  EL: Integer; // Embro Last compiled
  ES: Integer; // Embro Size (Length(E))
  Embro: array of Cardinal;
  EmbroB: Pointer;
  EmbroP: Integer;
  EmbroL: Integer;
  EmbroS: Integer;
  EmbroI: array of TEmbroItemInfo;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'R'}{$ENDIF}
  R: array of Byte; // Return stack
  RB: Pointer; // Return stack Base
  RP: Pointer; // Return stack Pointer
  RS: Integer; // Return stack Size
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'C'}{$ENDIF}
  C: array of PForthCommand; // Commands
  CB: Pointer; // Commands Base (@C[0])
  CC: Integer; // Commands Counter (C[CC] - last added command)
  CS: Integer; // Commands Size (Length(C))
  // Command REserve
  // Command FInd
  // Command EXecute
  // Command COmpile
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'LOCALS'}{$ENDIF}
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'D'}{$ENDIF}
 {D: array of Byte; // Data
  DB: Pointer; // Data Base
  DP: Pointer; // Data Pointer (traditionaly called HERE in forth)
  DS: Integer; // Data Size
  procedure DA(Size: Integer); // Data Allot}
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'S'}{$ENDIF}
  // doesn't work in run state
  S: PChar; // Source
  SC: Integer; // Source Counter
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'L'}{$ENDIF}
  L: array of Byte; // Local stack
  LB: Pointer; // Local stack Base (@W[0])
  LP: Pointer; // Local stack Pointer
  LS: Integer; // Local stack Size
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'V'}{$ENDIF}
  Context: array of PVoc;
  Target: array of PVoc;
  vGLOBAL: PVoc;
  vLOCAL: PVoc;
  vBUILTIN: PVoc;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'plugin datas'}{$ENDIF}
  Code: packed record
    Count: Cardinal;
    Chunks: Pointer;
  end;
  Chunks: array of packed record
                            Opcode: Cardinal;
                            Len: Cardinal;
                            Data: Pointer;
                            Count: Cardinal;
                            Refs: Pointer;
                          end;
  Refs: array of array of Cardinal;
  Commands: array of packed record
                       Name: PChar;
                       Flags: Integer;
                       Code: Integer;
                       Data: Integer;
                     end;
  FOutput: TString;
  FAppType: Integer;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'Strings'}{$ENDIF}
  // когда они создаются при интерпритации, нужно где-то хранить
  FPChars: array of array of TChar;

  TempS: TStr;
  FStrNil: TStr;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'exceptions'}{$ENDIF}
  Exceptions: array of Byte;
  ExceptionsB: Pointer;
  ExceptionsP: Pointer;
  ExceptionsS: Integer;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'system options'}{$ENDIF}
  nop: PForthCommand;
  ConvStr: PForthCommand;
  ConvName: PForthCommand;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
  UserData: Pointer;
  //C: array of TForthCommand;
  FData: array of Byte;
  //FHere: Integer;
  FCompilation: Boolean;
  FRunning: Boolean;
  FSource: PChar;
  FCurrentChar: Integer;
  //FPC: Cardinal;
  FCurrentName: TString;
  // FS_*
  State: Integer;
  FSession: Boolean;
  FLastMnemonic: Integer;
  FEmbroDump: array of TString;
  FEmbro: array of Byte;
  FTypes: array of TType;
  //FMemoryDebug: TDebug;
  FAlien: TAlien;
  FCurrentFileName: TString;
  FCurrentLine: Integer;
  FCurrentPos: Integer;
  Directories: array of TString;
  procedure CompileSource(Source: PChar);
  function CompileName(W: PChar): Boolean; overload;
  function NextMnemonic: Cardinal;
  procedure Run(Index: Integer);
  procedure RunMnemonic(M: Cardinal);
  procedure RunCommand(Command: PForthCommand);
  procedure RunError(const S: TString);
  procedure RunWarring(const S: TString);
  procedure IncHere(Count: Integer);
  procedure AddType(const Name: TString; Size: Integer);
  system_commands(, TInt);
  system_commands(int, TInt);
  system_commands(int8, TInt8);
  system_commands(int16, TInt16);
  system_commands(int32, TInt32);
  system_commands(int64, TInt64);
  system_commands(uint, TUInt);
  system_commands(uint8, TUInt8);
  system_commands(uint16, TUInt16);
  system_commands(uint32, TUInt32);
  system_commands(uint64, TUInt64);
  system_commands(float, Single);
  system_commands(double, Double);
  system_commands(extended, Extended);
  sysar_commands(, TInt);
  sysar_commands(int, TInt);
  sysar_commands(int8, TInt8);
  sysar_commands(int16, TInt16);
  sysar_commands(int32, TInt32);
  sysar_commands(int64, TInt64);
  sysar_commands(uint, TUInt);
  sysar_commands(uint8, TUInt8);
  sysar_commands(uint16, TUInt16);
  sysar_commands(uint32, TUInt32);
  sysar_commands(uint64, TUInt64);
{$IFNDEF FLAG_FPC}{$REGION 'machine datas'}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'E'}{$ENDIF}
  procedure EA(Size: Integer); // Embro Alloc
  function Here: Pointer; overload;
  procedure EWV(V: Pointer; Size: Integer); // Embro Write Var
  procedure EWI(V: Integer); // Embro Write Integer
  procedure EWE(V: TEmbroPtr);
  procedure EWO(V: TOpcode); overload;
  procedure EWO(V: TString); overload;
  procedure BuiltinEWO(V: TString); 
  procedure EWR(V: TOpcode); overload;
  procedure EWI8(V: TInt8);
  procedure EWI16(V: TInt16);
  procedure EWI32(V: TInt32);
  procedure EWI64(V: TInt64);
  procedure EWU(V: TUInt);
  procedure EWU8(V: TUInt8);
  procedure EWU16(V: TUInt16);
  procedure EWU32(V: TUInt32);
  procedure EWU64(V: TUInt64);
  procedure EWC(V: Char);
  procedure EWS(V: Single);
  procedure EWD(const V: Double);
  procedure EWExtended(const V: Extended);
  procedure EWPChar(V: PChar);
  procedure EWStr(V: TString);
  procedure ERV(V: Pointer; Size: Integer); // Embro Read Var
  function ERI: Integer; // Embro Read Integer
  function ERE: TEmbroPtr;
  function ERO: TOpcode;
  function ERI8: TInt8;
  function ERI16: TInt16;
  function ERI32: TInt32;
  function ERI64: TInt64;
  function ERU: TUInt;
  function ERU8: TUInt8;
  function ERU16: TUInt16;
  function ERU32: TUInt32;
  function ERU64: TUInt64;
  function ERC: Char;
  function ERS: Single;
  function ERD: Double;
  function ERExtended: Extended;
  function ERPChar: PChar;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'R'}{$ENDIF}
  procedure RUV(const P: Pointer; Size: Integer);
  procedure ROV(const P: Pointer; Size: Integer);
  pop_interface(ROP, Pointer, RP); // Return stack pOp Pointer
  push_interface(RUI, TInt, RP); // Return stack pUsh Integer
  push_interface(RUI8, TInt8, RP); 
  push_interface(RUI16, TInt16, RP);
  push_interface(RUI32, TInt32, RP);
  push_interface(RUI64, TInt64, RP);
  push_interface(RUU, TUInt, RP);
  push_interface(RUU8, TUInt8, RP); 
  push_interface(RUU16, TUInt16, RP);
  push_interface(RUU32, TUInt32, RP);
  push_interface(RUU64, TUInt64, RP);
  push_interface(RUP, Pointer, RP); // Return stack pUsh Pointer
  pop_interface(ROI, TInt, RP); // Return stack pOp Integer
  pop_interface(ROI8, TInt8, RP); 
  pop_interface(ROI16, TInt16, RP);
  pop_interface(ROI32, TInt32, RP);
  pop_interface(ROI64, TInt64, RP);
  pop_interface(ROU, TUInt, RP);
  pop_interface(ROU8, TUInt8, RP); 
  pop_interface(ROU16, TUInt16, RP);
  pop_interface(ROU32, TUInt32, RP);
  pop_interface(ROU64, TUInt64, RP);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'W'}{$ENDIF}
  push_interface(WUI, TInt, WP); // Work stack pUsh Integer
  push_interface(WUP, Pointer, WP); // Work stack pUsh Pointer
  pop_interface(WOI, TInt, WP); // Work stack pOp Integer
  pop_interface(WOP, Pointer, WP); // Work stack pOp Pointer
  push_interface(WUI8, TInt8, WP); 
  push_interface(WUI16, TInt16, WP);
  push_interface(WUI32, TInt32, WP);
  push_interface(WUI64, TInt64, WP);
  push_interface(WUU, TUInt, WP);
  push_interface(WUU8, TUInt8, WP); 
  push_interface(WUU16, TUInt16, WP);
  push_interface(WUU32, TUInt32, WP);
  push_interface(WUU64, TUInt64, WP);
  pop_interface(WOI8, TInt8, WP); 
  pop_interface(WOI16, TInt16, WP);
  pop_interface(WOI32, TInt32, WP);
  pop_interface(WOI64, TInt64, WP);
  pop_interface(WOU, TUInt, WP);
  pop_interface(WOU8, TUInt8, WP); 
  pop_interface(WOU16, TUInt16, WP);
  pop_interface(WOU32, TUInt32, WP);
  pop_interface(WOU64, TUInt64, WP);
  procedure WUV(const P: Pointer; Size: Integer);
  procedure WOV(const P: Pointer; Size: Integer);
  procedure WUS(const S: TString);
  function WOS: TString;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'B'}{$ENDIF}
  procedure BWU(C: Pointer); // Block Work pUsh
  function BWO: Pointer; // Block Work pOp
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'C'}{$ENDIF}
  // Command REserve
  // Command FInd
  // Command EXecute
  // Command COmpile
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'LOCALS'}{$ENDIF}
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'S'}{$ENDIF}
  // doesn't work in run state
  function SE: Boolean; // Source End
  function SNC: TChar; // Source Next Char
  function SNN: TString; // Source Next Name
  procedure SSS; // Source Skip Spaces
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'L'}{$ENDIF}
  procedure LUV(const P: Pointer; Size: Integer);
  procedure LOV(const P: Pointer; Size: Integer);
  push_interface(LUI, TInt, LP); // Work stack pUsh Integer
  push_interface(LUP, Pointer, LP); // Work stack pUsh Pointer
  pop_interface(LOI, TInt, LP); // Work stack pOp Integer
  pop_interface(LOP, Pointer, LP); // Work stack pOp Pointer
  push_interface(LUI8, TInt8, LP); 
  push_interface(LUI16, TInt16, LP);
  push_interface(LUI32, TInt32, LP);
  push_interface(LUI64, TInt64, LP);
  push_interface(LUU, TUInt, LP);
  push_interface(LUU8, TUInt8, LP); 
  push_interface(LUU16, TUInt16, LP);
  push_interface(LUU32, TUInt32, LP);
  push_interface(LUU64, TUInt64, LP);
  pop_interface(LOI8, TInt8, LP); 
  pop_interface(LOI16, TInt16, LP);
  pop_interface(LOI32, TInt32, LP);
  pop_interface(LOI64, TInt64, LP);
  pop_interface(LOU, TUInt, LP);
  pop_interface(LOU8, TUInt8, LP); 
  pop_interface(LOU16, TUInt16, LP);
  pop_interface(LOU32, TUInt32, LP);
  pop_interface(LOU64, TUInt64, LP);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'V'}{$ENDIF}
  function HighTarget: PVoc;
  procedure ContextPush(V: PVoc);
  function ContextPop: PVoc;
  procedure TargetPush(V: PVoc);
  function TargetPop: PVoc;
  procedure UseVoc(V: PVoc);
  procedure UnuseVoc;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
  constructor Create;
  destructor Destroy;
  procedure AddCommand(Name: PChar; Code: TCode; Immediate: Boolean = False;
                       Builtin: Boolean = True);
  procedure OnUpdateCommand(Opcode: Integer); overload;
  procedure OnUpdateCommand(Command: PForthCommand); overload;
  procedure AddToContext(Index: Integer);
  procedure UpdateContext;

  procedure InterpretName(W: PChar); overload;
  procedure Interpret(const Line: PChar); overload;
  procedure InterpretFile(const FileName: TString);
  procedure CallCommand(Command: PForthCommand);
  procedure MainLoop;
  procedure Step;
  procedure InterpretStep;
  procedure CompileStep;
  procedure RunStep;
  
  // команды времени компиляции
  procedure CompileError(const S: TString);
  procedure CompileWarring(const S: TString);
  procedure LogError(const S: TString);
  function NextChar: TChar;
  function NextName: TString; overload;
  function NextName(S: PChar; var I: Integer): TString; overload;
  function NextNamePassive: TString;
  function EOS: Boolean; // end of source
  procedure WriteEmbro(P: Pointer; Size: Integer);
  procedure WriteEmbroInt(I: Integer); overload;
  procedure WriteEmbroUInt(U: Cardinal); overload;
  procedure WriteEmbroChar(C: Char); overload;
  procedure WriteEmbroByte(B: Byte); overload;
  procedure PopEmbro(P: Pointer; Size: Integer);
  procedure WriteMnemonic(M: Cardinal);
  procedure WriteMnemonicByName(const Name: TString);
  function GetOpcodeByName(const Name: TString): TMnemonic;
  function GetCommandByOpcode(Opcode: Integer): PForthCommand;
  procedure CancelMnemonic;
  function ReserveName(const Name: TString): PForthCommand;
  
  procedure ReadEmbro(P: Pointer; Size: Integer);
  function ReadMnemonic: TMnemonic;

  function GetEmbroDumpLines: Integer;
  function GetEmbroDumpLine(Index: Integer): TString;
  function FindCommand(Voc: PVoc; const Name: TString; Index: PInteger = nil): PForthCommand; overload;
  function FindCommand(const Name: TString; Index: PInteger = nil): PForthCommand; overload;
  function ExtendedFindCommand(const Name: TString; Index: PInteger = nil): PForthCommand; overload;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'all commands'}{$ENDIF}
  typed_commands(ptr, 4);
  typed_commands(int, 4);
  typed_commands(int8, 1);
  typed_commands(int16, 2);
  typed_commands(int32, 4);
  typed_commands(int64, 8);
  typed_commands(uint, 4);
  typed_commands(uint8, 1);
  typed_commands(uint16, 2);
  typed_commands(uint32, 4);
  typed_commands(uint64, 8);
  typed_commands(embro, 4);
  typed_commands(float, 4);
  typed_commands(double, 8);
  typed_commands(extended, 10);
  arithmetic_commands(, TInt);
  arithmetic_commands(int, TInt);
  arithmetic_commands(int8, TInt8);
  arithmetic_commands(int16, TInt16);
  arithmetic_commands(int32, TInt32);
  arithmetic_commands(int64, TInt64);
  arithmetic_commands(uint, TUInt);
  arithmetic_commands(uint8, TUInt8);
  arithmetic_commands(uint16, TUInt16);
  arithmetic_commands(uint32, TUInt32);
  arithmetic_commands(uint64, TUInt64);
  arithmetic_commands(float, Single);
  arithmetic_commands(double, Double);
  arithmetic_commands(extended, Extended);
  signed_arithmetic_commands(, TInt);
  signed_arithmetic_commands(int, TInt);
  signed_arithmetic_commands(int8, TInt8);
  signed_arithmetic_commands(int16, TInt16);
  signed_arithmetic_commands(int32, TInt32);
  signed_arithmetic_commands(int64, TInt64);
  signed_arithmetic_commands(float, Single);
  signed_arithmetic_commands(double, Double);
  number_arithmetic_commands(, TInt);
  number_arithmetic_commands(int, TInt);
  number_arithmetic_commands(int8, TInt8);
  number_arithmetic_commands(int16, TInt16);
  number_arithmetic_commands(int32, TInt32);
  number_arithmetic_commands(int64, TInt64);
  number_arithmetic_commands(uint, TUInt);
  number_arithmetic_commands(uint8, TUInt8);
  number_arithmetic_commands(uint16, TUInt16);
  number_arithmetic_commands(uint32, TUInt32);
  number_arithmetic_commands(uint64, TUInt64);
  convert_number_arithmetic_commands(int,      TInt,     int8,     TInt8);
  convert_number_arithmetic_commands(int,      TInt,     int16,    TInt16);
  convert_number_arithmetic_commands(int,      TInt,     int32,    TInt32);
  convert_number_arithmetic_commands(int,      TInt,     int64,    TInt64);
  convert_number_arithmetic_commands(int8,     TInt8,    int,      TInt);
  convert_number_arithmetic_commands(int16,    TInt16,   int,      TInt);
  convert_number_arithmetic_commands(int32,    TInt32,   int,      TInt);
  convert_number_arithmetic_commands(int64,    TInt64,   int,      TInt);
  convert_number_arithmetic_commands(uint,     TUInt,    uint8,    TUInt8);
  convert_number_arithmetic_commands(uint,     TUInt,    uint16,   TUInt16);
  convert_number_arithmetic_commands(uint,     TUInt,    uint32,   TUInt32);
  convert_number_arithmetic_commands(uint,     TUInt,    uint64,   TUInt64);
  convert_number_arithmetic_commands(uint8,    TUInt8,   uint,     TUInt);
  convert_number_arithmetic_commands(uint16,   TUInt16,  uint,     TUInt);
  convert_number_arithmetic_commands(uint32,   TUInt32,  uint,     TUInt);
  convert_number_arithmetic_commands(uint64,   TUInt64,  uint,     TUInt);
  convert_number_arithmetic_commands(float,    Single,   double,   Double);
  convert_number_arithmetic_commands(double,   Double,   float,   Single);
  convert_number_arithmetic_commands(float,    Single,   extended, Extended);
  convert_number_arithmetic_commands(double,   Double,   extended, Extended);
  convert_number_arithmetic_commands(extended, Extended, double,   Double);
  convert_number_arithmetic_commands(extended, Extended, float,   Single);
  convert_number_arithmetic_commands(int,      TInt,     float,    Single);
  convert_number_arithmetic_commands(int,      TInt,     double,   Double);
  convert_number_arithmetic_commands(int,      TInt,     extended, Extended);
  exception_commands
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'misc commands'}{$ENDIF}
  procedure _nop(Machine: TForthMachine; Command: PForthCommand);
  procedure _builtedin(Machine: TForthMachine; Command: PForthCommand);
  procedure _builtin(Machine: TForthMachine; Command: PForthCommand);
  procedure CompileComment(Machine: TForthMachine; Command: PForthCommand);
  procedure CompileLineComment(Machine: TForthMachine; Command: PForthCommand);
  procedure _here(Machine: TForthMachine; Command: PForthCommand); overload;
  procedure _BtoW(Machine: TForthMachine; Command: PForthCommand);
  procedure _WtoB(Machine: TForthMachine; Command: PForthCommand);
  procedure Evaluate(Machine: TForthMachine; Command: PForthCommand);
  procedure EvaluateFile(Machine: TForthMachine; Command: PForthCommand);
  procedure _FIND_(Machine: TForthMachine; Command: PForthCommand);
  procedure _NOTFOUND_(Machine: TForthMachine; Command: PForthCommand);
  procedure _align(Machine: TForthMachine; Command: PForthCommand);
  procedure _palign(Machine: TForthMachine; Command: PForthCommand);
  procedure _poststr cmdhdr;
  procedure _postname cmdhdr;
  procedure _raw_2_unicode cmdhdr;
  procedure _utf8_2_unicode cmdhdr;
  procedure _utf8_2_raw cmdhdr;
  procedure _unicode_2_utf8 cmdhdr;
  procedure _unicode_2_raw cmdhdr;
  procedure _randomize cmdhdr;
  procedure _random cmdhdr;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TControlCommands'}{$ENDIF}
procedure branch(Machine: TForthMachine; Command: PForthCommand);
procedure _ask_branch(Machine: TForthMachine; Command: PForthCommand);
procedure _gt_mark(Machine: TForthMachine; Command: PForthCommand);
procedure _gt_resolve(Machine: TForthMachine; Command: PForthCommand);
procedure _lt_mark(Machine: TForthMachine; Command: PForthCommand);
procedure _lt_resolve(Machine: TForthMachine; Command: PForthCommand);
procedure _exit(Machine: TForthMachine; Command: PForthCommand);
procedure recurse(Machine: TForthMachine; Command: PForthCommand);
procedure call(Machine: TForthMachine; Command: PForthCommand);
procedure compile_def(Machine: TForthMachine; Command: PForthCommand);
procedure compile_noname(Machine: TForthMachine; Command: PForthCommand);
procedure compile_skip_to_end(Machine: TForthMachine; Command: PForthCommand);
procedure compile_enddef(Machine: TForthMachine; Command: PForthCommand);
procedure compile_scattered_def(Machine: TForthMachine; Command: PForthCommand);
procedure compile_scattered_enddef(Machine: TForthMachine; Command: PForthCommand); 
procedure scattered_dots(Machine: TForthMachine; Command: PForthCommand); 
procedure immediate(Machine: TForthMachine; Command: PForthCommand);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TEmbroCommands'}{$ENDIF}
procedure compile(Machine: TForthMachine; Command: PForthCommand);
procedure q_compile_q(Machine: TForthMachine; Command: PForthCommand);
procedure _call(Machine: TForthMachine; Command: PForthCommand);
procedure postpone(Machine: TForthMachine; Command: PForthCommand);
procedure _compiled(Machine: TForthMachine; Command: PForthCommand);
procedure _postponed(Machine: TForthMachine; Command: PForthCommand);
procedure _called(Machine: TForthMachine; Command: PForthCommand);
procedure _execute(Machine: TForthMachine; Command: PForthCommand);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TDataCommands'}{$ENDIF}
  procedure _nil(Machine: TForthMachine; Command: PForthCommand);
  procedure ptr_comma(Machine: TForthMachine; Command: PForthCommand);

  procedure _create(Machine: TForthMachine; Command: PForthCommand);
  procedure _created(Machine: TForthMachine; Command: PForthCommand);
  procedure putdataptr(Machine: TForthMachine; Command: PForthCommand);
  procedure here(Machine: TForthMachine; Command: PForthCommand);
  procedure allot(Machine: TForthMachine; Command: PForthCommand);

  procedure compile_to(Machine: TForthMachine; const Name: TString; Size: Integer);
  procedure interpete_to(Machine: TForthMachine; const Name: TString; Size: Integer);

  procedure to_int(Machine: TForthMachine; Command: PForthCommand);
  procedure to_int8(Machine: TForthMachine; Command: PForthCommand);
  procedure to_int16(Machine: TForthMachine; Command: PForthCommand);
  procedure to_int32(Machine: TForthMachine; Command: PForthCommand);
  procedure to_int64(Machine: TForthMachine; Command: PForthCommand);
  procedure to_uint(Machine: TForthMachine; Command: PForthCommand);
  procedure to_uint8(Machine: TForthMachine; Command: PForthCommand);
  procedure to_uint16(Machine: TForthMachine; Command: PForthCommand);
  procedure to_uint32(Machine: TForthMachine; Command: PForthCommand);
  procedure to_uint64(Machine: TForthMachine; Command: PForthCommand);
  procedure to_ptr(Machine: TForthMachine; Command: PForthCommand);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TTypeCommands'}{$ENDIF}
  procedure typeof(Machine: TForthMachine; Command: PForthCommand);
  procedure type_size(Machine: TForthMachine; Command: PForthCommand);
  procedure compile_type(Machine: TForthMachine; Name: PChar);
  procedure interpete_type(Machine: TForthMachine; Name: PChar);
  procedure run_type(Machine: TForthMachine; Command: PForthCommand);
  procedure _void(Machine: TForthMachine; Command: PForthCommand);
  procedure _int(Machine: TForthMachine; Command: PForthCommand);
  procedure _int8(Machine: TForthMachine; Command: PForthCommand);
  procedure _int16(Machine: TForthMachine; Command: PForthCommand);
  procedure _int32(Machine: TForthMachine; Command: PForthCommand);
  procedure _int64(Machine: TForthMachine; Command: PForthCommand);
  procedure _uint(Machine: TForthMachine; Command: PForthCommand);
  procedure _uint8(Machine: TForthMachine; Command: PForthCommand);
  procedure _uint16(Machine: TForthMachine; Command: PForthCommand);
  procedure _uint32(Machine: TForthMachine; Command: PForthCommand);
  procedure _uint64(Machine: TForthMachine; Command: PForthCommand);
  procedure _bool(Machine: TForthMachine; Command: PForthCommand);
  procedure _str(Machine: TForthMachine; Command: PForthCommand);
  procedure _pchar(Machine: TForthMachine; Command: PForthCommand);
  procedure _ptr(Machine: TForthMachine; Command: PForthCommand);
  procedure _type(Machine: TForthMachine; Command: PForthCommand);
  procedure _float(Machine: TForthMachine; Command: PForthCommand);
  procedure _double(Machine: TForthMachine; Command: PForthCommand);
  procedure _extended(Machine: TForthMachine; Command: PForthCommand);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}

function IsImmediate(Command: PForthCommand): Boolean;
procedure SetImmediate(Command: PForthCommand; I: Boolean);
function IsBuiltin(Command: PForthCommand): Boolean;
procedure SetBuiltin(Command: PForthCommand; I: Boolean);
function CopyStrToPChar(const B: TString): PChar;

implementation

uses
  DCommandsBool,
  DCommandsMisc,
  DCommandsConsole,
  DCommandsStrings,
  DCommandsAlien,
  DCommandsF,
  DCommandsBW,
  DCommandsCompile,
  DCommandsCreatewords,
  DCommandsFiles,
  DCommandsInt,
  DCommandsMem,
  DCommandsOS,
  DCommandsPtr,
  DCommandsR,
  DCommandsSource,
  DCommandsVM,
  DCommandsVoc,
  DCommandsExtInt,
  DCommandsEmbro;

function GetFileName(FullPath: TString): TString;
var
  I: Integer;
begin
  I := Length(FullPath);
  while I > 0 do
    if FullPath[I] = '\' then begin
      Delete(FullPath, 1, I);
      break;
    end else
      Dec(I);
  Result := FullPath;
end;

function GetDirectory(const FullPath: TString): TString;
var
  I: Integer;
begin
  Result := FullPath;
  I := Length(FullPath);
  while I > 0 do
    if Result[I] = '\' then begin
      Result := Copy(Result, 1, I);
      Exit
    end else
      Dec(I);
end;

function InternalFileName(const FullPath: TString): TString;
begin
  Result := GetFileName(FullPath);
  if Length(Result) > 2 then
    if Pos('.de', Result) = Length(Result) - 2 then
      Delete(Result, Length(Result) - 2, 3);
end;

function IsImmediate(Command: PForthCommand): Boolean;
begin
  Result := (Command^.Flags and 1) > 0;
end;

procedure SetImmediate(Command: PForthCommand; I: Boolean);
begin
  with Command^ do
    if I then
      Flags := Flags or 1
    else
      Flags := Flags and not 1
end;

function IsBuiltin(Command: PForthCommand): Boolean;
begin
  Result := (Command^.Flags and 2) > 0;
end;

procedure SetBuiltin(Command: PForthCommand; I: Boolean);
begin
  Command^.Flags := Command^.Flags or (Ord(I) shl 1);
  with Command^ do
    if I then
      Flags := Flags or 2
    else
      Flags := Flags and not 2
end;

function CopyStrToPChar(const B: TString): PChar;
begin
  Result := StrAlloc(Length(B) + 1);
  StrCopy(Result, PChar(B));
end;

{$IFNDEF FLAG_FPC}{$REGION 'TControlCommands'}{$ENDIF}
procedure branch;
begin
  with Machine^ do begin
    Machine.EC := Machine.ERU;
  end;
end;

procedure _ask_branch;
var
  B: TInt;
  Temp: Cardinal;
begin
  with Machine^ do begin
    B := Machine.WOI;
    Temp := Machine.ERU;
    if B = BOOL_FALSE then
      Machine.EC := Temp;
  end;
end;

procedure _gt_mark;
var
  Temp: Cardinal;
begin
  with Machine^ do begin
    Temp := Machine.EL;
    Machine.WUU(Temp);
    Machine.EWU(Temp);
  end;
end;

procedure _gt_resolve;
var
  Temp: Cardinal;
  PC: Cardinal;
begin
  with Machine^ do begin
    Temp := Machine.WOU;
    PC := Machine.EL;
    Move(PC, Pointer(@Machine.E[Temp])^, SizeOf(PC));
  end;
end;

procedure _lt_mark;
var
  Temp: Cardinal;
begin
  with Machine^ do begin
    Temp := Machine.EL;
    Machine.WUU(Temp);
  end;
end;

procedure _lt_resolve;
var
  Temp: Cardinal;
  PC: Cardinal;
begin
  with Machine^ do begin
    Temp := Machine.WOU;
    Machine.EWU(Temp);
  end;
end;

procedure _exit;
begin
  with Machine^ do begin
    // Log('EXIT');
    if TUInt(Machine.RB) < TUInt(Machine.RP) then begin
      Machine.EC := Machine.ROI;
    end else if TUInt(Machine.RB) = TUInt(Machine.RP) then begin
      //Machine.EC := Length(Machine.FEmbro)
      Machine.RB := Machine.ROP;
      // Machine.State := Machine.ROI;
      Machine.FRunning := False;
    end else begin
      Machine.LogError('[exit] R stack error (' +
                         IntToStr(TUInt(Machine.RP) - TUInt(Machine.RB)) + ')');
      Machine.FSession := False;
    end;
    Machine.LP := Machine.LB;
    Machine.LB := Machine.ROP;
  end;
end;

procedure recurse(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    Machine.EWO(Machine.FLastMnemonic);
  end;
end;

procedure call(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    // Writeln('INSIDE CALL "' + Command^.Name + '"');
    //Writeln('called function ' + Command^.Name);
    Machine.RUP(Machine.LB);
    Machine.LB := Machine.LP;
    if Machine.FRunning then
      Machine.RUI(Machine.EC)
    else begin
      // Machine.RUI(Machine.State);
      Machine.RUP(Machine.RB);
      Machine.RB := Machine.RP;
    end;
    Machine.EC := Integer(Command^.Data);
    Machine.FRunning := True;
    // Writeln('WP = ', Cardinal(Machine.WP));
  end;
end;

procedure compile_def(Machine: TForthMachine; Command: PForthCommand);
var
  Name: TString;
  NewCommand: PForthCommand;
  PName: PChar;
begin
  with Machine^ do begin
    Name := Machine.NextName;
    PName := CopyStrToPChar(Name);
    NewCommand := Machine.ReserveName('');
    NewCommand^.Code := call;
    SetImmediate(NewCommand, False);
    Integer(NewCommand^.Data) := Machine.EL;
    Machine.State := FS_COMPILE;
    Machine.LUI(Machine.FLastMnemonic);
    Machine.LUP(PName);
    Machine.LUI(101);
  end;
end;

procedure compile_noname(Machine: TForthMachine; Command: PForthCommand);
var
  NewCommand: PForthCommand;
begin
  with Machine^ do begin
    NewCommand := Machine.ReserveName('');
    NewCommand^.Code := call;
    SetImmediate(NewCommand, False);
    Integer(NewCommand^.Data) := Machine.EL;
    Machine.State := FS_COMPILE;
    Machine.WUP(NewCommand);
    Machine.LUI(Machine.FLastMnemonic);
    Machine.LUP(Pointer(PChar('')));
    Machine.LUI(101);
  end;
end;

procedure compile_skip_to_end(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Integer(Machine.LP^) <> 101 then begin
      Machine.LogError('Нельзя использовать skip-to; внутри конструкций (на вершине стека не colon-id)');
      Exit;
    end;
    _gt_mark(Machine, nil);
    Machine.LUI(201);
  end;
end;

procedure compile_enddef(Machine: TForthMachine; Command: PForthCommand);
var
  B: TString;
  Index: TInt;
  P: PChar;
  ID: Integer;
begin
  with Machine^ do begin
    //B := str_pop(Machine);
    //Machine.C[Machine.WOI]^.Name := PChar(TString(PChar(@TStrRec(B^).Sym[0])));
    //DelRef(B);
    ID := Machine.LOI;
    if ID = 201 then begin
      _gt_resolve(Machine, nil);
    end;
    P := Machine.LOP;
    Index := Machine.LOI;
    Machine.C[Index]^.Name := P;
    Machine.BuiltinEWO('exit');
    Machine.State := FS_INTERPRET;
    Machine.C[Index]^.Flags := Machine.C[Index]^.Flags and not 1;
    Machine.OnUpdateCommand(Index);
    Machine.FLastMnemonic := Index;
    //Writeln('LAST COMMAND ', High(Machine.C), ' ' + Machine.C[High(Machine.C)].Name);
  end;
end;

procedure compile_scattered_def(Machine: TForthMachine; Command: PForthCommand);
var
  Name: TString;
  C: PForthCommand;
begin
 // with Machine^ do begin
    Machine.State := FS_COMPILE;
    Name := Machine.NextName;
    C := Machine.FindCommand(Name);
    if C = nil then begin
      Machine.LogError('Command not found: ' + Name);
      Exit;
    end;
    Machine.WUU(Cardinal((@Machine.E[Cardinal(C^.Param)])^));
    Cardinal((@Machine.E[Cardinal(C^.Param)])^) := Machine.EL;
    Machine.WUP(C);
 // end;
end;

procedure compile_scattered_enddef(Machine: TForthMachine; Command: PForthCommand);
var
  C: PForthCommand;
  P: Cardinal;
begin
 // with Machine^ do begin
    C := Machine.WOP;
    P := Cardinal(C^.Param);
    Machine.BuiltinEWO('branch');
    Cardinal(C^.Param) := Machine.EL;
    Machine.EWU(Machine.WOU);
    Machine.State := FS_INTERPRET;
 // end;
end;

procedure scattered_dots(Machine: TForthMachine; Command: PForthCommand); 
begin
  with Machine^ do begin
    Machine.BuiltinEWO('branch');
    Cardinal(Machine.C[Machine.FLastMnemonic]^.Param) := Machine.EL;
    Machine.EWU(Machine.EL + SizeOf(TUInt));
  end;
end;

procedure immediate(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    SetImmediate(Machine.C[Machine.FLastMnemonic], True);
  end;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TEmbroCommands'}{$ENDIF}
procedure compile(Machine: TForthMachine; Command: PForthCommand);
var
  U: TUInt;
begin
  with Machine^ do begin
    //if Machine.State = FS_COMPILE then begin
      Machine.BuiltinEWO('(compile)');
      Machine.EWO(Machine.NextName);
    //end else begin
    //  Machine.EWO(Machine.C[Machine.ERU].Name);
    //end;
  end;
end;

procedure q_compile_q(Machine: TForthMachine; Command: PForthCommand);
var
  O: TOpcode;
begin
  with Machine^ do begin
    O := Machine.ERU;
    Machine.EWO(Machine.C[O].Name);
  end;
end;

procedure _call(Machine: TForthMachine; Command: PForthCommand);
begin
  Machine.EWO(Machine.NextName);
end;

procedure postpone(Machine: TForthMachine; Command: PForthCommand);
var
  C: PForthCommand;
  Opcode: TOpcode;
begin
  C := Machine.FindCommand(Machine.NextName, @Opcode);
  // Writeln(C^.Name);
  if not IsImmediate(C) then
    Machine.BuiltinEWO('(compile)');
  Machine.EWO(Opcode)
end;

procedure _compiled(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    //if Machine.State = FS_COMPILE then begin
      Machine.BuiltinEWO('(compile)');
      Machine.EWO(Machine.WOS);
    //end else begin
    //  Machine.EWO(Machine.C[Machine.ERU].Name);
    //end;
  end;
end;

procedure _postponed(Machine: TForthMachine; Command: PForthCommand);
var
  C: PForthCommand;
  Opcode: TOpcode;
begin
  C := Machine.FindCommand(Machine.WOS, @Opcode);
  // Writeln(C^.Name);
  if not IsImmediate(C) then
    Machine.BuiltinEWO('(compile)');
  Machine.EWO(Opcode)
end;

procedure _called(Machine: TForthMachine; Command: PForthCommand);
begin
  Machine.EWO(Machine.WOS);
end;

procedure _execute(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    Machine.InterpretName(PChar(Machine.NextName));
  end;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TDataCommands'}{$ENDIF}
procedure _create(Machine: TForthMachine; Command: PForthCommand);
var
  Name: TString;
  NewCommand: PForthCommand;
begin
  with Machine^ do begin
    Name := Machine.NextName;
    NewCommand := Machine.ReserveName(Name);
    NewCommand^.Code := putdataptr;
    NewCommand^.Data := Machine.Here;
    Machine.OnUpdateCommand(NewCommand);
  end;
end;

procedure _created(Machine: TForthMachine; Command: PForthCommand);
var
  Name: TString;
  NewCommand: PForthCommand;
begin
  with Machine^ do begin
    Name := Machine.WOS;
    NewCommand := Machine.ReserveName(Name);
    NewCommand^.Code := putdataptr;
    NewCommand^.Data := Machine.Here;
    Machine.OnUpdateCommand(NewCommand);
  end;
end;

procedure putdataptr(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  with Machine^ do begin
    P := Command^.Data;
    Machine.WUP(P);
  end;
end;

procedure here(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  with Machine^ do begin
    // FIXME: P не постоянен
    P := Machine.Here;
    Machine.WUP(P);
  end;
end;

procedure allot(Machine: TForthMachine; Command: PForthCommand);
var
  I: Integer;
begin
  with Machine^ do begin
    I := Machine.WOI;
    Machine.IncHere(I);
  end;
end;

procedure to_int(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TInt))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TInt));
  end;
end;

procedure to_int8(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TInt8))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TInt8));
  end;
end;

procedure to_int16(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TInt16))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TInt16));
  end;
end;

procedure to_int32(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TInt32))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TInt32));
  end;
end;

procedure to_int64(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TInt64))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TInt64));
  end;
end;

procedure to_uint(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TUInt))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TUInt));
  end;
end;

procedure to_uint8(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TUInt8))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TUInt8));
  end;
end;

procedure to_uint16(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TUInt16))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TUInt16));
  end;
end;

procedure to_uint32(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TUInt32))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TUInt32));
  end;
end;

procedure to_uint64(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(TUint64))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(TUint64));
  end;
end;

procedure to_ptr(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_to(Machine, Machine.NextName, SizeOf(Pointer))
    else
      interpete_to(Machine, Machine.NextName, SizeOf(Pointer));
  end;
end;

procedure compile_to;
begin
  with Machine^ do begin
    case Size of
      1: Machine.WriteMnemonicByName(' 8to');
      2: Machine.WriteMnemonicByName(' 16to');
      4: Machine.WriteMnemonicByName(' 32to');
      8: Machine.WriteMnemonicByName(' 64to');
    else
      Machine.WriteMnemonicByName(' to');
      Machine.WriteEmbroByte(Size);
    end;
    Machine.WriteMnemonicByName(Name);
  end;
end;

procedure interpete_to;
var
  C: PForthCommand;
  Temp: array of Byte;
begin
 // with Machine^ do begin
    C := Machine.FindCommand(Name);
    if C = nil then begin
      Machine.LogError('cannot find command ' + Name);
      Exit;
    end;
    SetLength(Temp, Size);
    // FIXME
    //Machine.(@Temp[0], Size);
    Move(Temp[0], C^.Data^, Size);
 // end;
end;

procedure _nil(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  with Machine^ do begin
    P := nil;
    Machine.WUP(nil);
  end;
end;

procedure ptr_comma(Machine: TForthMachine; Command: PForthCommand);
var
  P: Pointer;
begin
  with Machine^ do begin
    P := Machine.WOP;
    Move(P, Machine.Here^, SizeOf(Pointer));
    Machine.IncHere(SizeOf(Pointer)); 
  end;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TTypeCommands'}{$ENDIF}
procedure typeof(machine: tforthmachine; command: pforthcommand);
var
  Name: TString;
  I: Integer;
  P: PType;
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, PChar(Machine.NextName))
    else begin
      Name := Machine.NextName;
      for I := 0 to High(Machine.FTypes) do
        if TString(Machine.FTypes[I].Name) = Name then begin
          P := @Machine.FTypes[I];
          Machine.WUP(P);
          Exit;
        end;
      Machine.LogError('cannot find type "' + Name + '"');
    end;
  end;
end;

procedure type_size(Machine: TForthMachine; Command: PForthCommand);
var
  P: PType;
begin
  with Machine^ do begin
    P := Machine.WOP;
    Machine.WUI(P^.Size);
  end;
end;

procedure compile_type(Machine: TForthMachine; Name: PChar);
var
  I: Integer;
  P: PType;
begin
  with Machine^ do begin
    for I := 0 to High(Machine.FTypes) do
      if TString(Machine.FTypes[I].Name) = TString(Name) then begin
        Machine.BuiltinEWO('(typeof)');
        Machine.EWI(I);
        Exit;
      end;
    Machine.LogError('cannot find type "' + Name + '"');
  end;
end;

procedure interpete_type(Machine: TForthMachine; Name: PChar);
var
  I: Integer;
  P: PType;
begin
  with Machine^ do begin
    for I := 0 to High(Machine.FTypes) do
      if TString(Machine.FTypes[I].Name) = TString(Name) then begin
        Machine.WUP(@Machine.FTypes[I]);
        Exit;
      end;
    Machine.LogError('cannot find type "' + Name + '"');
  end;
end;

procedure run_type;
var
  I: TInt;
  P: PType;
begin
  with Machine^ do begin
    I := Machine.ERI;
    P := @Machine.FTypes[I];
    Machine.WUP(P);
  end;
end;

procedure _void(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'void')
    else
      interpete_type(Machine, 'void');
  end;
end;

procedure _int(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'int')
    else
      interpete_type(Machine, 'int');
  end;
end;

procedure _int8(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'int8')
    else
      interpete_type(Machine, 'int8');
  end;
end;

procedure _int16(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'int16')
    else
      interpete_type(Machine, 'int16');
  end;
end;

procedure _int32(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'int32')
    else
      interpete_type(Machine, 'int32');
  end;
end;

procedure _int64(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'int64')
    else
      interpete_type(Machine, 'int64');
  end;
end;

procedure _uint(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'uint')
    else
      interpete_type(Machine, 'uint');
  end;
end;

procedure _uint8(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'uint8')
    else
      interpete_type(Machine, 'uint8');
  end;
end;

procedure _uint16(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'uint16')
    else
      interpete_type(Machine, 'uint16');
  end;
end;

procedure _uint32(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'uint32')
    else
      interpete_type(Machine, 'uint32');
  end;
end;

procedure _uint64(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'uint64')
    else
      interpete_type(Machine, 'uint64');
  end;
end;

procedure _bool(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'bool')
    else
      interpete_type(Machine, 'bool');
  end;
end;

procedure _str(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'str')
    else
      interpete_type(Machine, 'str');
  end;
end;

procedure _pchar(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'pchar')
    else
      interpete_type(Machine, 'pchar');
  end;
end;

procedure _ptr(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'ptr')
    else
      interpete_type(Machine, 'ptr');
  end;
end;

procedure _type(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'type')
    else
      interpete_type(Machine, 'type');
  end;
end;

procedure _float(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'float')
    else
      interpete_type(Machine, 'float');
  end;
end;

procedure _double(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'double')
    else
      interpete_type(Machine, 'double');
  end;
end;

procedure _extended(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    if Machine.State = FS_COMPILE then
      compile_type(Machine, 'extended')
    else
      interpete_type(Machine, 'extended');
  end;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'TForthMachine'}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'folded'}{$ENDIF}
procedure OForthMachine.AddCommand(Name: PChar; Code: TCode; Immediate: Boolean = False; Builtin: Boolean = True);
begin
  SetLength(C, Length(C) + 1);
  New(C[High(C)]);
  C[High(C)].Name := StrAlloc(StrLen(Name)+1);
  StrCopy(C[High(C)].Name, Name);
  C[High(C)].Code := Code;
  SetImmediate(C[High(C)], Immediate);
  SetBuiltin(C[High(C)], Builtin);
  OnUpdateCommand(High(C));
  FLastMnemonic := High(C);
end;

procedure OForthMachine.OnUpdateCommand(Opcode: Integer);
begin
  VocAdd(HighTarget, Opcode);
  // Writeln('Add command ', C[Opcode]^.Name);
  if TString(C[Opcode]^.Name) = '_FIND_' then
    HighTarget.sFIND := Opcode
  else if TString(C[Opcode]^.Name) = '_NOTFOUND_' then
    HighTarget.sNOTFOUND := Opcode;
  FLastMnemonic := Opcode;
end;

procedure OForthMachine.OnUpdateCommand(Command: PForthCommand);
var
  I: Integer;
begin
  for I := High(C) downto 0 do
    if C[I] = Command then begin
      OnUpdateCommand(I);
      Exit;
    end;
end;

procedure OForthMachine.AddToContext(Index: Integer);
begin
  if Context[High(Context)] = nil then begin
    LogError('[OForthMachine.AddToContext] Incorrect context stack');
    Exit;
  end;
  VocAdd(Context[High(Context)], Index);
end;

procedure OForthMachine.UpdateContext;
var
  I: PVocItem;
begin
  if Context[High(Context)] = nil then begin
    LogError('[OForthMachine.UpdateContext] Incorrect context stack');
    Exit;
  end;
  I := Context[High(Context)].Item;
  while I <> nil do
    if TString(C[I^.Index].Name) = '_NOTFOUND_' then begin
      Context[High(Context)].sNOTFOUND := I^.Index;
      Break;
    end else
      I := I^.Next;
  while I <> nil do
    if TString(C[I^.Index].Name) = '_FIND_' then begin
      Context[High(Context)].sFIND := I^.Index;
      Break;
    end else
      I := I^.Next;
end;

procedure OForthMachine.CompileSource(Source: PChar);
var
  I: Integer;
begin
  FSource := Source;
  FCompilation := True;
  State := FS_COMPILE;
  FCurrentChar := 0;
  while (not EOS) and FCompilation do begin
    FCurrentName := NextName;
    if FCurrentName = '' then
      Break;
    EWO(FCurrentName);
    CompileName(@FCurrentName[1]);
  end;
  //for I := 0 to High(FEmbro) do
  //  Write(IntToHex(FEmbro[I], 2), ' ');
  //Writeln;
  FCompilation := False;
end;

procedure _nop(Machine: TForthMachine; Command: PForthCommand);
begin
end;

procedure _builtedin(Machine: TForthMachine; Command: PForthCommand);
var
  S: TString;
  NewName: PAnsiChar;
  V: PVocItem;
begin
  NewName := PAnsiChar(Machine.WOS);
  S := TString(Machine.WOS);
  V := Machine.vBUILTIN.Item;
  while V <> nil do begin
    if TString(Machine.C[V^.Index].Name) = S then begin
      with Machine^ do
        AddCommand(NewName, C[V^.Index].Code, IsImmediate(C[V^.Index]));
      Exit;
    end;
    V := V^.Next;
  end;
  Machine.LogError('not found command "' + S + '"');
end;

procedure _builtin(Machine: TForthMachine; Command: PForthCommand);
begin
  source_next_name(Machine, Command);
  source_next_name(Machine, Command);
  _builtedin(Machine, Command);
end;

procedure CompileComment(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    {( это для m4}
    while Machine.NextChar <> ')' do
      if Machine.EOS then begin
        {( это для m4 }CompileError('need ")", but end of source found');
        Break;
      end;
  end;
end;

procedure CompileLineComment(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    while Machine.NextChar <> #13 do
      if Machine.EOS then
        Break;
  end;
end;

function OForthMachine.NextMnemonic: Cardinal;
begin
  Result := Cardinal((@FEmbro[EC])^);
  Inc(EC, SizeOf(Cardinal));
end;

procedure OForthMachine.Run(Index: Integer);
var
  M: Cardinal;
  SavedState: Integer;
begin
  // Writeln('Deprecated code');
  LogError('Deprecated code');
  // Halt(-1);
end;

procedure OForthMachine.RunMnemonic(M: Cardinal);
begin
  //Writeln('RUN MNEMONIC "' + C[M].Name + '" ' + IntToStr(M) + ' EC:' + IntToStr(EC));
  // Writeln('RUN STEP "', C[M].Name, '"');
  if M = Cardinal(-1) then begin
    LogError('trying to run command with opcode -1');
    Exit;
  end;
  // Writeln(C[M].Name);
  C[M].Code(@Self, C[M]);
end;

procedure OForthMachine.RunCommand(Command: PForthCommand);
begin
  Command^.Code(@Self, Command);
end;

procedure OForthMachine.RunError(const S: TString);
begin
  Error('Runtime(' + InternalFileName(FCurrentFileName) + ', ' +
                     IntToStr(FCurrentLine) + ', ' +
                     IntToStr(FCurrentPos) + '): ' + S);
  // FRunning := False;
end;

procedure OForthMachine.RunWarring(const S: TString);
begin
  Warrning('Runtime warring: ' + S);
end;

procedure OForthMachine.IncHere(Count: Integer);
begin
  //Inc(Here, Count);
  EA(Count);
  //if Length(FData) - FHere < 1024 then
  //  SetLength(FData, Length(FData) + 1024);
end;

procedure OForthMachine.AddType(const Name: TString; Size: Integer);
var
  Command: PForthCommand;
begin
  SetLength(FTypes, Length(FTypes) + 1);
  FTypes[High(FTypes)].Name := PChar(Name);
  FTypes[High(FTypes)].Size := Size;

  Command := ReserveName(Name);
  SetImmediate(Command, True);
  SetBuiltin(Command, True);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'E'}{$ENDIF}
procedure OForthMachine.EA(Size: Integer); // Embro Alloc
begin
  Inc(EL, Size);
end;

function OForthMachine.Here: Pointer;
begin
  Result := @E[EL];
end;

procedure _here(Machine: TForthMachine; Command: PForthCommand);
begin
  with Machine^ do begin
    Pointer(WP^) := @E[EL];
    Inc(WP, SizeOf(Pointer));
  end;
end;

procedure OForthMachine.EWV(V: Pointer; Size: Integer); // Embro Write Data
begin
  Move(V^, (@E[EL])^, Size);
  Inc(EL, Size);

  Inc(Chunks[High(Chunks)].Len, Size);
end;

procedure OForthMachine.EWI(V: Integer);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' ' + IntToStr(V) + ' ';
end;

procedure OForthMachine.EWE(V: TEmbroPtr);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' embro:' + IntToStr(V) + ' ';
end;

procedure OForthMachine.EWO(V: TOpcode);
begin
  Move(V, (@E[EL])^, SizeOf(V));
  Inc(EL, SizeOf(V));

  SetLength(FEmbroDump, Length(FEmbroDump) + 1);
  FEmbroDump[High(FEmbroDump)] := C[V].Name + ' ';

  SetLength(Chunks, Length(Chunks) + 1);
  Chunks[High(Chunks)].Opcode := V;
  Chunks[High(Chunks)].Data := @E[EL];
  Chunks[High(Chunks)].Len := 0;
  Chunks[High(Chunks)].Count := 0;
  Chunks[High(Chunks)].Refs := nil;
  SetLength(Refs, Length(Refs) + 1);
  //Writeln('WRITE OPCODE: ' + IntToStr(V));
end;

procedure OForthMachine.EWO(V: TString);
var
  I: TOpcode;
begin
  (* for I := High(C) downto 0 do *)
  (*   if TString(C[I].Name) = V then begin *)
  (*     EWO(I); *)
  (*     Exit; *)
  (*   end; *)
  if FindCommand(V, @I) <> nil then begin
    EWO(I);
    Exit;
  end;
  FSession := False;
  LogError('command "' + V + '" not found');
end;

procedure OForthMachine.BuiltinEWO(V: TString); 
var
  I: TOpcode;
begin
  if FindCommand(vBUILTIN, V, @I) <> nil then begin
    EWO(I);
    Exit;
  end;
  FSession := False;
  LogError('builtin command "' + V + '" not found');
end;

procedure OForthMachine.EWR(V: TOpcode);
begin
  // TODO
end;

procedure OForthMachine.EWI8(V: TInt8);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' int8:' + IntToStr(V) + ' ';
end;

procedure OForthMachine.EWI16(V: TInt16);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' int16:' + IntToStr(V) + ' ';
end;

procedure OForthMachine.EWI32(V: TInt32);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' int32:' + IntToStr(V) + ' ';
end;

procedure OForthMachine.EWI64(V: TInt64);
begin
  EWV(@V, SizeOf(V));
  
  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' int64:' + IntToStr(V) + ' ';
end;

procedure OForthMachine.EWU(V: TUInt);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' u' + IntToStr(V) + ' ';
end;

procedure OForthMachine.EWU8(V: TUInt8);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' uint8:' + IntToStr(V) + ' ';
end;

procedure OForthMachine.EWU16(V: TUInt16);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' uint16:' + IntToStr(V) + ' ';
end;

procedure OForthMachine.EWU32(V: TUInt32);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' uint32:' + IntToStr(V) + ' ';
end;

procedure OForthMachine.EWU64(V: TUInt64);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' uint64:' + IntToStr(V) + ' ';
end;

procedure OForthMachine.EWC(V: Char);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + V;
end;

procedure OForthMachine.EWS(V: Single);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' s' + FloatToStr(V) + ' ';
end;

procedure OForthMachine.EWD(const V: Double);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' d' + FloatToStr(V) + ' ';
end;

procedure OForthMachine.EWExtended(const V: Extended);
begin
  EWV(@V, SizeOf(V));

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' e' + FloatToStr(V) + ' ';
end;

procedure OForthMachine.EWPChar(V: PChar);
begin
  // TODO
end;

procedure OForthMachine.EWStr(V: TString);
var
  B: TStr;
begin
  B := CreateStr(V);
  PStrRec(B)^.Ref := 1;
  EWV(B, SizeOf(Integer)*3 + PStrRec(B)^.Len + 1);

  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' "' + V + '" ';
end;

procedure OForthMachine.ERV(V: Pointer; Size: Integer);
begin
  Move((@E[EC])^, V^, Size);
  Inc(EC, Size);
end;

function OForthMachine.ERI: Integer;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERE: TEmbroPtr;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERO: TOpcode;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERI8: TInt8;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERI16: TInt16;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERI32: TInt32;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERI64: TInt64;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERU: TUInt;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERU8: TUInt8;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERU16: TUInt16;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERU32: TUInt32;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERU64: TUInt64;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERC: Char;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERS: Single;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERD: Double;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERExtended: Extended;
begin
  ERV(@Result, SizeOf(Result));
end;

function OForthMachine.ERPChar: PChar;
begin
  // TODO
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'D'}{$ENDIF}
{procedure OForthMachine.DA(Size: Integer);
begin
  Inc(Here, Size);
end;}
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'S'}{$ENDIF}
function OForthMachine.SE: Boolean;
begin
  Result := S[SC] = #0;
end;

function OForthMachine.SNC: TChar;
begin
  Result := S[SC];
  if not SE then begin
    Inc(SC);
    if Result = EOL then begin
      Inc(FCurrentLine);
      FCurrentPos := 1
    end else
      Inc(FCurrentPos);
  end;
end;

function OForthMachine.SNN: TString;
var
  Ch: TChar;
begin
  Result := '';
  repeat
    Ch := SNC;
  until (not (Ch in [#0..#32])) or SE;
  repeat
    Result := Result + Ch;
    if SE then
      Exit;
    Ch := SNC;
  until (Ch in [#0..#32]) or SE;
  if not (Ch in [#0..#32]) then
    Result := Result + Ch;
end;

procedure OForthMachine.SSS;
begin
  while (not SE) and (S[SC] in [#1..#32]) do
    SNC;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'R'}{$ENDIF}
procedure OForthMachine.RUV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(P^, RP^, Size);
  Inc(RP, Size);
end;

procedure OForthMachine.ROV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(RP^, P^, Size);
  Dec(RP, Size);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'W'}{$ENDIF}
procedure OForthMachine.BWU;
begin
  Pointer(BWP^) := C;
  Inc(BWP, SizeOf(Pointer));
end;

function OForthMachine.BWO;
begin
  Dec(BWP, SizeOf(Pointer));
  Result := Pointer(BWP^);
end;

procedure _BtoW(Machine: TForthMachine; Command: PForthCommand);
begin
  Machine.WUP(Machine.BWO);
end;

procedure _WtoB(Machine: TForthMachine; Command: PForthCommand);
begin
  Machine.BWU(Machine.WOP);
end;

procedure OForthMachine.WUV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(P^, WP^, Size);
  Inc(WP, Size);
end;

procedure OForthMachine.WOV(const P: Pointer; Size: Integer);
begin
  Dec(WP, Size);
  if P <> nil then
    Move(WP^, P^, Size);
end;

procedure OForthMachine.WUS(const S: TString);
begin
  str_push(@Self, S);
end;

function OForthMachine.WOS: TString;
var
  S_: PStrRec;
begin
  S_ := str_pop(@Self);
  Result := StrToString(S_);
  DelRef(S_);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'L'}{$ENDIF}
procedure OForthMachine.LUV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(P^, LP^, Size);
  Inc(LP, Size);
end;

procedure OForthMachine.LOV(const P: Pointer; Size: Integer);
begin
  if P <> nil then
    Move(LP^, P^, Size);
  Dec(LP, Size);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'L'}{$ENDIF}
function OForthMachine.HighTarget: PVoc;
var
  I: Integer;
begin
  I := High(Target);
  while (I > 0) and (Target[I] = nil) do
    Dec(I);
  Result := Target[I];
end;

procedure OForthMachine.ContextPush(V: PVoc);
begin
  SetLength(Context, Length(Context) + 1);
  Context[High(Context)] := V;
end;

function OForthMachine.ContextPop: PVoc;
begin
  if Length(Context) = 0 then
    Exit;
  Result := Context[High(Context)];
  if Length(Context) = 1 then begin
    LogError('trying to pop root context vocabulary');
    Exit;
  end;
  SetLength(Context, Length(Context) - 1);
end;

procedure OForthMachine.TargetPush(V: PVoc);
begin
  SetLength(Target, Length(Target) + 1);
  Target[High(Target)] := V;
end;

function OForthMachine.TargetPop: PVoc;
begin
  if Length(Target) = 0 then
    Exit;
  Result := Target[High(Target)];
  if Length(Target) = 1 then begin
    LogError('trying to pop root target vocabulary');
    Exit;
  end;
  SetLength(Target, Length(Target) - 1);
end;

procedure OForthMachine.UseVoc(V: PVoc);
begin
  TargetPush(V);
  ContextPush(V);
end;

procedure OForthMachine.UnuseVoc;
begin
  TargetPop;
  ContextPop;
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}

constructor OForthMachine.Create;
begin
  GetMem(FStrNil, 3*SizeOf(TInt) + 1);
  PStrRec(FStrNil)^.Ref := 1;
  PStrRec(FStrNil)^.Len := 0;
  PStrRec(FStrNil)^.Width := 1;
  PStrRec(FStrNil)^.Sym[0] := 0;

  SetLength(E, 1024 * 1024);
  EB := @E[0];
  EC := 0;
  EL := 0;
  ES := Length(E);
  SetLength(R,   16 * 1024);
  RB := @R[0];
  RP := RB;
  RS := Length(R);
  SetLength(W,   16 * 1024);
  WB := @W[0];
  WP := WB;
  WS := Length(W);
  SetLength(BW,  4 * 1024);
  BWB := @BW[0];
  BWP := BWB;
  BWS := Length(BW);
  SetLength(C,   0);
  CB := @C[0];
  CC := 0;
  CS := Length(C);
  {SetLength(D, 1024 * 1024);
  DB := @D[0];
  Here := DB;
  DS := Length(D);}
  SetLength(L, 1024 * 1024);
  LB := @L[0];
  LP := LB;
  LS := Length(L);
  S  := nil;
  SC := 0;
  UserData := nil;
  State := FS_INTERPRET;
  SetLength(FData, 2048);
  //FHere := 0;
  //FMemoryDebug := TDebug.Create('memory.tmp');
  //FMemoryDebug.Console := False;

  FAlien := TAlien.Create;

  new(vGLOBAL);
  new(vLOCAL);
  new(vBUILTIN);
  vGLOBAL^.Item := nil;
  vLOCAL^.Item := nil;
  vBUILTIN^.Item := nil;
  vGLOBAL^.sFIND := -1;
  vGLOBAL^.sNOTFOUND := -1;
  vLOCAL^.sFIND := -1;
  vLOCAL^.sNOTFOUND := -1;
  vBUILTIN^.sFIND := -1;
  vBUILTIN^.sNOTFOUND := -1;
  UseVoc(vGLOBAL);
  ContextPush(vLOCAL);
  // it must have zero opcode
  AddCommand('exit', _exit);
  AddCommand('_FIND_', _FIND_);
  AddCommand('(', CompileComment, True); {) для m4}
  AddCommand('//', CompileLineComment, True);
  AddCommand('builtin', _builtin);
  AddCommand('builtedin', _builtedin);

  UseVoc(vBUILTIN);
  AddCommand('nop', _nop);
  nop := C[High(C)];

  ConvStr := nop;
  ConvName := nop;

  AddCommand('exit', _exit);
  AddCommand('_FIND_', _FIND_);
  AddCommand('(', CompileComment, True); {) для m4}
  AddCommand('//', CompileLineComment, True);
  AddCommand('builtin', _builtin);
  AddCommand('builtedin', _builtedin);
  AddCommand('_NOTFOUND_', _NOTFOUND_);
  AddCommand('align', _align);
  AddCommand('palign', _palign);
  AddCommand('*poststr', _poststr);
  AddCommand('*postname', _postname);
  AddCommand('utf8->unicode', _utf8_2_unicode);
  AddCommand('utf8->raw', _utf8_2_raw);
  AddCommand('raw->unicode', _raw_2_unicode);
  AddCommand('unicode->utf8', _unicode_2_utf8);
  AddCommand('unicode->raw', _unicode_2_raw);
  AddCommand('randomize', _randomize);
  AddCommand('random', _random);
  
  AddCommand('w>b', _WtoB);
  AddCommand('b>w', _BtoW);

  SetLength(FTypes, 0);
  all_create;
  AddType('', 0);
  AddType('void', 0);
  AddType('int', SizeOf(TInt));
  AddType('int8', SizeOf(TInt8));
  AddType('int16', SizeOf(TInt16));
  AddType('int32', SizeOf(TInt32));
  AddType('int64', SizeOf(TInt64));
  AddType('uint', SizeOf(TUInt));
  AddType('uint8', SizeOf(TUInt8));
  AddType('uint16', SizeOf(TUInt16));
  AddType('uint32', SizeOf(TUInt32));
  AddType('uint64', SizeOf(TUInt64));
  AddType('bool', SizeOf(TInt));
  AddType('ptr', SizeOf(Pointer));
  AddType('pchar', SizeOf(PChar));
  AddType('str', SizeOf(TStr));
  AddType('type', SizeOf(PType));
  AddType('float', SizeOf(PType));
  AddType('double', SizeOf(PType));
  AddType('extended', SizeOf(PType));

  AddCommand('exit', _exit);
{$IFNDEF FLAG_FPC}{$REGION 'control commands'}{$ENDIF}
  AddCommand(':', compile_def);
  AddCommand(':noname', compile_noname);
  AddCommand(';', compile_enddef, True);
  AddCommand('skip-to;', compile_enddef, True);
  AddCommand('...', scattered_dots, True);
  AddCommand('..:', compile_scattered_def);
  AddCommand(';..', compile_scattered_enddef, True);
  AddCommand('branch', branch);
  AddCommand('?branch', _ask_branch);
  AddCommand('>mark', _gt_mark);
  AddCommand('>resolve', _gt_resolve);
  AddCommand('<mark', _lt_mark);
  AddCommand('<resolve', _lt_resolve);
  AddCommand('recurse', recurse, True);
  AddCommand('immediate', immediate);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'embro commands'}{$ENDIF}
  AddCommand('compile', compile, True);
  AddCommand('(compile)', q_compile_q, True);
  AddCommand('call', _call, True);
  AddCommand('postpone', postpone, True);
  AddCommand('compiled', _compiled, False);
  AddCommand('postponed', _postponed, False);
  AddCommand('called', _called, False);
  AddCommand('evaluate', Evaluate);
  ~AddCommand('evaluate-file', EvaluateFile);|
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'data commands'}{$ENDIF}
  AddCommand('nil', _nil);
  AddCommand('ptr,', ptr_comma);

  AddCommand('create', _create);
  AddCommand('created', _created);
  DCommandsEmbro.LoadCommands(@Self);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'bool'}{$ENDIF}
  DCommandsBool.LoadCommands(@Self);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
{$IFNDEF FLAG_FPC}{$REGION 'type commands'}{$ENDIF}
  AddCommand('typeof', typeof, True);
  AddCommand('(typeof)', run_type);
  AddCommand('type-size', type_size);
  AddCommand('t_void', _void, True);
  AddCommand('t_int', _int, True);
  AddCommand('t_int8', _int8, True);
  AddCommand('t_int16', _int16, True);
  AddCommand('t_int32', _int32, True);
  AddCommand('t_int64', _int64, True);
  AddCommand('t_uint', _uint, True);
  AddCommand('t_uint8', _uint8, True);
  AddCommand('t_uint16', _uint16, True);
  AddCommand('t_uint32', _uint32, True);
  AddCommand('t_uint64', _uint64, True);
  AddCommand('t_bool', _bool, True);
  AddCommand('t_str', _str, True);
  AddCommand('t_pchar', _pchar, True);
  AddCommand('t_ptr', _ptr, True);
  AddCommand('t_type', _type, True);
  AddCommand('t_float', _float, True);
  AddCommand('t_single', _float, True);
  AddCommand('t_double', _double, True);
  AddCommand('t_extended', _extended, True);
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}
  DCommandsAlien.LoadCommands(@Self);
  DCommandsStrings.LoadCommands(@Self);
  DCommandsConsole.LoadCommands(@Self);
  DCommandsF.LoadCommands(@Self);
  DCommandsBW.LoadCommands(@Self);
  DCommandsCompile.LoadCommands(@Self);
  DCommandsCreatewords.LoadCommands(@Self);
  DCommandsFiles.LoadCommands(@Self);
  DCommandsInt.LoadCommands(@Self);
  DCommandsMem.LoadCommands(@Self);
  DCommandsOS.LoadCommands(@Self);
  DCommandsPtr.LoadCommands(@Self);
  DCommandsR.LoadCommands(@Self);
  DCommandsSource.LoadCommands(@Self);
  DCommandsVM.LoadCommands(@Self);
  DCommandsVoc.LoadCommands(@Self);
  DCommandsExtInt.LoadCommands(@Self);
  DCommandsMisc.LoadCommands(@Self);
  regist_all_commands;
  UnuseVoc;
end;

destructor OForthMachine.Destroy; 
begin
  all_free;
  FAlien.Free;
  //FMemoryDebug.Free;
end;

procedure OForthMachine.InterpretName(W: PChar);
var
  I: Integer;
  Command: PForthCommand;
  S_: TString;
  //Time: Integer;
begin
  //Writeln('INTERPRET ', W);
  (* for I := High(C) downto 0 do *)
  (*   if StrComp(C[I].Name, W) = 0 then begin *)
  (*     //Writeln('START ' + W); *)
  (*     C[I].Code(@Self, C[I]); *)
  (*     // Writeln('DONE ' + W); *)
  (*     Exit; *)
  (*   end; *)
  S_ := W;
  Command := FindCommand(S_);
  // Writeln('FOUND COMMAND: ', Integer(Command));
  if Command <> nil then begin
    // Writeln('INTERPRET COMMAND ', Command^.Name);
    Command.Code(@Self, Command);
    Exit;
  end;
  //Time := GetTimer;
  for I := High(Context) downto 0 do begin
    if Context[I] = nil then
      continue;
    if Context[I]^.sNOTFOUND = -1 then
      continue;
    WUS(S_);
    CallCommand(C[Context[I]^.sNOTFOUND]);
    if WOI <> 0 then
      Exit;
  end;
  LogError('unknown command "' + S_ + '"');
end;

function OForthMachine.CompileName(W: PChar): Boolean;
var
  I: Integer;
  Command: PForthCommand;
  S_: TString;
begin
  S_ := W;
  Command := FindCommand(S_, @I);
  if Command <> nil then begin
    if IsImmediate(C[I]) then
      C[I].Code(@Self, C[I])
    else
      EWO(I);
    Exit;
  end;
  for I := High(Context) downto 0 do begin
    if Context[I] = nil then
      continue;
    if Context[I]^.sNOTFOUND = -1 then
      continue;
    WUS(S_);
    CallCommand(C[Context[I]^.sNOTFOUND]);
    if WOI <> 0 then
      Exit;
  end;
  LogError('Unknown command: ' + W)
end;

procedure OForthMachine.Interpret(const Line: PChar);
begin
  //Writeln('Interpret ', Line);
  if Line = nil then
    Exit;
  (* Writeln('RB=', Cardinal(RB), *)
  (*         ' RP=', Cardinal(RP),  *)
  (*         ' SC=', SC,  *)
  (*         ' EC=', EC, *)
  (*         ' Line=', Line); *)
  RUI(State);
  RUI(Ord(FSession) * BOOL_TRUE);
  RUI(Ord(FRunning) * BOOL_TRUE);
  RUI(EC);
  RUP(Self.S);
  RUI(SC);
  RUP(RB);
  Self.S := Line;
  //Self.SB := Line;
  Self.SC := 0;
  State := FS_INTERPRET;
  FSession := True;
  FRunning := False;
  RUI(FCurrentLine);
  RUI(FCurrentPos);
  FCurrentLine := 1;
  FCurrentPos := 1;
  MainLoop;
  FCurrentPos := ROI;
  FCurrentLine := ROI;
  RB := ROP; 
  SC := ROI;
  Self.S  := ROP;
  EC := ROI;
  FRunning := ROI <> BOOL_FALSE;
  FSession := ROI <> BOOL_FALSE;
  // Writeln('RB=', Cardinal(RB), ' SC=', SC, ' Line=', Integer(Line), ' EC=', EC);
  State := ROI;
end;

procedure OForthMachine.InterpretFile(const FileName: TString);
var
  F: TextFile;
  S_: TString;
  B: TString;
  T: TString;
begin
  S_ := FileName;
  Assign(F, S_);
  {$I-}
  Reset(F);
  {$I+}
  if IOResult <> 0 then begin
    LogError('cannot open file "' + S_ + '"');
    Exit;
  end;
  B := '';
  while not EOF(F) do begin
    Readln(F, T);
    B := B + T + EOL;
  end;
  Close(F);
  WUS(FCurrentFileName);
  LUI(FCurrentLine);
  LUI(FCurrentPos);
  FCurrentFileName := FileName;
  FCurrentLine := 1;
  FCurrentPos := 1;
  Interpret(PChar(B));
  FCurrentPos := LOI;
  FCurrentLine := LOI;
  FCurrentFileName := WOS;
end;

procedure Evaluate(Machine: TForthMachine; Command: PForthCommand);
var
  S: TStr;
begin
  S := str_pop(Machine);
  Machine.Interpret(PChar(@(PStrRec(S)^.Sym[0])));
  DelRef(S);
end;

procedure EvaluateFile(Machine: TForthMachine; Command: PForthCommand);
var
  //F: File of Byte;
  F: TextFile;
  S: TStr;
  //B: array of Byte;
  B: TString;
  T: TString;
  FullPath: TString;
  ShortPath: TString;
begin
  S := str_pop(Machine);
  ShortPath := TString(PChar(@(PStrRec(S)^.Sym[0])));
  FullPath := '';
  while True do begin
    if Length(Machine.Directories) > 0 then begin
      FullPath := Machine.Directories[High(Machine.Directories)] + ShortPath;
      if FileExists(FullPath) then 
        Break;
    end;
    FullPath := PChar(GetCurrentDirectory) + '\' + ShortPath;
    if FileExists(FullPath) then 
      Break;
    FullPath := PChar(GetExeDirectory) + '\' + ShortPath;
    if FileExists(FullPath) then 
      Break;
    Exit;
  end;
  SetLength(Machine.Directories, Length(Machine.Directories) + 1);
  Machine.Directories[High(Machine.Directories)] := GetDirectory(FullPath);
  DelRef(S);
  Machine.InterpretFile(FullPath);
  SetLength(Machine.Directories, Length(Machine.Directories) - 1);
  (* // Writeln('Evaluate file "', PChar(@(PStrRec(S)^.Sym[0])), '"'); *)
  (* if Length(Machine.Directories) > 0 then begin *)
  (*   FullPath := Machine.Directories[High(Machine.Directories)] + ShortPath;  *)
  (*   Assign(F, FullPath); *)
  (*   {$I-} *)
  (*   Reset(F); *)
  (*   {$I+} *)
  (* end; *)
  (* if (Length(Machine.Directories) = 0) or (IOResult <> 0) then begin *)
  (*   FullPath := PChar(GetCurrentDirectory) + '\\' + ShortPath; *)
  (*   Assign(F, FullPath); *)
  (*   {$I-} *)
  (*   Reset(F); *)
  (*   {$I+} *)
  (*   if IOResult <> 0 then begin *)
  (*     FullPath := PChar(GetExeDirectory) + '\\' + ShortPath; *)
  (*     Assign(F, FullPath); *)
  (*     {$I-} *)
  (*     Reset(F); *)
  (*     {$I+} *)
  (*     if IOResult <> 0 then begin *)
  (*       Machine.LogError('cannot open file "' + ShortPath + '"'); *)
  (*       Exit; *)
  (*     end; *)
  (*   end; *)
  (* end; *)
  (* B := TString(PChar(@(PStrRec(S)^.Sym[0]))); *)
  (* while (Length(B) > 0) and (B[Length(B)] <> '\\') do begin *)
  (*   SetLength(B, Length(B) - 1); *)
  (* end; *)
  (* SetLength(Machine.Directories, Length(Machine.Directories) + 1); *)
  (* Machine.Directories[High(Machine.Directories)] := B; *)
  (* B := ''; *)
  (* while not EOF(F) do begin *)
  (*   Readln(F, T); *)
  (*   B := B + T + EOL; *)
  (* end; *)
  (* Close(F); *)
  (* Machine.Interpret(PChar(B)); *)
  (* DelRef(S); *)
  (* SetLength(Machine.Directories, Length(Machine.Directories) - 1); *)
  // Writeln('End of evaluate file "', PChar(@S^.Sym[0]), '"');
end;

procedure OForthMachine.CallCommand(Command: PForthCommand);
begin
  if Command = nil then
    Exit;
  // Writeln('Call command ', Command^.Name);
  RUI(Ord(FSession) * BOOL_TRUE);
  RUI(Ord(FRunning) * BOOL_TRUE);
  RUI(EC);
  RUP(S);
  RUI(SC);
  RUP(RB);
  RUP(RP);
  S := '';
  SC := 0;
  RB := RP;
  FSession := True;
  FRunning := False;
  Command^.Code(@Self, Command);
  if FRunning then begin
    // Writeln('MAINLOOP');
    MainLoop;
  end;
  RP := ROP;
  RB := ROP; 
  SC := ROI;
  S := ROP;
  EC := ROI;
  FRunning := ROI <> BOOL_FALSE;
  FSession := ROI <> BOOL_FALSE;
  // Writeln('Command done');
end;

procedure OForthMachine.MainLoop;
begin
  while FSession do begin
    //Writeln('MainLoop');
    if FRunning then
      RunStep
    else
      case State of
        FS_INTERPRET: InterpretStep;
        FS_COMPILE:   CompileStep;
      else
        LogError('Illegal State');
        FSession := False;
      end;
    // Writeln('Main Loop State="', State, '" FRunning="', FRunning, '"');
  end;
end;

procedure OForthMachine.Step;
var
  Running: Boolean;
begin
  if not FSession then
    Exit;
  Writeln('Step');
  Running := FRunning;
  FRunning := False;
  case State of
    FS_INTERPRET: InterpretStep;
    FS_COMPILE:   CompileStep;
  else
    LogError('Illegal State');
    FSession := False;
  end;
  FRunning := Running;
end;

procedure OForthMachine.InterpretStep;
begin
  // Writeln('INTERPRET STEP');
  SSS;
  if SE then begin
    FSession := False;
  end else
    InterpretName(PChar(SNN));
end;

procedure OForthMachine.CompileStep;
begin
  // Writeln('COMPILE STEP');
  SSS;
  if SE then
    FSession := False
  else
    CompileName(PChar(SNN));
end;

procedure OForthMachine.RunStep;
begin
  RunMnemonic(ERO);
end;

procedure OForthMachine.CompileError(const S: TString);
begin
  Error('Compile(' + InternalFileName(FCurrentFileName) + ', ' +
                     IntToStr(FCurrentLine) + ', ' +
                     IntToStr(FCurrentPos) + '): ' + S);
  FCompilation := False;
end;

procedure OForthMachine.CompileWarring(const S: TString);
begin
  Warrning(' Compilation: "' + S + '"');
end;

procedure OForthMachine.LogError(const S: TString);
begin
  if State = FS_COMPILE then
    CompileError(S)
  else
    RunError(S);
end;

function OForthMachine.NextChar: TChar;
begin
  Result := SNC;
  {if EOS then
    Result := #0
  else begin
    Result := FSource[FCurrentChar];
    Inc(FCurrentChar);
  end;}
end;

function OForthMachine.NextName: TString;
begin
  Result := SNN;
  {Result := '';
  repeat
    C := NextChar;
  until (not (C in [#0..#32])) or EOS;
  repeat
    Result := Result + C;
    if EOS then
      Exit;
    C := NextChar;
  until (C in [#0..#32]) or EOS;
  if not (C in [#0..#32]) then
    Result := Result + C;}
end;

function OForthMachine.NextName(S: PChar; var I: Integer): TString;
var
  Ch: TChar;
begin
  Result := '';
  repeat
    Ch := S[I];
    if Ch <> #0 then
      Inc(I);
  until (not (Ch in [#0..#32])) or (Ch = #0);
  repeat
    Result := Result + Ch;
    if S[I] = #0 then
      Exit;
    Ch := S[I];
    if Ch <> #0 then
      Inc(I);
  until (Ch in [#0..#32]) or (Ch = #0);
  if not (Ch in [#0..#32]) then
    Result := Result + Ch;
end;

function OForthMachine.NextNamePassive: TString;
var
  Temp: Integer;
begin
  Temp := SC;
  Result := NextName(S, Temp);
end;

function OForthMachine.EOS: Boolean; // end of source
begin
  Result := SE;
  //Result := FSource[FCurrentChar] = #0;
end;

procedure OForthMachine.WriteEmbro(P: Pointer; Size: Integer);
begin
  SetLength(FEmbro, Length(FEmbro) + Size);
  Move(P^, FEmbro[Length(FEmbro) - Size], Size);
end;

procedure OForthMachine.WriteEmbroInt(I: Integer);
begin
  WriteEmbro(@I, SizeOf(I));
  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' ' + IntToStr(I) + ' ';
end;

procedure OForthMachine.WriteEmbroUInt(U: Cardinal);
begin
  WriteEmbro(@U, SizeOf(U));
  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + ' u' + IntToStr(U) + ' ';
end;

procedure OForthMachine.WriteEmbroChar(C: Char);
begin
  WriteEmbro(@C, SizeOf(C));
  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + '''' + IntToHex(Ord(C), 2);
end;

procedure OForthMachine.WriteEmbroByte(B: Byte);
begin
  WriteEmbro(@B, SizeOf(B));
  FEmbroDump[High(FEmbroDump)] := FEmbroDump[High(FEmbroDump)] + 'b' + IntToHex(Ord(B), 2);
end;

procedure OForthMachine.PopEmbro(P: Pointer; Size: Integer);
begin
  Move(FEmbro[Length(FEmbro) - Size], P^, Size);
  SetLength(FEmbro, Length(FEmbro) - Size);
end;

procedure OForthMachine.WriteMnemonic(M: Cardinal);
begin
  WriteEmbro(@M, SizeOf(M));
  SetLength(FEmbroDump, Length(FEmbroDump) + 1);
  FEmbroDump[High(FEmbroDump)] := C[M].Name + ' ';
end;

procedure OForthMachine.WriteMnemonicByName(const Name: TString);
var
  I: Integer;
begin
  //Writeln('Write mnemonic by name ' + Name);
  for I := High(C) downto 0 do
    if TString(C[I].Name) = Name then begin
      WriteMnemonic(I);
      Exit;
    end;
  (* I := StrToIntDef(Name, -3535); *)
  (* if I = -3535 then *)
  (*   CompileError('Unknown name "' + Name + '"') *)
  (* else begin *)
  (*   WriteMnemonicByName('int-push'); *)
  (*   WriteEmbroInt(I); *)
  (* end; *)
  if ConvertStrToInt(Name, I) <> 0 then
    LogError('Unknown command: ' + Name)
  else begin
    BuiltinEWO('(literal)');
    EWI(I);
  end;
end;

function OForthMachine.GetOpcodeByName(const Name: TString): TMnemonic;
var
  I: Integer;
begin
  for I := High(C) downto 0 do
    if TString(C[I].Name) = Name then begin
      //Writeln(I);
      Result := I;
      Exit;
    end;
  Result := 0;
end;

function OForthMachine.GetCommandByOpcode(Opcode: Integer): PForthCommand;
begin
  //Writeln(Opcode);
  Result := C[Opcode];
end;

procedure OForthMachine.CancelMnemonic;
begin
  SetLength(FEmbro, Length(FEmbro) - SizeOf(Cardinal));
end;

function OForthMachine.ReserveName(const Name: TString): PForthCommand;
var
  I: Integer;
begin
  FLastMnemonic := -1;
  {{for I := 0 to High(C) do
    if TString(C[I].Name) = Name then begin
      Result := C[I];
      FLastMnemonic := I;
      Break;
    end;}
  if FLastMnemonic = -1 then begin
    SetLength(C, Length(C) + 1);
    New(C[High(C)]);
    C[High(C)].Name := StrAlloc(Length(Name)+1);
    StrCopy(C[High(C)].Name, PChar(Name));
  end;
  SetImmediate(C[High(C)], False);
  C[High(C)].Code := call;
  FLastMnemonic := High(C);
  Result := C[High(C)];
  if Name <> '' then begin
    OnUpdateCommand(High(C));
    FLastMnemonic := High(C);
  end;
end;

procedure OForthMachine.ReadEmbro(P: Pointer; Size: Integer);
begin
  Move(FEmbro[EC], P^, Size);
  Inc(EC, Size);
end;

function OForthMachine.ReadMnemonic: TMnemonic;
begin
  ReadEmbro(@Result, SizeOf(TMnemonic));
end;

function OForthMachine.GetEmbroDumpLines: Integer;
begin
  Result := Length(FEmbroDump);
end;

function OForthMachine.GetEmbroDumpLine;
begin
  Result := FEmbroDump[Index];
end;

procedure _FIND_(Machine: TForthMachine; Command: PForthCommand);
var
  B: TString;
  I: Integer;
  Item: PVocItem;
begin
  with Machine^ do begin
    B := WOS;
    with Machine^ do begin
      for I := High(Context) downto 0 do begin
        if Context[I] = nil then
          continue;
        Item := Context[I].Item;
        while Item <> nil do begin
          if TString(C[Item^.Index]^.Name) = B then begin
            //Writeln('FOUND ', Item^.Index, ' ', C[Item^.Index]^.Name);
            WUI(Item^.Index);
            WUI(0);
            Exit;
          end;
          Item := Item^.Next;
        end;
      end;
      // Writeln('_FIND_(', B, ')');
      //for I := High(C) downto 0 do
      //  if TString(C[I].Name) = B then begin
      //    WUI(I);
      //    WUI(0);
      //    // Writeln('_FIND_(', B, ') done');
      //    Exit;
      //  end;
      WUI(-1);
      // Writeln('_FIND_(', B, ') failed');
    end;
  end;
end;

procedure _NOTFOUND_(Machine: TForthMachine; Command: PForthCommand);
var
  B: TString;
  I: Integer;
begin
  with Machine^ do begin
    B := Machine.WOS;
    // Writeln('_NOTFOUND_(', B, ')');
    if ConvertStrToInt(B, I) = 0 then begin
      if Machine^.State = FS_INTERPRET then
        Machine^.WUI(I)
      else begin
        Machine^.BuiltinEWO('(literal)');
        MAchine^.EWI(I);
      end;
      WUI(BOOL_TRUE);
      Exit;
    end;
    WUI(BOOL_FALSE);
  end;
end;

procedure _align(Machine: TForthMachine; Command: PForthCommand);
var
  I: Integer;
body(
  I := WOI;
  if I mod 4 = 0 then
    WUI(I)
  else
    WUI(I + 4 - (I mod 4))
)

procedure _palign(Machine: TForthMachine; Command: PForthCommand);
begin
  _align(Machine, Command);
end;

procedure _poststr cmdhdr; body(WUP(@ConvStr))
procedure _postname cmdhdr; body(WUP(@ConvName))

procedure _raw_2_unicode cmdhdr;
var
  B, C: TStr;
begin
  B := str_pop(Machine);
  C := CreateStr(4, B^.Len);
  MoveChars(@C^.Sym[0], @B^.Sym[0], B^.Len, 4, B^.Width);
  DelRef(B);
  str_push(Machine, C);
end;

procedure _utf8_2_unicode cmdhdr;
var
  B, C: TStr;
  Len, U: Integer;
  P: Pointer;
begin
  B := str_pop(Machine);
  C := CreateStr(4, B^.Len);
  Len := 0;
  P := @B^.Sym[0];
  while TUInt(P) < TUInt(@B^.Sym[B^.Len]) do
    if not ReadUTF8Char(P, U) then
      Break
    else begin
      PArrayOfCardinal(@C^.Sym[0])^[Len] := U;
      Inc(Len);
      // Write(Char(U));
    end;
  // Writeln;
  C^.Len := Len;
  DelRef(B);
  str_push(Machine, C);
end;

procedure _utf8_2_raw cmdhdr;
body(
)

procedure _unicode_2_utf8 cmdhdr;
body(
)

procedure _unicode_2_raw cmdhdr;
var
  B, C: TStr;
begin
  B := str_pop(Machine);
  C := CreateStr(1, B^.Len);
  MoveChars(@C^.Sym[0], @B^.Sym[0], B^.Len, 1, B^.Width);
  DelRef(B);
  str_push(Machine, C);
end;

procedure _randomize cmdhdr;
begin
  Randomize;
end;

procedure _random cmdhdr;
begin
  Machine.WUI(Random(Machine.WOI));
end;

function OForthMachine.FindCommand(Voc: PVoc; const Name: TString; Index: PInteger = nil): PForthCommand;
begin
  if Voc <> nil then begin
    if Voc.sFIND <> -1 then begin
      WUS(Name);
      CallCommand(C[Voc.sFIND]);
      if WOI = 0 then begin
        if Index <> nil then begin
          Index^ := WOI;
          Result := C[Index^];
        end else
          Result := C[WOI];
      end else begin
        Result := nil;
      end;
    end else
      Result := nil;
  end else
    Result := nil;
end;

function OForthMachine.FindCommand(const Name: TString; Index: PInteger = nil): PForthCommand;
var
  I: Integer;
begin
  I := High(Context);
  Result := nil;
  for I := High(Context) downto 0 do begin
    Result := FindCommand(Context[I], Name, Index);
    if Result <> nil then
      Exit;
  end;
  (* I := High(Context); *)
  (* while I >= 0 do *)
  (*   if Context[I] <> nil then begin *)
  (*     if Context[I].sFIND = -1 then *)
  (*       Dec(I) *)
  (*     else *)
  (*       Break; *)
  (*   end else *)
  (*     Dec(I); *)
  (* // Writeln('I = ', I); *)
  (* if I <> -1 then begin *)
  (*   WUS(Name); *)
  (*   CallCommand(C[Context[I].sFIND]); *)
  (*   if WOI = 0 then begin *)
  (*     if Index <> nil then begin *)
  (*       Index^ := WOI; *)
  (*       Result := C[Index^]; *)
  (*     end else *)
  (*       Result := C[WOI]; *)
  (*   end else begin *)
  (*     Result := nil; *)
  (*   end; *)
  (* end else *)
  (*   Result := nil; *)
end;

function OForthMachine.ExtendedFindCommand(const Name: TString; Index: PInteger = nil): PForthCommand;
begin
  Result := FindCommand(Name, Index);
  if Result = nil then
    Result := FindCommand(vBUILTIN, Name, Index);
end;
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}

// ( Вся соль :)
all_implement

end.

{
var
  testptr,param:pointer;
  mm:TMemoryStream;
  i,paramsize:integer;
begin
  testptr:=@test;
  mm:=TMemoryStream.Create;
// в обратном порядке кидаю параметры в память
  i:=20;
  mm.Write(i,sizeof(i));
  i:=10;
  mm.Write(i,sizeof(i));
// здесь надо кидать по 4 байта - или указатель, или значение.
  mm.Position:=0;
  paramsize:=mm.Size;
  param:=mm.Memory;
  asm
    mov eax,0
    mov ecx,0
    lab:
    mov ebx,[Param+ecx]
    // получаю значение под указателем
    // если этого не сделать, то положим указатель на память вместо значения.
    mov ebx,[ebx]
    // в стек
    push ebx
    add ecx,4
    cmp ecx,ParamSize
    jne lab
    // сам вызов
    call [testptr]
  end;
    mov eax, work
    mov ecx, param
    cycle:
      mov ebx, BYTE [ecx] // получаем значение текущего байта
      jz endcycle // если 0, то выходим из цикла
      push [eax] // переносим очередной параметр на стек
      sub eax, ebx // сдвигаем указатели
      inc ecx
      jmp cycle // повторяем операцию
    endcycle:
      inc ecx
      call [ecx] // вызываем функцию
      add ecx, 4
      pop [eax] // переносим результат на рабочий стек форта
      add eax, BYTE [ecx]
      mov work, eax // сменяем положение стека
end;




Чистить стек можно с помощью любого регистра pop-ами, а можно сделать проще - просто сохранить esp где ни будь и восстановить. Вобще то любую переменную больше 4 байт обычно передают по адресу, так как она уже является массивом и считывать ее придется уже побайтово, тоесть инкрементируя адрес. Но я правда не уверен насчет языков высокого уровня, что там из себя представляют переменные. Я бы делал для надежности так :
int a;
LEA eax,a
mov ebx,[eax]
ну это конечно утрировано, но зато надежно.

mov ebx,[Param+ecx]
mov ebx,[ebx]

Вот в эту шаманскую песенку я не вкурил. [Param+ecx] это уже ваша переменная со смещением, двойное слово. Или там в param список адресов? 





В param - адрес на память, где находятся параметры.
param:=mm.Memory;

сначала ecx=0, с каждым проходом цикла он увеличивается на 4
add ecx,4

и так пока ecx не станет равным ParamSize - общей сумме размеров параметров.

а что такое
LEA eax,a
mov ebx,[eax]
? для типа extended не работает - он передается как 2 dword и один word.
Например, для (-5.5):
push $0000c001
push $b0000000
push $00
из CPU-debug. 

}
))))))))))))))))))))))))))))))))))))))))))))))))
_out
