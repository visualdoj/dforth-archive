unit DCommandsArithmetic;

interface

uses
  {$I units.inc},

  DEmbroCore,
  DCommandsStrings,
  DForthMachine;

changequote(~,|)
define(~genname|, ~ifelse($1, ~|, $2, len($1), ~1|, $2, $1-$2)|)
{$IFNDEF FLAG_FPC}{$REGION 'arithmetic_commands'}{$ENDIF}
define(~arithmetic_commands|, 
  ~
  procedure $1_plus cmdhdr;
  procedure $1_minus cmdhdr;
  procedure $1_star cmdhdr;
  procedure $1_equel cmdhdr;
  procedure $1_nequel cmdhdr;
  procedure $1_lt cmdhdr;
  procedure $1_gt cmdhdr;
  procedure $1_lte cmdhdr;
  procedure $1_gte cmdhdr;  
  procedure $1_0_equel cmdhdr;
  procedure $1_0_nequel cmdhdr;
  procedure $1_0_lt cmdhdr;
  procedure $1_0_gt cmdhdr;
  procedure $1_0_lte cmdhdr;
  procedure $1_0_gte cmdhdr;
  procedure $1_ask_dup cmdhdr;
  procedure $1_0_exit cmdhdr;
  procedure $1_if_exit cmdhdr;
  procedure $1_max cmdhdr;
  procedure $1_min cmdhdr;
  procedure $1_minmax cmdhdr;
  procedure $1_dot cmdhdr;
  procedure $1_dollar cmdhdr;
  procedure $1_ptr_plus_exclamation cmdhdr;
  procedure $1_conv_to_str cmdhdr;
  procedure $1_conv_from_str cmdhdr
  define(~all_implement|, all_implement 
    ~
      procedure $1_plus  cmdhdr; body( $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) + $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); )
      procedure $1_minus cmdhdr; body( $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) - $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); )
      procedure $1_star  cmdhdr; body( $2(WVar(-2*SizeOf($2))) := $2(WVar(-2*SizeOf($2))) * $2(WVar(-SizeOf($2))); 
                                                   Dec(WP, SizeOf($2)); )
      procedure $1_equel cmdhdr; body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) = $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_nequel cmdhdr; body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) <> $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_lt cmdhdr;    body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) < $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_gt cmdhdr;    body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) > $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_lte cmdhdr;   body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) <= $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_gte cmdhdr;   body( TInt(WVar(-2*SizeOf($2))) := BOOL_TRUE*Ord($2(WVar(-2*SizeOf($2))) >= $2(WVar(-SizeOf($2)))); 
                                                   Dec(WP, 2*SizeOf($2) - SizeOf(TInt)); )
      procedure $1_0_equel cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) = 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_0_nequel cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) <> 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_0_lt cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) < 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_0_gt cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) > 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_0_lte cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) <= 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_0_gte cmdhdr; body( TInt(WVar(-1*SizeOf($2))) := BOOL_TRUE*Ord(($2(WVar(-1*SizeOf($2)))) >= 0); Dec(WP, SizeOf($2) - SizeOf(TInt)) )
      procedure $1_ask_dup cmdhdr; body( if ($2(WVar(-1*SizeOf($2)))) <> 0 then begin $2(WP^) := $2(WVar(-1*SizeOf($2))); Inc(WP, SizeOf($2)); end; )
      procedure $1_0_exit cmdhdr; body( if $2(WVar(-SizeOf($2))) = 0 then begin Dec(WP, SizeOf($2)); _exit(Machine, Command); end )
      procedure $1_if_exit cmdhdr; body( if $2(WVar(-SizeOf($2))) <> 0 then begin Dec(WP, SizeOf($2)); _exit(Machine, Command); end )
      procedure $1_max cmdhdr;
      body(
        if $2(WVar(-2*SizeOf($2))) < $2(WVar(-1*SizeOf($2))) then
          Move(WVar(-1*SizeOf($2)), WVar(-2*SizeOf($2)), SizeOf($2));
        Dec(WP, SizeOf($2));
      )
      procedure $1_min cmdhdr;
      body(
        if $2(WVar(-2*SizeOf($2))) > $2(WVar(-1*SizeOf($2))) then
          Move(WVar(-1*SizeOf($2)), WVar(-2*SizeOf($2)), SizeOf($2));
        Dec(WP, SizeOf($2));
      )
      procedure $1_minmax cmdhdr;
      body(
        if $2(WVar(-2*SizeOf($2))) > $2(WVar(-1*SizeOf($2))) then begin
          Move(WVar(-2*SizeOf($2)), WVar(-0*SizeOf($2)), SizeOf($2));
          Move(WVar(-1*SizeOf($2)), WVar(-2*SizeOf($2)), SizeOf($2));
          Move(WVar(-0*SizeOf($2)), WVar(-1*SizeOf($2)), SizeOf($2));
        end;
      )
      procedure $1_dot cmdhdr;    body( Dec(WP, SizeOf($2)); Write($2(WP^), ' '); )
      procedure $1_dollar cmdhdr; var Temp: $2; body( Read(Temp); Move(Temp, WP^, SizeOf($2)); Inc(WP, SizeOf($2)); )
      procedure $1_ptr_plus_exclamation cmdhdr; body( $2(Pointer(WVar(-SizeOf(Pointer)))^) := $2(Pointer(WVar(-SizeOf(Pointer)))^) + $2(WVar(-SizeOf(Pointer)-SizeOf($2))); Dec(WP, SizeOf(Pointer) + SizeOf($2)); )
      procedure $1_conv_to_str cmdhdr;
      var
        B: TString;
      body(
        Str($2(WVar(-SizeOf($2))), B);
        Dec(WP, SizeOf($2));
        str_push(Machine, B);
      )
      procedure $1_conv_from_str cmdhdr;
      var
        B: TStr;
      body(
        B := str_pop(Machine);
        Val(PChar(@(TStrRec(B^).Sym[0])), $2(WP^));
        Inc(WP, SizeOf($2));
        DelRef(B);
      )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     Machine.AddCommand('$1+', $1_plus);
     Machine.AddCommand('$1-', $1_minus);
     Machine.AddCommand('$1*', $1_star);
     Machine.AddCommand('$1=', $1_equel);
     Machine.AddCommand('$1<>', $1_nequel);
     Machine.AddCommand('$1<', $1_lt);
     Machine.AddCommand('$1>', $1_gt);
     Machine.AddCommand('$1<=', $1_lte);
     Machine.AddCommand('$1>=', $1_gte);
     Machine.AddCommand('genname($1, 0=)', $1_0_equel);
     Machine.AddCommand('genname($1, 0<>)', $1_0_nequel);
     Machine.AddCommand('genname($1, 0<)', $1_0_lt);
     Machine.AddCommand('genname($1, 0>)', $1_0_gt);
     Machine.AddCommand('genname($1, 0<=)', $1_0_lte);
     Machine.AddCommand('genname($1, 0>=)', $1_0_gte);
     Machine.AddCommand('genname($1, ?dup)', $1_ask_dup);
     Machine.Addcommand('genname($1, 0;)', $1_0_exit);
     Machine.Addcommand('genname($1, if;)', $1_if_exit);
     Machine.AddCommand('genname($1, min)', $1_min);
     Machine.AddCommand('genname($1, max)', $1_max);
     Machine.AddCommand('genname($1, minmax)', $1_minmax);
     Machine.AddCommand('$1.', $1_dot);
     Machine.AddCommand('$1$', $1_dollar);
     Machine.AddCommand('$1+!', $1_ptr_plus_exclamation);
     Machine.AddCommand('$1->str', $1_conv_to_str);
     Machine.AddCommand('str->$1', $1_conv_from_str);
    |)
|)
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}

  arithmetic_commands(~|, TInt);
  arithmetic_commands(int, TInt);
  arithmetic_commands(int8, TInt8);
  arithmetic_commands(int16, TInt16);
  arithmetic_commands(int32, TInt32);
  arithmetic_commands(int64, TInt64);
  arithmetic_commands(uint, TUInt);
  arithmetic_commands(uint8, TUInt8);
  arithmetic_commands(uint16, TUInt16);
  arithmetic_commands(uint32, TUInt32);
  arithmetic_commands(uint64, TUInt64);
  arithmetic_commands(float, Single);
  arithmetic_commands(double, Double);
  arithmetic_commands(extended, Extended);

procedure LoadCommands(Machine: TForthMachine);

implementation

all_implement

procedure LoadCommands(Machine: TForthMachine);
begin
  regist_all_commands;
end;

end.
