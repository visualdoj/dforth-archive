unit DCommandsInt;

interface

uses
  {$I units.inc},

  DEmbroCore,
  DForthMachine;

changequote(~,|)

define(~all_implement|, ~|)
define(~regist_all_commands|, ~|)
define(~all_create|, ~|)
define(~all_free|, ~|)
define(~cmdhdr|, ~(Machine: TForthMachine; Command: PForthCommand)|)
define(~WVar|, ~(Pointer(TUInt(Machine.WP) + ($1))^)|)
define(~LVar|, ~(Pointer(TUInt(LB) + ($1))^)|)
define(~WInc|, ~Inc(WP, $1)|)
define(~WDec|, ~Dec(TUInt(WP), $1)|)
define(~PSize|, ~(SizeOf(Pointer))|)
define(~CELL|, ~(SizeOf(Pointer))|)
define(~BInc|, ~Inc(BWP, CELL)|)
define(~BDec|, ~Dec(TUInt(BWP), CELL)|)
define(~BVar|, ~TBlock(Pointer(TUInt(Machine.BWP) + ($1)*CELL)^)|)
define(~binc|, ~ if $1 <> nil then begin
                   if PInteger($1)^ <> -1 then Inc(PInteger($1)^); 
                 end|)
define(~bdec|, ~ if $1 <> nil then begin
                   if PInteger($1)^ > 1 then Dec(PInteger($1)^)
                   else if PInteger($1)^ = 1 then FreeMem(Pointer($1)); 
                 end|)
define(~genname|, ~ifelse($1, ~|, $2, len($1), ~1|, $2, $1-$2)|)
define(~body|, ~begin with Machine^ do begin $1 end; end;|)

define(~_X86|)
define(~_IA32|)

ifdef(_IA32,,define(~N_IA32|))
ifdef(_X86,,define(~N_X86|))

{$IFNDEF FLAG_FPC}{$REGION 'typed_commands'}{$ENDIF}
define(~typed_commands|, 
  ~
    procedure drop_$1 cmdhdr;
    procedure dup_$1 cmdhdr;
    procedure nip_$1 cmdhdr;
    procedure swap_$1 cmdhdr;
    procedure over_$1 cmdhdr;
    procedure tuck_$1 cmdhdr;
    procedure lrot_$1 cmdhdr;
    procedure rrot_$1 cmdhdr;
    procedure lrotn_$1 cmdhdr;
    procedure rrotn_$1 cmdhdr;
    procedure pick_$1 cmdhdr;
    procedure _comma_$1 cmdhdr;
    procedure _dog_$1 cmdhdr;
    procedure _exclamation_$1 cmdhdr;
    procedure ptr_plus_$1 cmdhdr;
    procedure _to_$1 cmdhdr;
    procedure _compile_to_$1 cmdhdr;
    procedure _run_to_$1 cmdhdr;
    procedure _interpret_to_$1 cmdhdr;
    procedure _value_$1 cmdhdr;
    procedure _variable_$1 cmdhdr;
    procedure RunValue_$1 cmdhdr;
    procedure literal_$1 cmdhdr;
    procedure run_literal_$1 cmdhdr
  define(~all_implement|, all_implement 
    ~
     ifdef(~_IA32|,
       ~
         procedure drop_$1 cmdhdr;
         idle(asm
           sub [eax], 4
         end;)
         {procedure dup_$1 cmdhdr;
         idle(asm
           mov ecx, [eax]
           mov edx, [ecx-4]
           mov [ecx], edx
           add [eax], 4
         end;)}
         procedure dup_$1 cmdhdr; body(Move(WVar(-$2), WVar(0), $2); WInc($2); )
         procedure nip_$1 cmdhdr;
         idle(asm
           mov ecx, [eax]
           lea ecx, [ecx-4]
           mov edx, [ecx]
           mov [ecx-4], edx
           mov [eax], ecx
         end;)
         procedure swap_$1 cmdhdr;
         idle(asm
           mov ecx, [eax]
           mov edx, [ecx-4]
           xchg [ecx-8], edx
           mov [ecx-4], edx
         end;)
         procedure over_$1 cmdhdr;
         idle(asm
           mov ecx, [eax]
           mov edx, [ecx-8]
           mov [ecx], edx
           add [eax], 4
         end;)
         procedure tuck_$1 cmdhdr;
         idle(asm // ab-bab  @wp=eax 
           mov ecx, [eax]       // ecx := wp 
           add [eax], 4         // @wp++
           mov edx, [ecx-4]     // edx := b
           mov [ecx], edx       // top := b
           mov eax, [ecx-8]     // eax := a
           mov [ecx-4], eax     // top[1] := a
           mov [ecx-8], edx     // top[2] := b
         end;)
       |,
       procedure drop_$1 cmdhdr; body(Dec(WP, $2))
       procedure dup_$1 cmdhdr; body(Move(WVar(-$2), WVar(0), $2); WInc($2))
       procedure nip_$1 cmdhdr; body(Move(WVar(-1*$2), WVar(-2*$2), $2); Dec(WP, $2))
       procedure swap_$1 cmdhdr; body(Move(WVar(-$2), WP^, $2); Move(WVar(-2*$2), WVar(-$2), $2); Move(WP^, WVar(-2*$2), $2);)
       procedure over_$1 cmdhdr; body(Move(WVar(-2*$2), WVar(0), $2); Inc(WP, $2))
       procedure tuck_$1 cmdhdr; body(Move(WVar(-2*$2), WVar(-1*$2), 2*$2); Move(WVar(0), WVar(-2*$2), $2); WInc($2);body)
     )
     procedure lrot_$1 cmdhdr; 
     body(
       Move(WVar(-1*$2), WP^, $2);
       Move(WVar(-3*$2), WVar(-1*$2), $2);
       Move(WVar(-2*$2), WVar(-3*$2), $2);
       Move(WP^, WVar(-2*$2), $2);
     )
     procedure rrot_$1 cmdhdr;
     body( 
       Move(WVar(-1*$2), WP^, $2);
       Move(WVar(-2*$2), WVar(-1*$2), $2);
       Move(WVar(-3*$2), WVar(-2*$2), $2);
       Move(WP^, WVar(-3*$2), $2);
     )
     procedure lrotn_$1 cmdhdr; 
     var
       N: Integer;
     body( 
       Dec(WP, SizeOf(TInt));
       N := TInt(WP^);
       Move(WVar(-$2*N), WVar(0), $2);
       while N > 0 do begin
         Move(WVar(-$2*(N-1)), WVar(-$2*N), $2);
         Dec(N);
       end;
       //Move(WVar(0), WVar(-$2), $2);
     )
     procedure rrotn_$1 cmdhdr;
     var
       I: Integer;
       N: Integer;
     body(
       Dec(WP, SizeOf(TInt));
       N := TInt(WP^);
       //Move(WVar(-$2), WVar(0), $2);
       for I := 0 to N - 1 do
         Move(WVar(-$2*(I+1)), WVar(-$2*I), $2);
       Move(WVar(0), WVar(-N*$2), $2);
     )
     procedure pick_$1 cmdhdr; 
     body( 
       Move(WVar(-SizeOf(TInt) -$2*TInt(WVar(-SizeOf(TInt)))), 
            WVar(-SizeOf(TInt)),
            $2);
       WInc($2 - SizeOf(TInt));
     )
     procedure _comma_$1 cmdhdr; body( Dec(WP, $2); ifelse(~|,$1,
                                                            EWI(Integer(WP^)),
                                                            EWV(WP, $2); ) )
     procedure _dog_$1 cmdhdr; body( Move(Pointer(WVar(-PSize))^, WVar(-PSize), $2); Inc(WP, $2 - PSize) )
     procedure _exclamation_$1 cmdhdr; body( Move(WVar(-PSize-$2), Pointer(WVar(-PSize))^, $2); Dec(WP, PSize + $2) )
     procedure ptr_plus_$1 cmdhdr; body( PtrInt(WVar(-SizeOf(Pointer))) := PtrInt(WVar(-SizeOf(Pointer))) + $2; )
     procedure _to_$1 cmdhdr; body( if State <> FS_INTERPRET then _compile_to_$1(Machine, Command) else _interpret_to_$1(Machine, Command); )
     procedure _compile_to_$1 cmdhdr; body( BuiltinEWO('run@genname($1, ~to|)'); EWO(NextName); )
     procedure _run_to_$1 cmdhdr; var O: TOpcode; body( O := ERO; Move(WVar(-$2), C[O].Data^, $2); Dec(WP, $2); )
     procedure _interpret_to_$1 cmdhdr; var N: TString; Comm: PForthCommand; body( N := NextName; Comm := FindCommand(N);
               if Comm = nil then begin LogError('unkown name after genname($1, ~to|): ' + N); FSession := False; Exit; end; 
               Move(WVar(-$2), Comm.Data^, $2); Dec(WP, $2);
             )
     procedure _value_$1 cmdhdr; body( with ReserveName(SNN)^ do begin Data := Here; Code := RunValue_$1; Move(WVar(-$2), Here^, $2); Dec(WP, $2); EA($2); Flags := Flags and not 1; end; )
     procedure _variable_$1 cmdhdr; body( with ReserveName(SNN)^ do begin Data := Here; Code := PutDataPtr; {Dec(WP, $2); Move(WP^, Here^, $2);} EA($2); end; )
     procedure RunValue_$1 cmdhdr; body( Move(Command.Data^, WP^, $2); Inc(WP, $2); )
    procedure literal_$1 cmdhdr; body( BuiltinEWO('genname($1, (literal))'); Dec(WP, $2); 
                                       ifelse(~|,$1,
                                              EWI(Integer(WP^)), 
                                              EWV(WP, $2);) )
    procedure run_literal_$1 cmdhdr; body( ERV(WP, $2); Inc(WP, $2); )
    |
  )
  define(~regist_all_commands|, regist_all_commands
    ~
     Machine.AddCommand('genname($1, drop)', drop_$1);
     Machine.AddCommand('genname($1, dup)', dup_$1);
     Machine.AddCommand('genname($1, nip)', nip_$1);
     Machine.AddCommand('genname($1, swap)', swap_$1);
     Machine.AddCommand('genname($1, over)', over_$1);
     Machine.AddCommand('genname($1, tuck)', tuck_$1);
     Machine.AddCommand('genname($1, lrot)', lrot_$1);
     Machine.AddCommand('genname($1, rrot)', rrot_$1);
     Machine.AddCommand('genname($1, lrotn)', lrotn_$1);
     Machine.AddCommand('genname($1, rrotn)', rrotn_$1);
     Machine.AddCommand('genname($1, pick)', pick_$1);
     Machine.AddCommand('$1,', _comma_$1);
     Machine.AddCommand('$1@', _dog_$1);
     Machine.AddCommand('$1!', _exclamation_$1);
     Machine.AddCommand('ptr+$1', ptr_plus_$1);
     Machine.AddCommand('genname($1, to)', _to_$1, True);
     Machine.AddCommand('compile@genname($1, to)', _compile_to_$1);
     Machine.AddCommand('run@genname($1, to)', _run_to_$1);
     Machine.AddCommand('interpret@genname($1, to)', _interpret_to_$1);
     Machine.AddCommand('genname($1, value)', _value_$1);
     Machine.AddCommand('genname($1, constant)', _value_$1);
     Machine.AddCommand('genname($1, variable)', _variable_$1);
     Machine.AddCommand('genname($1, literal)', literal_$1, True);
     Machine.AddCommand('genname($1, (literal))', run_literal_$1);
    |)
|)
{$IFNDEF FLAG_FPC}{$ENDREGION}{$ENDIF}

  typed_commands(, 4);
  typed_commands(ptr, 4);
  typed_commands(int, 4);
  typed_commands(int8, 1);
  typed_commands(int16, 2);
  typed_commands(int32, 4);
  typed_commands(int64, 8);
  typed_commands(uint, 4);
  typed_commands(uint8, 1);
  typed_commands(uint16, 2);
  typed_commands(uint32, 4);
  typed_commands(uint64, 8);
  typed_commands(embro, 4);
  typed_commands(float, 4);
  typed_commands(double, 8);
  typed_commands(extended, 10);

procedure LoadCommands(Machine: TForthMachine);

implementation

all_implement

procedure LoadCommands(Machine: TForthMachine);
begin
  regist_all_commands;
end;

end.
