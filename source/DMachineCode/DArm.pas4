unit DArm;

interface
dnl(
changequote(~,|)

define(~all_implement|, ~|)
define(~all_interface|, ~// arm mnemonics|
  )
define(~AsmCode|, ~
  define(~all_interface|, all_interface~
    procedure $1$2; overload;|)
  define(~all_implement|, all_implement~
procedure TArm.$1$2;
begin
  $3
end;
|)|)

// foreach
divert(~-1|)
# foreach(x, (item_1, item_2, ..., item_n), stmt)
#   parenthesized list, simple version
define(~foreach|, ~pushdef(~$1|)_foreach($@)popdef(~$1|)|)
define(~_arg1|, ~$1|)
define(~_foreach|, ~ifelse(~$2|, ~()|, ~|,
  ~define(~$1|, _arg1$2)$3~|$0(~$1|, (shift$2), ~$3|)|)|)
divert~|dnl

// conditions
define(~_EQ|, ~Hex(0)|)
define(~_NE|, ~Hex(1)|)
define(~_HS|, ~Hex(2)|) define(~_CS|, ~Hex(2)|)
define(~_LO|, ~Hex(3)|) define(~_CC|, ~Hex(3)|)
define(~_MI|, ~Hex(4)|)
define(~_PL|, ~Hex(5)|)
define(~_VS|, ~Hex(6)|)
define(~_VC|, ~Hex(7)|)
define(~_HI|, ~Hex(8)|)
define(~_LS|, ~Hex(9)|)
define(~_GE|, ~Hex(A)|)
define(~_LT|, ~Hex(B)|)
define(~_GT|, ~Hex(C)|)
define(~_LE|, ~Hex(D)|)
define(~_AL|, ~Hex(E)|) define(~_|, _AL)
define(~_NV|, ~Hex(F)|)
define(~_conds|, ~(, EQ, NE, HS, CS, LO, CC, MI, PL, VS, VC, HI, LS, GE, LT, GT,
                   LE, AL, NV,)|)
// descriptions
define(~_EQ_desc|, ~Z set (equal)|)
define(~_NE_desc|, ~Z clear (not equal)|)
define(~_HS_desc|, ~C set|) define(~_CS_desc|, ~_HS_desc|)
define(~_LO_desc|, ~C clear (unsigned lower)|) define(~_CC_desc|, ~_LO_desc|)
define(~_MI_desc|, ~N set (negative)|)
define(~_PL_desc|, ~N clear (positive or zero)|)
define(~_VS_desc|, ~V set (overflow)|)
define(~_VC_desc|, ~V clear (no overflow)|)
define(~_HI_desc|, ~C set and Z clear (unsigned higher)|)
define(~_LS_desc|, ~C clear or Z (set unsigned lower or same)|)
define(~_GE_desc|, ~N set and V set, or N clear and V clear (>or=)|)
define(~_LT_desc|, ~N set and V clear, or N clear and V set|)
define(~_GT_desc|, ~Z clear, and either N set and V set, or clear and V set (>)|)
define(~_LE_desc|, ~Z set, or N set and V clear, or N clear and V set (<, or =)|)
define(~_AL_desc|, ~always|)
define(~_NV_desc|, ~reserved|)

define(~Cond|, ((Ord($1)) shl 28))
define(~__S|, ((Ord($1)) shl 20))
define(~__I|, ((Ord($1)) shl 25))
define(~__S_S|, Hex(1))
define(~__S_|, Hex(0))

// cccc101Loooooooooooooooooooooooo c=cond o=offset
define(~_B|,  ~AsmCode(~B$1|,  ~(Offset: Cardinal)|, WriteU(Cond(_$1) or (10 shl 24) or Offset);)|)
define(~_BL|, ~AsmCode(~BL$1|, ~(Offset: Cardinal)|, WriteU(Cond(_$1) or (11 shl 24) or Offset);)|)
// cccc00Io oooSnnnn dddd#### ######## c=cond I=immediate o=opcode S=set_condition_code d=destination n=1st #=operand2
define(~all_interface|, all_interface~
  // data processing (arithmetic & logic)|)
AsmCode(~WriteDataTrans|, ~(C, I, O, S, N, D: Byte; R: Cardinal)|, WriteU(Cond(C) or __I(I) or (O shl 22) or __S(S) or (N shl 16) or (D shl 12) or R);)
AsmCode(~WriteDataTransR|, ~(C, O, S: Byte; N, D, R: TArmReg; F: Byte)|, WriteDataTrans(C, 0, O, S, Ord(N), Ord(D), (F shl 4) or Ord(R));)
AsmCode(~WriteDataTransI|, ~(C, O, S: Byte; N, D: TArmReg; I, R: Byte)|, WriteDataTrans(1, 0, O, S, Ord(N), Ord(D), ((R and Hex(F)) shl 8) or I);)
define(~_DP|, ~AsmCode(~$1$2|, ~(Dst, Src1, Src2: TArmReg; Shift: Word = 0)|,  WriteDataTransR(_$2, $3, 0, Src1, Dst, Src2, Shift);)
               AsmCode(~$1$2S|, ~(Dst, Src1, Src2: TArmReg; Shift: Byte = 0)|,  WriteDataTransR(_$2, $3, 1, Src1, Dst, Src2, Shift); )
               AsmCode(~$1$2|, ~(Dst, Src: TArmReg; Imm: Byte; Rotate: Byte = 0)|,  WriteDataTransI(_$2, $3, 0, Src, Dst, Imm, Rotate); )
               AsmCode(~$1$2S|, ~(Dst, Src: TArmReg; Imm: Byte; Rotate: Byte = 0)|,  WriteDataTransI(_$2, $3, 1, Src, Dst, Imm, Rotate); )|)

define(~all_interface|, all_interface~
  // branch menmonics|)
foreach(~_cond|, _conds, ~_B(_cond)|)
foreach(~_cond|, _conds, ~_BL(_cond)|)
# foreach(~_cond|, _conds, foreach(~mne|, _datatransmne, ~PSR(mne, _cond, Hex(0))|))
foreach(~_cond|, _conds, ~_DP( ifelse(_cond,~|,~_|)AND, _cond, Hex(0))|)
foreach(~_cond|, _conds, ~_DP( EOR, _cond, Hex(1))|)
foreach(~_cond|, _conds, ~_DP( SUB, _cond, Hex(2))|)
foreach(~_cond|, _conds, ~_DP( RSB, _cond, Hex(3))|)
foreach(~_cond|, _conds, ~_DP( ADD, _cond, Hex(4))|)
foreach(~_cond|, _conds, ~_DP( ADC, _cond, Hex(5))|)
foreach(~_cond|, _conds, ~_DP( SBC, _cond, Hex(6))|)
foreach(~_cond|, _conds, ~_DP( RSC, _cond, Hex(7))|)
foreach(~_cond|, _conds, ~_DP( TST, _cond, Hex(8))|)
foreach(~_cond|, _conds, ~_DP( TEQ, _cond, Hex(9))|)
foreach(~_cond|, _conds, ~_DP( CMP, _cond, Hex(A))|)
foreach(~_cond|, _conds, ~_DP( CMN, _cond, Hex(B))|)
foreach(~_cond|, _conds, ~_DP( ORR, _cond, Hex(C))|)
foreach(~_cond|, _conds, ~_DP( MOV, _cond, Hex(D))|)
foreach(~_cond|, _conds, ~_DP( BIC, _cond, Hex(E))|)
foreach(~_cond|, _conds, ~_DP( MVN, _cond, Hex(F))|)

define(~all_interface|, all_interface~ 
  // PSR transfer (for CPSR and SPSR registers)|)
define(~_PSR|, ~
  AsmCode(~MRS$1|,  ~(r: TArmReg; p: TArmPSR)|, WriteU(Cond(_$1) or (2 shl 23) or (Ord(p) shl 22) or (Hex(F) shl 16) or (Ord(r) shl 12));)
  AsmCode(~MSR$1|,  ~(p: TArmPSR; r: TArmReg)|, WriteU(Cond(_$1) or (2 shl 23) or (Ord(p) shl 22) or (Hex(2) shl 20) or (Hex(9) shl 16) or (Hex(F) shl 12) or Ord(r));)
  AsmCode(~MSR$1|,  ~(p: TArmPSRf; Rotate, Imm: Byte)|, WriteU(Cond(_$1) or (1 shl 25) or (2 shl 23) or (Ord(p) shl 22) or (Hex(2) shl 20) or (Hex(8) shl 16) or (Hex(F) shl 12) or ((Rotate and $F) shl 8) or Imm);)
  AsmCode(~MSR$1|,  ~(p: TArmPSRf; r: TArmReg)|, WriteU(Cond(_$1) or (0 shl 25) or (2 shl 23) or (Ord(p) shl 22) or (Hex(2) shl 20) or (Hex(8) shl 16) or (Hex(F) shl 12) or Ord(r));)|)
foreach(~_cond|, _conds, ~_PSR(_cond)|)


define(~all_interface|, all_interface~ 
  // multiplication|)
AsmCode(~Multiplication|, (C, S: Byte; Rd, Rm, Rs: TArmReg),  WriteU(Cond(C) or (S shl 20) or (Ord(Rd) shl 16) or (Ord(Rs) shl 8) or (Ord(9) shl 4) or Ord(Rm));)
AsmCode(~MultiplicationA|, (C, S: Byte; Rd, Rm, Rs, Rn: TArmReg),  WriteU(Cond(_$1) or (Hex(1) shl 21) or (S shl 20) or (Ord(Rd) shl 16) or (Ord(Rn) shl 12) or (Ord(Rs) shl 8) or (Ord(9) shl 4) or Ord(Rm));)
define(~_MUL|, ~
  AsmCode(~MUL$1$2|,  ~(Rd, Rm, Rs: TArmReg)|, Multiplication(_$1, __S_$2, Rd, Rm, Rs);)
  AsmCode(~MLA$1$2|,  ~(Rd, Rm, Rs, Rn: TArmReg)|, MultiplicationA(_$1, __S_$2, Rd, Rm, Rs, Rn);)
  |)
foreach(~_cond|, _conds, ~_MUL(_cond,) _MUL(_cond,S)|)

define(~sign_in_mulU|, ~1|)
define(~sign_in_mulS|, ~0|)
AsmCode(~LongMultiplication|, (C, U, A, S: Byte; RdLo, RdHi, Rm, Rs: TArmReg),  WriteU(Cond(C) or (1 shl 23) or (U shl 22) or (A shl 21) or (S shl 20) or (Ord(RdHi) shl 16) or (Ord(RdLo) shl 12) or (Ord(Rs) shl 8) or (9 shl 4) or Ord(Rm));)
define(~_MULL|, ~
  AsmCode(~$3MULL$1$2|,  ~(RdLo, RdHi, Rm, Rs: TArmReg)|, LongMultiplication(_$1, sign_in_mul$3, 0, __S_$2, RdLo, RdHi, Rm, Rs);)
  AsmCode(~$3MLAL$1$2|,  ~(RdLo, RdHi, Rm, Rs: TArmReg)|, LongMultiplication(_$1, sign_in_mul$3, 1, __S_$2, RdLo, RdHi, Rm, Rs);)
  |)
foreach(~_cond|, _conds, ~_MULL(_cond,,S) _MULL(_cond,S,S) _MULL(_cond,,U) _MULL(_cond,S,U)|)

AsmCode(~DataTransferI|, (C, P, U, B, W, L: Byte; Rn, Rd: TArmReg; O: Word),  WriteU(Cond(C) or (1 shl 26) or (1 shl 25) or (P shl 24) or (U shl 23) or (B shl 22) or (W shl 21) or (L shl 20) or (Ord(Rn) shl 16) or (Ord(Rd) shl 12) or O);)
AsmCode(~DataTransfer|, (C, P, U, B, W, L: Byte; Shift: Byte; Rm: TArmReg),  WriteU(Cond(C) or (1 shl 26) or (0 shl 25) or (P shl 24) or (U shl 23) or (B shl 22) or (W shl 21) or (L shl 20) or (Ord(Rn) shl 16) or (Ord(Rd) shl 12) or (Shift shl 4) or Ord(Rm));)
define(~_data_transfer_byteB|, ~1|)
define(~_data_transfer_byte|, ~0|)
define(~_data_transfer_postindexT|, ~1|)
define(~_data_transfer_postindex|, ~0|)
define(~_data_transfer_opSTR|, ~0|)
define(~_data_transfer_opLDR|, ~1|)
define(~_DataTransfer|, ~
  // <expression> --> [pc] SmallInt
  // [Rn, expression]{!} --> [R] [Smallint] WriteBack
  // [Rn, +-Rm, shift] --> [R] Sign [R] Byte
  // [Rn] expression --> [R] SmallInt
  // [Rn] Rm shift --> [R] Sign R Byte
  AsmCode(~$4$1$2$3|,  ~(Rd: TArmReg; O: Word)|, $4$1$2$3(Rd, [pc], [O]);)
  AsmCode(~$4$1$2$3|,  ~(Rd: TArmReg; const Rn: array of TArmReg; W: TArmWriteBack = ARM_DONOTWRITE)|, $4$1$2$3(Rd, [pc], [0], W);)
  AsmCode(~$4$1$2$3|,  ~(Rd: TArmReg; const Rn: array of TArmReg; const O: array of SmallInt; W: TArmWriteBack = ARM_DONOTWRITE)|, DataTransferI(_$1, 1, Ord(O[0] >= 0), _data_transfer_byte$2, Ord(W), _data_transfer_op$4, Rn[0], Rd, O[0] and $FFF);)
  AsmCode(~$4$1$2$3|,  ~(Rd: TArmReg; const Rn: array of TArmReg; const Rm: array of TArmReg; Shift: Byte = 0; W: TArmWriteBack = ARM_DONOTWRITE)|, $4$1$2$3(Rd, Rn, ARM_PLUS, Rm, Shift, W);)
  AsmCode(~$4$1$2$3|,  ~(Rd: TArmReg; const Rn: array of TArmReg; Sign: TArmSign; const Rm: array of TArmReg; Shift: Byte = 0; W: TArmWriteBack = ARM_DONOTWRITE)|, DataTransfer(_$1, 1, Ord(Sign), _data_transfer_byte$2, Ord(W), _data_transfer_op$4, Rn[0], Shift, Rm[0]);)
  AsmCode(~$4$1$2$3|,  ~(Rd: TArmReg; const Rn: array of TArmReg; O: SmallInt)|, DataTransferI(_$1, 0, Ord(O >= 0), _data_transfer_byte$2, 1, _data_transfer_op$4, Rn[0], Rd, O and $FFF);)
  AsmCode(~$4$1$2$3|,  ~(Rd: TArmReg; const Rn: array of TArmReg; Rm: TArmReg; Shift: Byte = 0)|, $4$1$2$3(Rd, Rn, ARM_PLUS, Rm, Shift);)
  AsmCode(~$4$1$2$3|,  ~(Rd: TArmReg; const Rn: array of TArmReg; Sign: TArmSign; Rm: TArmReg; Shift: Byte = 0)|, DataTransfer(_$1, 0, Ord(Sign), _data_transfer_byte$2, 1, _data_transfer_op$4, Rn[0], Rd, Shift, Rm);)
  |)
foreach(~_cond|, _conds, ~_DataTransfer(_cond,,,LDR) _DataTransfer(_cond,B,,LDR) _DataTransfer(_cond,,T,LDR) _DataTransfer(_cond,B,T,LDR) _DataTransfer(_cond,,,STR) _DataTransfer(_cond,B,,STR) _DataTransfer(_cond,,T,STR) _DataTransfer(_cond,B,T,STR)|)
// TODO <LDR|STR>{cond}<H|SH|SB>
// TODO <LDM|STM>{cond}<FD|ED|FA|EA|IA|IB|DA|DB>

define(~_swap_byteB|, ~1|)
define(~_swap_byte|, ~0|)
AsmCode(~SwapInstruction|, (C, B: Byte; Rd, Rm, Rn: TArmReg),  WriteU(Cond(C) or (2 shl 23) or (B shl 22) or (Ord(Rn) shl 16) or (Ord(Rd) shl 12) or (9 shl 4) or Ord(Rm));)
define(~_Swap|,~
  AsmCode(SWP$1$2, (Rd, Rm: TArmReg; const Rn: array of TArmReg), SwapInstruction(_$1, _swap_byte$2, Rd, Rm, Rn[0]);)
  |)
foreach(~_cond|, _conds, ~_Swap(_cond,) _Swap(_cond,B)|)
)

uses
  DMachineCode;


type
  TArmReg =     (
                        r0      = 0,
                        r1      = 1,
                        r2      = 2,
                        r3      = 3,
                        r4      = 4,
                        r5      = 5,
                        r6      = 6,
                        r7      = 7,
                        r8      = 8,
                        r9      = 9,
                        r10     = 10,
                        r11     = 11,
                        r12     = 12,
                        r13     = 13,
                        r14     = 14,
                        r15     = 15
                );
  TArmPSR  =       (
                        CPSR    = 0,
                        SPSR    = 1
                );
  TArmPSRf  =       (
                        CPSR_flg        = 0,
                        SPSR_flg        = 1
                );
  TArmSign =
                (
                        ARM_MINUS       = 0,
                        ARM_PLUS        = 1
                );
  TArmWriteBack =
                (
                        ARM_DONOTWRITE  = 0,
                        ARM_WRITE       = 1
                );

const
  // alternative registers' names
  sp = r13;
  lr = r14;
  pc = r15;
  CPSR_all = CPSR;
  SPSR_all = SPSR;

type
  TArm = class(TMachineCode)
  private
  public
  public
    constructor Create(BaseSize: Integer);
    all_interface
  end;

implementation

constructor TArm.Create(BaseSize: Integer);
begin
end;
all_implement
end.
