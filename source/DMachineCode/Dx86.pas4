unit Dx86;

interface 
dnl(
changequote(~,|)

define(~all_implement|, ~|)
define(~all_interface|, ~// x86 mnemonics|)
define(~AsmCode|, ~
  define(~all_interface|, all_interface~
    procedure $1$2; overload;|)
  define(~all_implement|, all_implement~
procedure Tx86.$1$2;
begin
  $3
end;
|)
  |
)
// косвенность
define(~K|, ~const $1: array of $2|)
// assert косвенность
define(~AK|, ~if Length($1) <> 1 then begin
    // TODO
    Exit;
  end;|)
define(~ModRM_Mod|, ~(($1) shl 6)|)
define(~ModRM_Reg|, ~(($1) shl 3)|)
define(~ModRM_R_M|, ~($1)|)
define(~ModRM|, ~WriteB(ModRM_Mod($1) + ModRM_Reg($2) + ModRM_R_M($3))|)
define(~SIB_Mul|, ~(($1) shl 6)|)
define(~SIB_Reg2|, ~(($1) shl 3)|)
define(~SIB_Reg1|, ~($1)|)
define(~SIB|, ~WriteB(SIB_MUL($1) + SIB_Reg2($2) + SIB_Reg1($1))|)
define(~SwitchMode|, ~  if FMode = $1 then
  WriteB(Hex(66));|)

// xxx
define(~mne0|, ~AsmCode($1, ~|, WriteB($2);)|)

// xxx int
define(~mnei|, ~AsmCode($1, ~(I: LongInt)|, WriteB($2);
  WriteI(I);)|)

// 1 IMMEDIATE OPERAND
// i := immediate
// xxx byte
define(~mneib|, ~AsmCode($1, ~(B: Tx86b)|, WriteB($2);
  WriteB(Byte(B));)|)
// xxx word
define(~mneiw|, ~AsmCode($1, ~(W: Tx86w)|, WriteB($2);
  WriteW(Word(W));)|)
// xxx dword
define(~mneid|, ~AsmCode($1, ~(D: Tx86d)|, WriteB($2);
  WriteI(LongInt(D));)|)

// REGISTER/MEMORY AND IMMEDIATE OPERANDS
// g := register/memory
define(~mnexix|, ~
 define(~mner$1ib|, ~AsmCode($|~1, ~(Reg: Tx86Reg|$|~3~; B: Tx86b)|, WriteB($|~2 + Ord(Reg));
  WriteB(Byte(B));)|)
 define(~mner$1iw|, ~AsmCode($|~1, ~(Reg: Tx86Reg|$|~3~; W: Tx86w)|, WriteB($|~2 + Ord(Reg));
  WriteW(Word(W));)|)
 define(~mner$1id|, ~AsmCode($|~1, ~(Reg: Tx86Reg|$|~3~; D: LongInt)|, WriteB($|~2 + Ord(Reg));
  WriteI(LongInt(D));)|)
  
 define(~mnem$1ib|, ~AsmCode($|~1, ~(Reg: Tx86Reg|$|~3~; T: )|, WriteB($|~2);
  $2
  WriteB(Byte(B));)|)
 define(~mnem$1iw|, ~AsmCode($|~1, ~(Reg: Tx86Reg|$|~3~; W: Tx86w)|, SwitchMode(X86_MODE_16);
  WriteB($|~2 + Ord(Reg));
  $2
  WriteW(Word(W));)|)
 define(~mnem$1id|, ~AsmCode($|~1, ~(Reg: Tx86Reg|$|~3~; D: LongInt)|, SwitchMode(X86_MODE_32);
  WriteB($|~2 + Ord(Reg));
  $2
  WriteI(LongInt(D));)|)|)

 define(~mneg$1ib|, ~|)
 define(~mneg$1iw|, ~|)
 define(~mneg$1id|, ~|)
mnexix(b, // TODO)
mnexix(w, // TODO)
mnexix(d, // TODO)

// REGISTER/MEMORY AND REGISTER OPERANDS
define(~mnerxrx|, ~
  define(~mner$1r$1|, ~AsmCode($|~1, (Dst, Src: Tx86Reg$|~3),  $2)|)
|)
mnerxrx(b, WriteB($2); 
  ModRM(3, Dst, Src);, 
  Tx86b, Byte);
mnerxrx(w, SwitchMode(X86_MODE_32); 
  WriteB($2);
  ModRM(3, Dst, Src);, 
  Tx86w, Word);
mnerxrx(d, SwitchMode(X86_MODE_32);
  WriteB($2); 
  ModRM(3, Dst, Src);, 
  LongIng, LongInt);
define(~mnemxrx|, ~
 define(~mner$1m$1|, ~AsmCode($|~1, (Reg: Tx86Reg$|~3; K(Mem, LongInt)),  $2)|)
 define(~mnem$1r$1|, ~AsmCode($|~1, (K(Mem, LongInt); Reg: Tx86Reg$|~3),  $2)|)
  |)
define(~mnerws|, ~AsmCode($1, (Reg: Tx86Reg$3; S: Tx86RegSreg),  WriteB($2); // TODO)|)
define(~mnesrw|, ~AsmCode($1, (S: Tx86RegSreg; Reg: Tx86Reg$3),  WriteB($2); // TODO)|)
define(~mnemws|, ~AsmCode($1, (M: Tx86w; S: Tx86RegSreg),  WriteB($2); // TODO)|)
define(~mnesmw|, ~AsmCode($1, (S: Tx86RegSreg; M: Tx86w),  WriteB($2); // TODO)|)

// xxx reg
define(~mner|, ~AsmCode($1, ~(Reg: Tx86Reg$3)|, WriteB($2 + Ord(Reg));)|)

// xxx reg int
define(~mneri|, ~AsmCode($1, ~(Reg: Tx86Reg$3; I: LongInt)|, WriteB($2 + Ord(Reg));
  SwitchMode(X86_MODE_32);
  WriteI(I);)|)

// xxx reg reg
define(~mnerr|, ~AsmCode($1, ~(Reg1, Reg2: Tx86Reg$3)|, WriteB($2); 
  WriteB(ModRM_Mod(3) + ModRM_Reg(Ord(Reg1)) + ModRM_R_M(Ord(Reg2)));)|)

// xxx reg [reg]
define(~mnerk|, ~AsmCode($1, ~(Dst: Tx86Reg$3; K(Reg, Tx86Reg$3))|,
  AK(Reg);
  WriteB($2);
  if Reg[0] = EBP then begin
    WriteB(ModRM_Mod(1) + ModRM_Mod(Ord(Reg)) + ModRM_R_M(Ord(EBP)));
    WriteB(0);
  end else if Reg[0] = ESP then begin
    WriteB(ModRM_Mod(0) + ModRM_Reg(Ord(Reg)) + ModRM_R_M(Ord(ESP)));
    WriteB(SIB_Mul(0) + SIB_Reg2(Ord(ESP)) + SIB_Reg1(Ord(ESP)));
  end else begin
    WriteB(ModRM_Mod(0) + ModRM_Reg(Ord(Dst)) + ModRM_R_M(Ord(Reg[0])));
  end;)|)

// xxx reg, [reg+byte]
define(~mnerko8|, ~AsmCode($1, ~(Dst: Tx86Reg$3; K(Reg, Tx86Reg$3); Offset: Tx86b)|,
  AK(Reg);
  WriteB($2);
  if Reg[0] = ESP then begin
    WriteB(ModRM_Mod(1) + ModRM_Mod(Ord(Dst)) + ModRM_R_M(Ord(ESP)));
    WriteB(SIB_Mul(0) + SIB_Reg2(Ord(ESP)) + SIB_Reg1(Ord(ESP)));
  end else begin
    WriteB(ModRM_Mod(1) + ModRM_Mod(Ord(Dst)) + ModRM_R_M(Ord(Reg[0])));
  end;
  WriteB(Byte(Offset));)|)

// xxx reg, [reg + int]
define(~mnerko32|, ~AsmCode($1, ~(Dst: Tx86Reg$3; K(Reg, Tx86Reg$3); Offset: LongInt)|,
  AK(Reg);
  WriteB($2);
  if Reg[0] = ESP then begin
  end else begin
    WriteB(ModRM_Mod(2) + ModRM_Mod(Ord(Dst)) + ModRM_R_M(Ord(Reg[0])));
  end;
  WriteI(Offset);)|)

// xxx reg, [reg1 + reg2*mul + byte] 
define(~mnerkmo8|, ~AsmCode($1, ~(Dst: Tx86Reg$3; K(Reg1, Tx86Reg$3); K(Reg2, Tx86Reg$3); Mul: Byte; Offset: Tx86b)|,
  AK(Reg1);
  AK(Reg2);
  if Reg2[0] = ESP then begin
    // такое нельзя делать...
    Exit
  end;
  if (Mul and not 3) <> 0 then begin
    // такого тоже нельзя делать...
    Exit
  end;
  WriteB($2);
  WriteB(ModRM_Mod(1) + ModRM_Mod(Ord(Dst)) + ModRM_R_M(Ord(ESP)));
  WriteB(SIB_Mul(Byte(Mul)) + SIB_Reg2(Ord(Reg2[0])) + SIB_Reg1(Ord(Reg1[0])));
  WriteB(Byte(Offset));)|)

// xxx reg, [reg1 + reg2*mul + int] 
define(~mnerkmo32|, ~AsmCode($1, ~(Dst: Tx86Reg$3; K(Reg1, Tx86Reg$3); K(Reg2, Tx86Reg$3); Mul: Byte; Offset: LongInt)|,
  AK(Reg1)
  AK(Reg2)
  if Reg2[0] = ESP then begin
    // такое нельзя делать...
    Exit
  end;
  if Reg1[0] = EBP then begin
    // так тоже делать нельзя
    Exit
  end;
  case Mul of
    1: Mul := 0;
    2: Mul := 1;
    4: Mul := 2;
    8: Mul := 3;
  else
    // такого тоже нельзя делать...
    Exit
  end;
  WriteB($2);
  WriteB(ModRM_Mod(2) + ModRM_Mod(Ord(Dst)) + ModRM_R_M(Ord(ESP)));
  WriteB(SIB_Mul(Mul - 1) + SIB_Reg2(Ord(Reg2[0])) + SIB_Reg1(Ord(Reg1[0])));
  WriteI(Offset);)|)

mnerko32(Test,  Hex(90))
mneib(ADD,  Hex(04))
mneiw(ADD,  Hex(05))
mneid(ADD,  Hex(05))
mnegbib(ADD,  Hex(80))
mnegwiw(ADD,  Hex(81))
mnegdid(ADD,  Hex(81))
mnegbib(ADD,  Hex(83), ~B|)
mnegwib(ADD,  Hex(83), ~W|)
mnegdib(ADD,  Hex(83))
mne0(NOP,  Hex(90))
mne0(REPNE,  Hex(F2))
mne0(SCASD,  Hex(AF))
dnl mneri(MOV,  Hex(B8))
dnl mnerr(MOV,  Hex(8B))
dnl mnerk(MOV,  Hex(8B))
dnl mnerko8(MOV,  Hex(8B))
dnl mnerko32(MOV,  Hex(8B))
dnl mnerkmo8(MOV,  Hex(8B))
dnl mnerkmo32(MOV,  Hex(8B))

mnerbrb(MOV, Hex(88), B)
mnerwrw(MOV, Hex(89), W)
mnerdrd(MOV, Hex(89))
mnerbmb(MOV, Hex(8A), B)
mnerwmw(MOV, Hex(8B), W)
mnerdmd(MOV, Hex(8B))
mnembrb(MOV, Hex(88), B)
mnemwrw(MOV, Hex(89), W)
mnemdrd(MOV, Hex(89))
mnerbib(MOV, Hex(B0), B)
mnerwiw(MOV, Hex(B8), W)
mnerdid(MOV, Hex(B8))
mnerws(MOV, Hex(8C), W)
mnesrw(MOV, Hex(8E), W)
mnemws(MOV, Hex(8C), W)
mnesmw(MOV, Hex(8E), W)

mner(INC,  Hex(40))
mner(DEC,  Hex(48))
mner(PUSH, Hex(50))
mner(POP,  Hex(58))
)

uses
  DMachineCode;

type
  // x86 types
  Tx86b = record V: ShortInt; end;
  Tx86w = record V: SmallInt; end;
  Tx86d = record V: LongInt; end;
  Tx86q = record V: Int64; end;
  Tx86type = (x86BYTE, x86WORD, x86DWORD, x86QWORD);
  // general x86 registers
  Tx86Reg = (
                EAX =                 0,
                ECX =                 1,
                EDX =                 2,
                EBX =                 3,
                ESP =                 4,
                EBP =                 5,
                ESI =                 6,
                EDI =                 7
            );
  // 16-bit x86 registers (rw)
  Tx86RegW = (
                AX =                  0,
                CX =                  1,
                DX =                  2,
                BX =                  3,
                SP =                  4,
                BP =                  5,
                SI =                  6,
                DI =                  7
            );
  // 8-bit x86 registers (rb)
  Tx86RegB = (
                AL =                  0,
                CL =                  1,
                DL =                  2,
                BL =                  3,
                AH =                  4,
                CH =                  5,
                DH =                  6,
                BH =                  7
            );
  // x86 mm registers
  Tx86RegMM = (
                MM0 =                 0,
                MM1 =                 1,
                MM2 =                 2,
                MM3 =                 3,
                MM4 =                 4,
                MM5 =                 5,
                MM6 =                 6,
                MM7 =                 7
            );
  // x86 xmm registers
  Tx86RegXMM = (
                XMM0 =                 0,
                XMM1 =                 1,
                XMM2 =                 2,
                XMM3 =                 3,
                XMM4 =                 4,
                XMM5 =                 5,
                XMM6 =                 6,
                XMM7 =                 7
            );
  // x86 Sreg register
  Tx86RegSreg = ( 
                ES =                    0,
                CS =                    1,
                SS =                    2,
                DS =                    3,
                FS =                    4,
                GS =                    5
                );
  // x86 modes
  Tx86Mode = (X86_MODE_32, X86_MODE_16);

type
  Tx86 = class(TMachineCode)
  private
    FMode: Tx86Mode;
  public
    property Mode: Tx86Mode read FMode write FMode;
  public
    constructor Create(BaseSize: Integer);
    all_interface
  end;

function x86b(I: ShortInt): Tx86b;
function x86w(I: SmallInt): Tx86w;
function x86d(I: LongInt): Tx86d;

implementation

function x86b(I: ShortInt): Tx86b;
begin
  Move(I, Result, SizeOf(I));
end;

function x86w(I: SmallInt): Tx86w;
begin
  Move(I, Result, SizeOf(I));
end;

function x86d(I: LongInt): Tx86d;
begin
  Move(I, Result, SizeOf(I));
end;

constructor Tx86.Create(BaseSize: Integer);
begin
  inherited Create(BaseSize);
  FMode := X86_MODE_32;
end;
all_implement
var
  c: Tx86;
initialization
  c := Tx86.Create(1000);
  c.MOV(EAX, 5);
  c.MOV(EBX, ECX);
  c.MOV(EDX, [ESP]);
  c.MOV(EDX, [ESP], [EAX], 4, x86b(67));
  c.MOV(EDX, [ESP], [EAX], 4, 1067);
  c.Free;
end.
